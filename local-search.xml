<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>4.15每日一题</title>
    <link href="/2022/04/15/4-15%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <url>/2022/04/15/4-15%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-385：迷你语法分析器"><a href="#LeetCode-385：迷你语法分析器" class="headerlink" title="LeetCode 385：迷你语法分析器"></a>LeetCode 385：迷你语法分析器</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>一道题做了一个多小时，人都麻了… 4.15今天日子也很特殊 哈哈哈！</p></blockquote><p>这道题的 NestedInteger 其实就是定义的一个新的数据类型，相当于集合之类的。核心思想就是栈的嵌套，先把 NestedInteger 类型的数字放入栈中，然后再将栈顶的元素top嵌套入栈的top-1中。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。</p><p>列表中的每个元素只可能是整数或整数嵌套列表</p><p>示例1</p><figure class="highlight nix"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;324&quot;</span>,<br>输出：<span class="hljs-number">324</span><br>解释：你应该返回一个 NestedInteger 对象，其中只包含整数值 <span class="hljs-number">324</span>。<br></code></pre></td></tr></table></figure><p>示例2</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：s = <span class="hljs-string">&quot;[123,[456,[789]]]&quot;</span>,<br>输出：[<span class="hljs-number">123</span>,[<span class="hljs-number">456</span>,[<span class="hljs-number">789</span>]]]<br>解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：<br><span class="hljs-number">1.</span> 一个 <span class="hljs-keyword">integer</span> 包含值 <span class="hljs-number">123</span><br><span class="hljs-number">2.</span> 一个包含两个元素的嵌套列表：<br>    i.  一个 <span class="hljs-keyword">integer</span> 包含值 <span class="hljs-number">456</span><br>    ii. 一个包含一个元素的嵌套列表<br>         <span class="hljs-keyword">a</span>. 一个 <span class="hljs-keyword">integer</span> 包含值 <span class="hljs-number">789</span><br></code></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法1：深度优先搜索"><a href="#方法1：深度优先搜索" class="headerlink" title="方法1：深度优先搜索"></a>方法1：深度优先搜索</h4><p>模拟</p><h4 id="方法2：栈"><a href="#方法2：栈" class="headerlink" title="方法2：栈"></a>方法2：栈</h4><p><img src="https://raw.githubusercontent.com/yiqiangshiyia/img/main/images/QQ%E6%88%AA%E5%9B%BE20220415164146.png" alt="图示模拟栈的过程"></p><p>当s[i] == ‘[‘时：建立一个’[]’，放入栈中</p><p>当isdigit(s[i])时：记录数字num</p><p>当s[i] == ‘,’ || s[i] == ‘]’时：如果数字不为空，将数字加入栈顶，重置数字num = 0</p><p>当s[i] == ‘]’ &amp;&amp; st.size()&gt;1时，将栈顶元素加入栈顶的倒数第二个元素中，直到栈的到小为1</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">NestedInteger <span class="hljs-title">deserialize</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;[&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">NestedInteger</span>(<span class="hljs-built_in">stoi</span>(s));<br>        stack&lt;NestedInteger&gt; st;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span>)<br>            &#123;<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">NestedInteger</span>());<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i]))<br>            &#123;<br>                num = num*<span class="hljs-number">10</span> + s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;,&#x27;</span> || s[i] == <span class="hljs-string">&#x27;]&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i<span class="hljs-number">-1</span>]))<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(flag)  num = num*<span class="hljs-number">-1</span>;<br>                    st.<span class="hljs-built_in">top</span>().<span class="hljs-built_in">add</span>(<span class="hljs-built_in">NestedInteger</span>(num));<br>                    num = <span class="hljs-number">0</span>;<br>                    flag = <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; st.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>                &#123;<br>                    NestedInteger ni = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    st.<span class="hljs-built_in">top</span>().<span class="hljs-built_in">add</span>(ni);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>b栈学习视频：<a href="https://www.bilibili.com/video/BV195411U7h4?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV195411U7h4?spm_id_from=333.337.search-card.all.click</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL:map unordered_map set unordered_set的用法和区别</title>
    <link href="/2022/04/10/C-STL-map-unordered-map-set-unordered-set%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/10/C-STL-map-unordered-map-set-unordered-set%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><table><thead><tr><th align="center"><strong>数据结构</strong></th><th align="center"><strong>map</strong></th><th align="center"><strong>unordered_map</strong></th><th align="center"><strong>set</strong></th><th align="center"><strong>unordered_set</strong></th></tr></thead><tbody><tr><td align="center">实现机理</td><td align="center">红黑树</td><td align="center">hash表</td><td align="center">红黑树</td><td align="center">hash表</td></tr><tr><td align="center">元素格式</td><td align="center">key+value</td><td align="center">key+value</td><td align="center">key</td><td align="center">key</td></tr><tr><td align="center">存储规律</td><td align="center">键升序</td><td align="center">无序</td><td align="center">键升序</td><td align="center">无序</td></tr><tr><td align="center">元素重复</td><td align="center">键不可,值可</td><td align="center">键不可,值可</td><td align="center">不可重复</td><td align="center">不可重复</td></tr><tr><td align="center">头文件</td><td align="center">#include&lt; map&gt;</td><td align="center">#include<unordered_map></td><td align="center">#include&lt; set&gt;</td><td align="center">#include<unordered_set></td></tr></tbody></table><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h4 id="内部实现机理"><a href="#内部实现机理" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>map内部实现了一个 红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树）， 红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p><h4 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a><strong>优缺点以及适用处</strong></h4><p>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作；红黑树，内部实现一个红黑树使得map的很多操作在O(logN)的时间复杂度下就可以实现，因此效率非常的高。</p><p>缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率（低于unorder_map），但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间（但占用的内存比unorder_map低）</p><p>适用处：对于那些数据存储有顺序要求的问题，用map会更高效一些</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>1.构造函数 2.插入数据 3.判断是否有元素 4.遍历 5.查找 </p><p>参考博客</p><p><a href="https://blog.csdn.net/weixin_45774972/article/details/113418453?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">C++ 中使用哈希表(unordered_map)的常用操作</a> </p><p><a href="https://lover.blog.csdn.net/article/details/82633778?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&utm_relevant_index=6">简述C++中map和unordered_map的用法</a> </p><p><a href="https://blog.csdn.net/qq_30815237/article/details/91047041">C++ map set unordered_map和unorder_set的区别</a></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; list = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">34</span>,<span class="hljs-number">22</span>,<span class="hljs-number">39</span>,<span class="hljs-number">5</span> &#125;;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = list.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>map[i] = list[i];  <span class="hljs-comment">//倒序插入</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = map.<span class="hljs-built_in">begin</span>(); i != map.<span class="hljs-built_in">end</span>(); i++) &#123;<br>cout &lt;&lt; i-&gt;first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;  <span class="hljs-comment">//输出的数是有序的且有两个5</span><br>&#125;<br><span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != map.<span class="hljs-built_in">end</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;find key=&quot;</span> &lt;&lt; map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>)-&gt;first &lt;&lt; <span class="hljs-string">&quot;, value=&quot;</span> &lt;&lt; map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>)-&gt;second &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">count</span>(<span class="hljs-number">5</span>) &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//m.count(n)计算下标为n的位置有无数据，有返回1，无返回0</span><br>cout &lt;&lt; <span class="hljs-string">&quot;count 5: &quot;</span> &lt;&lt; map.<span class="hljs-built_in">count</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;  <span class="hljs-comment">//find()和count()的输入参数都是key值</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>map是基于RBT的，因此元素是有序存储的（默认按键的升序排列）。</p></blockquote><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><h4 id="内部实现机理-1"><a href="#内部实现机理-1" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>unordered_map内部实现了一个 哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此， 其元素的排列顺序是无序的。</p><h4 id="优缺点以及适用处-1"><a href="#优缺点以及适用处-1" class="headerlink" title="优缺点以及适用处"></a><strong>优缺点以及适用处</strong></h4><p>优点： 因为内部实现了哈希表，因此其查找速度非常的快（运行效率快于map）</p><p>缺点： 哈希表的建立比较耗费时间（unorder_map占用的内存比map要高）</p><p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><p>1.构造函数 2.插入数据 3.判断是否有元素 4.遍历 5.查找 </p><p><a href="https://blog.csdn.net/weixin_45774972/article/details/113418453?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">C++ 中使用哈希表(unordered_map)的常用操作</a> </p><p><a href="https://lover.blog.csdn.net/article/details/82633778?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&utm_relevant_index=6">简述C++中map和unordered_map的用法</a> </p><p><a href="https://blog.csdn.net/qq_30815237/article/details/91047041">C++ map set unordered_map和unorder_set的区别</a></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; list = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">34</span>,<span class="hljs-number">22</span>,<span class="hljs-number">39</span>,<span class="hljs-number">5</span> &#125;;<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = list.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>map[i] = list[i];  <span class="hljs-comment">//倒序插入</span><br>&#125;<br>cout &lt;&lt; map[<span class="hljs-number">0</span>] &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator i = map.<span class="hljs-built_in">begin</span>(); i != map.<span class="hljs-built_in">end</span>(); i++) &#123;<br>cout &lt;&lt; i-&gt;first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;  <span class="hljs-comment">//输出的数是有序的且有两个5</span><br>&#125;<br><span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != map.<span class="hljs-built_in">end</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;find key=&quot;</span> &lt;&lt; map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>)-&gt;first &lt;&lt; <span class="hljs-string">&quot;, value=&quot;</span> &lt;&lt; map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>)-&gt;second &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">count</span>(<span class="hljs-number">5</span>) &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//m.count(n)计算下标为n的位置有无数据，有返回1，无返回0</span><br>cout &lt;&lt; <span class="hljs-string">&quot;find 5: &quot;</span> &lt;&lt; map.<span class="hljs-built_in">count</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;  <span class="hljs-comment">//find()和count()的输入都是key值</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>unordered_map 是基于hash表的，因此元素是无序存储的（不按键升序排列）。</p></blockquote><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h4 id="内部实现机理-2"><a href="#内部实现机理-2" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; list = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">34</span>,<span class="hljs-number">22</span>,<span class="hljs-number">39</span>,<span class="hljs-number">5</span> &#125;;<br>set&lt;<span class="hljs-type">int</span>&gt; set1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = list.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>set1.<span class="hljs-built_in">insert</span>(list[i]);  <span class="hljs-comment">//倒序插入</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = set1.<span class="hljs-built_in">begin</span>(); i != set1.<span class="hljs-built_in">end</span>(); i++) &#123;<br>cout &lt;&lt; *i &lt;&lt; endl;  <span class="hljs-comment">//输出的数是有序的且只有一个5</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;find 5: &quot;</span> &lt;&lt; *set1.<span class="hljs-built_in">find</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;<br>cout &lt;&lt;<span class="hljs-string">&quot;count 5: &quot;</span> &lt;&lt; set1.<span class="hljs-built_in">count</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><blockquote><p>set 是基于RBT的，因此元素是顺序存储的（默认按键值升序排列）。</p></blockquote><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><h4 id="内部实现机理-3"><a href="#内部实现机理-3" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>unordered_set的内部实现了一个 哈希表，因此， 其元素的排列顺序是无序的。</p><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; list = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">34</span>,<span class="hljs-number">22</span>,<span class="hljs-number">39</span>,<span class="hljs-number">5</span> &#125;;<br>unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = list.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>set.<span class="hljs-built_in">insert</span>(list[i]);  <span class="hljs-comment">//倒序插入</span><br>&#125;<br><span class="hljs-keyword">for</span> (unordered_set&lt;<span class="hljs-type">int</span>&gt;::iterator i = set.<span class="hljs-built_in">begin</span>(); i != set.<span class="hljs-built_in">end</span>(); i++) &#123;<br>cout &lt;&lt; *i &lt;&lt; endl;  <span class="hljs-comment">//输出的数是无序的且只有一个5</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;find 39: &quot;</span> &lt;&lt; *set.<span class="hljs-built_in">find</span>(<span class="hljs-number">39</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;count 14:&quot;</span> &lt;&lt; set.<span class="hljs-built_in">count</span>(<span class="hljs-number">14</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><blockquote><p>unordered_set 是基于hash表的，因此元素是无序存储的（不按键值升序排列）。</p></blockquote><h2 id="unordered-map与unordered-set的区别"><a href="#unordered-map与unordered-set的区别" class="headerlink" title="unordered_map与unordered_set的区别"></a>unordered_map与unordered_set的区别</h2><blockquote><p>后者就是在哈希表插入value，而这个value就是它自己的key，而不是像之前的unordered_map那样有键-值对，这里单纯就是为了方便查询这些值。</p><p>它们几乎相同. unordered_set只包含键,没有值.没有从键到值的映射,因此不需要operator[]. unordered_map将键映射到值.</p></blockquote><h2 id="unordered-map与map的区别"><a href="#unordered-map与map的区别" class="headerlink" title="unordered_map与map的区别"></a>unordered_map与map的区别</h2><blockquote><p>这两个的内部结构都是采用哈希表来实现。区别在哪里？unordered_map在C++11的时候被引入标准库了，而hash_map没有，所以建议还是使用unordered_map比较好。</p></blockquote><h2 id="hash-map与unordered-map的区别"><a href="#hash-map与unordered-map的区别" class="headerlink" title="hash_map与unordered_map的区别"></a>hash_map与unordered_map的区别</h2><blockquote><p>虽然都是map，但是内部结构大大的不同哎，map的内部结构是R-B-tree来实现的，所以保证了一个稳定的动态操作时间，查询、插入、删除都是O（logN），最坏和平均都是。而unordered_map如前所述，是哈希表。顺便提一下，哈希表的查询时间虽然是O（1），但是并不是unordered_map查询时间一定比map短，因为实际情况中还要考虑到数据量，而且unordered_map的hash函数的构造速度也没那么快，所以不能一概而论，应该具体情况具体分析。</p></blockquote><p>参考博客：</p><p><a href="https://blog.csdn.net/bryant_zhang/article/details/111600209">C++：map,unordered_map,set和unordered_set的用法和区别</a></p><p><a href="https://blog.csdn.net/u013195320/article/details/23046305?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&utm_relevant_index=1">C++中map、hash_map、unordered_map、unordered_set通俗辨析</a></p><p> </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和+哈希求和为K的子数组</title>
    <link href="/2022/04/08/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%93%88%E5%B8%8C%E6%B1%82%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/04/08/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%93%88%E5%B8%8C%E6%B1%82%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-560：和为-K-的子数组"><a href="#LeetCode-560：和为-K-的子数组" class="headerlink" title="LeetCode 560：和为 K 的子数组"></a>LeetCode 560：和为 K 的子数组</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>解决数组问题时，如果多层循环遍历超时，多考虑前缀和的思想来减少循环次数降低时间复杂度。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法1：枚举"><a href="#方法1：枚举" class="headerlink" title="方法1：枚举"></a>方法1：枚举</h4><p>两层循环遍历，超出时间限制</p><h4 id="方法2：前缀和-哈希表"><a href="#方法2：前缀和-哈希表" class="headerlink" title="方法2：前缀和+哈希表"></a>方法2：前缀和+哈希表</h4><blockquote><p>我们可以基于方法一利用数据结构进行进一步的优化，我们知道方法一的瓶颈在于对每个 i，我们需要枚举所有的 j 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。</p><p>我们定义 pre[i] 为 0..i 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：<br>pre[i]=pre[i−1]+nums[i]</p><p>那么 j..i 这个子数组和为 k 这个条件我们可以转化为<br>pre[i]−pre[j−1]==k</p><p>简单移项可得符合条件的下标 j 需要满足<br>pre[j−1]==pre[i]−k</p><p>所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1) 时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。</p><p>需要注意的是，从左往右边更新边计算的时候已经保证了mp[pre[i]−k] 里记录的 pre[j] 的下标范围是 0≤j≤i 。同时，由于 pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用 pre 变量来记录 pre[i−1] 的答案即可。</p></blockquote><p>AC代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        mp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)<br>        &#123;<br>            pre = pre+num;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(pre-k) != mp.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                cnt = cnt+mp[pre-k];<br>            &#125;<br>            mp[pre]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数据库系统概论」期末复习</title>
    <link href="/2022/04/07/%E3%80%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8D%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/04/07/%E3%80%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8D%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h1><p><a href="https://youpai.roccoshi.top/img/20210107010414.png"><img src="https://youpai.roccoshi.top/img/20210107010414.png" alt="img"></a></p><h1 id="2-关系数据库"><a href="#2-关系数据库" class="headerlink" title="2. 关系数据库"></a>2. 关系数据库</h1><h2 id="1-关系数据结构及形式化定义"><a href="#1-关系数据结构及形式化定义" class="headerlink" title="1 | 关系数据结构及形式化定义"></a>1 | 关系数据结构及形式化定义</h2><p>关系模型中数据的逻辑结构是一张扁平的二维表</p><p>关系是笛卡尔积的有限子集，所以关系也是一张二维表</p><p><strong>候选码</strong>：若关系中某一属性的值能唯一标识一个元组，而其子集不能，则称该属性组为候选码</p><p><strong>主码</strong>：若一个关系中有多个候选码，则选定其中一个为主码</p><p><strong>主属性</strong>：候选码的诸属性称为主属性</p><p><strong>非主属性</strong>：不包含在任何候选码中的属性称为非主属性或非码属性</p><p><strong>全码</strong>：关系模式的所有属性是这个关系模式的候选码，称为全码</p><h2 id="2-关系的完整性"><a href="#2-关系的完整性" class="headerlink" title="2 | 关系的完整性"></a>2 | 关系的完整性</h2><p>关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。</p><h2 id="3-关系代数"><a href="#3-关系代数" class="headerlink" title="3| 关系代数"></a>3| 关系代数</h2><h4 id="3-1-传统的集合运算"><a href="#3-1-传统的集合运算" class="headerlink" title="3-1 | 传统的集合运算"></a>3-1 | 传统的集合运算</h4><p>并、叉、交、笛卡尔积</p><h4 id="3-2-专门的关系运算"><a href="#3-2-专门的关系运算" class="headerlink" title="3-2 | 专门的关系运算"></a>3-2 | 专门的关系运算</h4><p>选择</p><p>投影：投影操作 是从列的角度进行运算</p><p>连接：两种常用的连接：等值连接和自然连接</p><p>除运算：除法是用象集来定义的</p><p>关系代数的五个基本操作：其余三种运算可以用这五种基本运算来表达</p><p><a href="https://youpai.roccoshi.top/img/20210107010534.png"><img src="https://youpai.roccoshi.top/img/20210107010534.png" alt="img"></a></p><p>关系代数中可能会用到的各个符号:</p><p><a href="https://youpai.roccoshi.top/img/20210107010616.png"><img src="https://youpai.roccoshi.top/img/20210107010616.png" alt="img"></a></p><h1 id="3-关系数据库标准语言SQL"><a href="#3-关系数据库标准语言SQL" class="headerlink" title="3. 关系数据库标准语言SQL"></a>3. 关系数据库标准语言SQL</h1><h2 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1 | SQL概述"></a>1 | SQL概述</h2><h3 id="1-1-SQL的特点"><a href="#1-1-SQL的特点" class="headerlink" title="1-1 | SQL的特点"></a>1-1 | SQL的特点</h3><p>1、综合统一 </p><p>2、高度非过程化</p><p>3、面向集合的操作方式</p><p>4、以同一种语法结构提供多种使用方式</p><p>5、语言简洁，易学易用</p><h3 id="1-2-SQL与三级模式体系结构图"><a href="#1-2-SQL与三级模式体系结构图" class="headerlink" title="1-2 | SQL与三级模式体系结构图"></a>1-2 | SQL与<strong>三级模式</strong>体系结构图</h3><p><a href="https://youpai.roccoshi.top/img/20210106174625.png"><img src="https://youpai.roccoshi.top/img/20210106174625.png" alt="image-20201226123540167"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174625.png">image-20201226123540167</a></p><p>模式：模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征描述，是所有用户的公共数据视图</p><p>外模式：外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</p><p>内模式：内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式</p><h2 id="2-数据定义"><a href="#2-数据定义" class="headerlink" title="2 | 数据定义"></a>2 | 数据定义</h2><p>SQL数据的定义功能：定义各种数据库的对象</p><p>SQL数据库定义功能包括模式定义、表定义、视图定义和索引定义</p><p><a href="https://youpai.roccoshi.top/img/20210106174626.png"><img src="https://youpai.roccoshi.top/img/20210106174626.png" alt="image-20201226123755751"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174626.png">image-20201226123755751</a></p><p>数据库对象命名机制的层次结构：</p><p>一个关系数据库管理系统中可以建立多个数据库，一个数据库可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</p><h3 id="2-1-模式的定义与删除"><a href="#2-1-模式的定义与删除" class="headerlink" title="2-1 | 模式的定义与删除"></a>2-1 | 模式的定义与删除</h3><h3 id="2-2-基本表的定义、删除与修改"><a href="#2-2-基本表的定义、删除与修改" class="headerlink" title="2-2 | 基本表的定义、删除与修改"></a>2-2 | 基本表的定义、删除与修改</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE <span class="hljs-operator">&lt;</span>name<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h4><p>格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>(<br>    <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>,<br>    <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>,<br>   ...<br>    <span class="hljs-operator">&lt;</span>表级完整性约束条件<span class="hljs-operator">&gt;</span><br>);<br></code></pre></td></tr></table></figure><p>列级完整性约束条件</p><p>表级完整性约束条件</p><p>实例：建立一个 “课程” 表Course</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Course<br>(Cno <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">PRIMARY</span> KEY,  <span class="hljs-comment">/*列级完整性约束条件，Cno是主码*/</span><br>     Cname <span class="hljs-type">CHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  <span class="hljs-comment">/*列级完整性约束条件，Cname不能取空值*/</span><br>     Cpno <span class="hljs-type">CHAR</span>(<span class="hljs-number">40</span>),  <span class="hljs-comment">/*Cpno的含义是先修课*/</span><br>     Ccredit <span class="hljs-type">SMALLINT</span>,<br>     <span class="hljs-keyword">FOREIGN</span> KEY(Cpno) <span class="hljs-keyword">REFERENCES</span> Course(Cno)<br>     <span class="hljs-comment">/*表级完整性约束条件，Cpno是外码，被参照表是Course，被参照对的列是Cno*/</span><br>    );<br></code></pre></td></tr></table></figure><p>常用的完整性约束:</p><p><a href="https://youpai.roccoshi.top/img/20210106174627.png"><img src="https://youpai.roccoshi.top/img/20210106174627.png" alt="image-20201226125004438"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174627.png">image-20201226125004438</a></p><h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><p>格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">ADD</span>[<span class="hljs-keyword">COLUMN</span>]<span class="hljs-operator">&lt;</span>新列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>[完整性约束]]<br>[<span class="hljs-keyword">ADD</span><span class="hljs-operator">&lt;</span>表级完整性约束<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">DROP</span>[<span class="hljs-keyword">COLUMN</span>]<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[CASCADE<span class="hljs-operator">|</span>RESTRICT]]<br>[<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span><span class="hljs-operator">&lt;</span>完整性约束名<span class="hljs-operator">&gt;</span> [RESTRICT<span class="hljs-operator">|</span>CASCADE]]<br>[<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span><span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>]<br></code></pre></td></tr></table></figure><h4 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> [RESTRICT<span class="hljs-operator">|</span>CASCADE]<br></code></pre></td></tr></table></figure><blockquote><p>RESTRICT：若选择RESTRICT，则该表的删除是有限制条件的</p><p>CASCADE：若选择CASCADE，则该表的删除是没有限制条件的</p></blockquote><h2 id="3-数据查询（重点）"><a href="#3-数据查询（重点）" class="headerlink" title="3 | 数据查询（重点）"></a>3 | 数据查询（重点）</h2><p>语法:</p><p><a href="https://youpai.roccoshi.top/img/20210106174628.png"><img src="https://youpai.roccoshi.top/img/20210106174628.png" alt="image-20201226130756283"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174628.png">image-20201226130756283</a></p><h3 id="3-1-单表查询"><a href="#3-1-单表查询" class="headerlink" title="3-1 | 单表查询"></a>3-1 | 单表查询</h3><h4 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h4><p><a href="https://youpai.roccoshi.top/img/20210106174629.png"><img src="https://youpai.roccoshi.top/img/20210106174629.png" alt="image-20201226130825216"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174629.png">image-20201226130825216</a></p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">23</span>;    <span class="hljs-comment">/*找年龄20-23岁的*/</span><br><span class="hljs-keyword">where</span> dept <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;ma&#x27;</span>, <span class="hljs-string">&#x27;cs&#x27;</span>);    <span class="hljs-comment">/*查询不是is, ma, cs系得*/</span><br><span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;刘%&#x27;</span>;    <span class="hljs-comment">/*找姓刘的*/</span><br><span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;__阳&#x27;</span>;    <span class="hljs-comment">/*找名字叫xx阳的*/</span><br><span class="hljs-keyword">where</span> cname <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;DB\_Design&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;\&#x27;</span>;<br><span class="hljs-comment">/*escape定义转义字符, 出现在其后的第一个字符不是通配符而是字符本身*/</span><br></code></pre></td></tr></table></figure><h4 id="ORDER-BY字句"><a href="#ORDER-BY字句" class="headerlink" title="ORDER BY字句"></a>ORDER BY字句</h4><p>用户可以用ORDER BY字句对查询结果按照一个或多个属性的升序（ASC）或降序（DESC）排列，默认值为升序。</p><p>对属性列排序：</p><ul><li>asc为升序</li><li>desc为降序</li><li>默认为升序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Sdept,Sage <span class="hljs-keyword">DESC</span>;  <span class="hljs-comment">/*Sdept默认升序*/</span><br></code></pre></td></tr></table></figure><h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-built_in">COUNT</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)<br><span class="hljs-built_in">SUM</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)<br><span class="hljs-built_in">AVG</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)<br><span class="hljs-built_in">MAX</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)<br><span class="hljs-built_in">MIN</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>如果指定DISTINCT短语，则表示在计算时要取消指定列中的重复行。如果不指定DISTINCT短语或者ALL短语（ALL为默认值），则表示不取消重复行。</p></blockquote><h4 id="GROUP-BY短语"><a href="#GROUP-BY短语" class="headerlink" title="GROUP BY短语"></a>GROUP BY短语</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>GROUP BY子句将查询结果按某一列或多列的值分组，值相等的为一组。</p><p>分散后聚集函数将作用于每一个组，即每一组都有一个函数值。</p><p>Note:</p><p>按指定的一列或者多列分组, 值相等的为一组, HAVING子句作用于各个组之上</p><ul><li>如果未对查询结果分组, 集函数作用于整个查询结果</li><li>对查询结果分组后, 集函数分别作用于各个组</li><li>使用GROUP BY子句后, SELECT子句的列名表中只能出现分组属性和集函数, 不能出现在group by中没有出现的属性</li></ul><p>例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*查询各个课程号和相应的选课人数*/</span><br><span class="hljs-keyword">select</span> cno, <span class="hljs-built_in">count</span>(sno)<br><span class="hljs-keyword">from</span> sc<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> cno;<br><br><span class="hljs-comment">/*查询有3门以上课程是90分以上的学生学号及其(90分以上的)课程数。*/</span><br><span class="hljs-keyword">select</span> sno, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> sc<br><span class="hljs-keyword">where</span> grade <span class="hljs-operator">&gt;=</span> <span class="hljs-number">90</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sno<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="3-2-连接查询"><a href="#3-2-连接查询" class="headerlink" title="3-2 | 连接查询"></a>3-2 | 连接查询</h3><h3 id="3-3-嵌套查询"><a href="#3-3-嵌套查询" class="headerlink" title="3-3 | 嵌套查询"></a>3-3 | 嵌套查询</h3><p>分类:</p><ul><li><p><strong>相关子查询</strong> : 子查询执行依赖于父查询条件</p></li><li><p><strong>不相关子查询</strong> : 子查询执行不依赖于父查询条件</p></li></ul><h4 id="带有IN谓词的子查询"><a href="#带有IN谓词的子查询" class="headerlink" title="带有IN谓词的子查询"></a>带有IN谓词的子查询</h4><h4 id="带有比较运算的子查询"><a href="#带有比较运算的子查询" class="headerlink" title="带有比较运算的子查询"></a>带有比较运算的子查询</h4><p>带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是单个值时，可以用&gt;、&lt;、=、&gt;=、&lt;=、!=或&lt;&gt;等比较运算符。</p><h4 id="带有ANY（SOME）或ALL谓词的子查询"><a href="#带有ANY（SOME）或ALL谓词的子查询" class="headerlink" title="带有ANY（SOME）或ALL谓词的子查询"></a>带有ANY（SOME）或ALL谓词的子查询</h4><p>子查询返回单值时可以用比较运算符，但返回多值时要用ANY或ALL谓词修饰。而使用ANY或ALL谓词时必须同时使用比较运算符。</p><p><a href="https://youpai.roccoshi.top/img/20210106174630.png"><img src="https://youpai.roccoshi.top/img/20210106174630.png" alt="img"></a></p><p>例子: (为不相关子查询)</p><p><a href="https://youpai.roccoshi.top/img/20210106174631.png"><img src="https://youpai.roccoshi.top/img/20210106174631.png" alt="image-20201226133604299"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174631.png">image-20201226133604299</a></p><p>使用any/all谓词与集函数具有等价关系, 而用集函数查询通常比any/all查询效率高因为前者可以减少比较次数</p><p><a href="https://youpai.roccoshi.top/img/20210106174632.png"><img src="https://youpai.roccoshi.top/img/20210106174632.png" alt="image-20201226133751280"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174632.png">image-20201226133751280</a></p><h4 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h4><p>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false， 故子查询通常只用select *</p><p><a href="https://youpai.roccoshi.top/img/20210106174633.png"><img src="https://youpai.roccoshi.top/img/20210106174633.png" alt="image-20201226133932439"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174633.png">image-20201226133932439</a></p><p>使用<strong>EXISTS子查询的效率要优于使用连接查询和IN查询</strong></p><p>EXISTS通常引入的是相关子查询, 而IN更多的是不相关子查询</p><h3 id="3-4-集合查询"><a href="#3-4-集合查询" class="headerlink" title="3-4 | 集合查询"></a>3-4 | 集合查询</h3><p>集合操作命令</p><table><thead><tr><th>命令</th><th></th></tr></thead><tbody><tr><td>UNION</td><td>并</td></tr><tr><td>INTERSECT</td><td>交</td></tr><tr><td>MINUS</td><td>差</td></tr></tbody></table><p><a href="https://youpai.roccoshi.top/img/20210106174634.png"><img src="https://youpai.roccoshi.top/img/20210106174634.png" alt="image-20201226140459748"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174634.png">image-20201226140459748</a></p><h2 id="4-数据更新"><a href="#4-数据更新" class="headerlink" title="4 | 数据更新"></a>4 | 数据更新</h2><h3 id="4-1-插入数据"><a href="#4-1-插入数据" class="headerlink" title="4-1 | 插入数据"></a>4-1 | 插入数据</h3><h4 id="插入单个结果"><a href="#插入单个结果" class="headerlink" title="插入单个结果"></a>插入单个结果</h4><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...)]<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-operator">&lt;</span>常量<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>常量<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...)<br></code></pre></td></tr></table></figure><p>如果不指定属性列, 则values必须以完整的元组插入, 且属性与表中属性顺序一致</p><p>举例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> sc(sno, cno)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;95001&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="插入子查询结果"><a href="#插入子查询结果" class="headerlink" title="插入子查询结果"></a>插入子查询结果</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> [(<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...)]<br>子查询;<br></code></pre></td></tr></table></figure><p>举例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> Deptage(Sdept, Avgage)<br><span class="hljs-keyword">SELECT</span> Sdept,<span class="hljs-built_in">AVG</span>(Sage)  <span class="hljs-comment">-- 属性个数要匹配</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sdept;<br></code></pre></td></tr></table></figure><h4 id="注意完整性约束"><a href="#注意完整性约束" class="headerlink" title="注意完整性约束"></a>注意完整性约束</h4><p><a href="https://youpai.roccoshi.top/img/20210106174635.png"><img src="https://youpai.roccoshi.top/img/20210106174635.png" alt="image-20201226143151436"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174635.png">image-20201226143151436</a></p><h3 id="4-2-修改数据"><a href="#4-2-修改数据" class="headerlink" title="4-2 | 修改数据"></a>4-2 | 修改数据</h3><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">SET</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span>表达式<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span>表达式<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span>]<br></code></pre></td></tr></table></figure><p>举例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> student<br><span class="hljs-keyword">set</span> sage <span class="hljs-operator">=</span> <span class="hljs-number">22</span><br><span class="hljs-keyword">where</span> sno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95001&#x27;</span><br><span class="hljs-keyword">Copy</span><br><span class="hljs-comment">-- 将所有学生年龄增加一岁</span><br><span class="hljs-keyword">update</span> student<br><span class="hljs-keyword">set</span> sage <span class="hljs-operator">=</span> sage <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="4-3-删除数据"><a href="#4-3-删除数据" class="headerlink" title="4-3 | 删除数据"></a>4-3 | 删除数据</h3><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><p>删除表中满足where指定条件的元组</p><p>例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span><br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> sno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95001&#x27;</span>;<br><span class="hljs-keyword">Copy</span><br><span class="hljs-comment">-- 删除所有学生的选课记录</span><br><span class="hljs-keyword">delete</span><br><span class="hljs-keyword">from</span> sc;<br><span class="hljs-keyword">Copy</span><br><span class="hljs-comment">-- 删除CS系所有学生的选课记录</span><br><span class="hljs-keyword">delete</span> <br><span class="hljs-keyword">from</span> sc<br><span class="hljs-keyword">where</span> sno <span class="hljs-keyword">in</span> (<br><span class="hljs-keyword">select</span> sno<br>    <span class="hljs-keyword">from</span> student<br>    <span class="hljs-keyword">where</span> student.sdept <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CS&#x27;</span><br>);<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>删除时的参照完整性:</p><ul><li>不允许被删除</li><li>级联删除 ( 通过CASCADE参数指定 )</li></ul><h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5 | 视图"></a>5 | 视图</h2><p>视图的特点：</p><p>1、虚表，是从一个或几个基本表（或视图）导出的表</p><p>2、只存放视图的定义，不存放视图对应的数据</p><p>3、基本表中的数据发生变化，从视图中查询出的数据也随之改变</p><p>数据库系统的<strong>三级模式</strong>: 外模式, 模式, 内模式</p><p>数据库系统的<strong>两级映像</strong>: 外模式-模式映像 模式-内模式映像</p><ul><li>外模式-模式映像用途: <strong>保证数据的逻辑独立性</strong></li><li>模式-内模式映像用途: <strong>保证数据的物理独立性</strong></li></ul><p>视图对应的就是三级模式/两级映像体系结构中的外模式和外模式/模式映像</p><h3 id="5-1-定义视图"><a href="#5-1-定义视图" class="headerlink" title="5-1 | 定义视图"></a>5-1 | 定义视图</h3><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>]...)]<br><span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>子查询<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure><p><a href="https://youpai.roccoshi.top/img/20210106174636.png"><img src="https://youpai.roccoshi.top/img/20210106174636.png" alt="image-20210102151117045"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174636.png">image-20210102151117045</a></p><p>DBMS执行create view语句时只是把视图的定义存入数据字典, 并不执行其中的select语句, 在对视图查询时, 按视图的定义从基本表中将数据查出</p><p>例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> IS_STUDENT<br><span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> sno, sname, sage<br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> sdept <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;IS&#x27;</span>;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>若一个视图是从单个基本表导出的, 并且只去掉了基本表的某些行和某些列但保留了码, 则这类视图称为<strong>行列子集视图</strong>, 上例所建立的视图就是行列子集视图</p><h3 id="5-2-查询视图"><a href="#5-2-查询视图" class="headerlink" title="5-2 | 查询视图"></a>5-2 | 查询视图</h3><p>视图消解：从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转化过程称为视图消解。</p><h3 id="5-3-更新视图"><a href="#5-3-更新视图" class="headerlink" title="5-3 | 更新视图"></a>5-3 | 更新视图</h3><h3 id="5-4-视图的作用"><a href="#5-4-视图的作用" class="headerlink" title="5-4 | 视图的作用"></a>5-4 | 视图的作用</h3><p>1、视图能够简化用户的操作</p><p>2、视图使用户能以多种角度看待同一数据</p><p>3、视图对重构数据库提供了一定程度的逻辑独立性</p><p>4、视图能够对机密数据提供安全防护</p><p>5、适当利用视图可以更清晰地表达查询</p><h1 id="4-数据库安全-赋权"><a href="#4-数据库安全-赋权" class="headerlink" title="4. 数据库安全-赋权"></a>4. 数据库安全-赋权</h1><blockquote><p>数据库的安全性控制通过授权机制来实现, 即通过赋予用户对数据库的使用权限来保证数据的安全</p></blockquote><h2 id="1-授权GRANT语句"><a href="#1-授权GRANT语句" class="headerlink" title="1 | 授权GRANT语句"></a>1 | 授权<code>GRANT</code>语句</h2><ul><li>将数据库中的某些对象的某些操作权限赋予某些用户</li></ul><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Grant</span> <span class="hljs-operator">&lt;</span>权限s<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ON</span><span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">TO</span><span class="hljs-operator">&lt;</span>用户s<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><ul><li>DBA拥有数据库操作的所有权限并可将权限赋予其他用户</li><li>建立数据库对象的用户称为OWNER, 他拥有对该对象的所有操作权限</li><li>接收权限的用户可以是一个或者多个具体用户, 也可以是全体用户PUBLIC</li><li><code>WITH GRANT OPTION</code>子句: 获得某种权限的用户还可以把这种权限再授予别的用户, 没有指定with grant option时, 获得某种权限的用户只能使用该权限, 不能传播该权限</li></ul><h3 id="所有权限一览表"><a href="#所有权限一览表" class="headerlink" title="所有权限一览表"></a>所有权限一览表</h3><p><a href="https://youpai.roccoshi.top/img/20201227101704.png"><img src="https://youpai.roccoshi.top/img/20201227101704.png" alt="image-20201227101703896"></a></p><p><a href="https://youpai.roccoshi.top/img/20201227101704.png">image-20201227101703896</a></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span><br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student<br><span class="hljs-keyword">to</span> user1;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>把对sc表的全部权限授予全部用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> priviliges<br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc<br><span class="hljs-keyword">to</span> public;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>把查询student表和修改学生学号的权限授予给用户3和用户4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">update</span>(sno), <span class="hljs-keyword">select</span><br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student<br><span class="hljs-keyword">to</span> user3, user4;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>把对表sc的insert权限授予给user5用户, 并允许他再将此权限授予其他用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">insert</span><br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc<br><span class="hljs-keyword">to</span> user5<br><span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> option;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>把在数据库S_C中的建表权限授予用户8</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> createtab<br><span class="hljs-keyword">on</span> database S_C<br><span class="hljs-keyword">to</span> user8;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h2 id="2-收回权限REVOKE语句"><a href="#2-收回权限REVOKE语句" class="headerlink" title="2 | 收回权限REVOKE语句"></a>2 | 收回权限<code>REVOKE</code>语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限s<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>用户s<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">update</span>(sno)<br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student<br><span class="hljs-keyword">from</span> user4;<br><span class="hljs-keyword">Copy</span><br><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">select</span><br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc<br><span class="hljs-keyword">from</span> public;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><ul><li>收回权限时, 将收回自己所级联授予出的权限</li><li>如果存在多重授予, (从不同用户处得到的相同权限, 则仍然具有该权限), 只收回自己级联授予的权限</li></ul><h2 id="3-视图机制"><a href="#3-视图机制" class="headerlink" title="3 | 视图机制"></a>3 | 视图机制</h2><p><a href="https://youpai.roccoshi.top/img/20201227102725.png"><img src="https://youpai.roccoshi.top/img/20201227102725.png" alt="image-20201227102725294"></a></p><p><a href="https://youpai.roccoshi.top/img/20201227102725.png">image-20201227102725294</a></p><h1 id="5-存储过程和触发器"><a href="#5-存储过程和触发器" class="headerlink" title="5. 存储过程和触发器"></a>5. 存储过程和触发器</h1><h2 id="1-存储过程"><a href="#1-存储过程" class="headerlink" title="1 | 存储过程"></a>1 | 存储过程</h2><p>创建存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span><br></code></pre></td></tr></table></figure><p>执行存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">PROCEDURE</span><br></code></pre></td></tr></table></figure><p>修改存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">PROCEDURE</span><br></code></pre></td></tr></table></figure><p>删除存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span><br></code></pre></td></tr></table></figure><h2 id="2-触发器"><a href="#2-触发器" class="headerlink" title="2 | 触发器"></a>2 | 触发器</h2><p>功能: 强化约束, 跟踪变化, 级联运行, 存储过程的调用</p><p>分类: 前触发器(<code>INSTEAD OF</code>), 后触发器 (<code>AFTER</code>)</p><p>创建:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <br><span class="hljs-keyword">ON</span><br><span class="hljs-keyword">FOR</span><br><span class="hljs-keyword">AS</span><br><br><span class="hljs-comment">-- 例子</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> reminder<br><span class="hljs-keyword">on</span> titles<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">insert</span>, <span class="hljs-keyword">update</span><br><span class="hljs-keyword">as</span> sql_statements<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>在触发器的执行过程中，系统会自动建立和管理两个逻辑表：插入表(inserted)和删除表(deleted)。这两个表与触发器所对应的基本表有着完全相同的结构，但为只读表，驻留于内存之中，直到触发器执行完毕，系统会自动删除。这两个表是事务回滚的重要依据。</p><h1 id="6-数据库设计"><a href="#6-数据库设计" class="headerlink" title="6. 数据库设计"></a>6. 数据库设计</h1><h2 id="1-数据库设计的流程"><a href="#1-数据库设计的流程" class="headerlink" title="1 | 数据库设计的流程"></a>1 | 数据库设计的流程</h2><table><thead><tr><th>1-需求分析</th><th>2-概念结构设计</th><th>3-逻辑结构设计</th><th>4-物理结构设计</th></tr></thead><tbody><tr><td></td><td>ER图</td><td>ER图-&gt;关系模型</td><td></td></tr></tbody></table><h2 id="2-ER图"><a href="#2-ER图" class="headerlink" title="2 | ER图"></a>2 | ER图</h2><p>三种表示</p><table><thead><tr><th></th><th>表示方式</th></tr></thead><tbody><tr><td>实体</td><td>矩形</td></tr><tr><td>属性</td><td>圆形</td></tr><tr><td>联系</td><td>菱形</td></tr></tbody></table><p>三种不同的联系</p><ul><li>一对一联系</li><li>一对多联系</li><li>多对多联系</li></ul><h2 id="3-ER图向关系模型的转换"><a href="#3-ER图向关系模型的转换" class="headerlink" title="3 | ER图向关系模型的转换"></a>3 | ER图向关系模型的转换</h2><table><thead><tr><th>联系</th><th>转换</th></tr></thead><tbody><tr><td>1 : 1</td><td>两实体<strong>任意一端添加另一端的主键</strong></td></tr><tr><td>1 : N</td><td>在<strong>N端添加另一端的主键</strong></td></tr><tr><td>N : M</td><td>将<strong>联系转化为实体</strong>, 并在实体中加入联系两端实体的主键</td></tr><tr><td>1 : 1 : N - N : M : P</td><td>同 1 : N - N : M (在N端添加另外两端主键 - 联系转化为实体添加三端实体主键)</td></tr></tbody></table><h1 id="7-关系数据理论"><a href="#7-关系数据理论" class="headerlink" title="7. 关系数据理论"></a>7. 关系数据理论</h1><p><strong>关系模式的简记</strong>: <code>R&lt;U, F&gt;</code></p><p>其中U表示属性集, F表示数据依赖</p><h2 id="1-关系数据理论"><a href="#1-关系数据理论" class="headerlink" title="1 | 关系数据理论"></a>1 | 关系数据理论</h2><p>不合适的数据依赖造成以下等问题</p><ul><li>数据冗余</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ul><h2 id="2-规范化"><a href="#2-规范化" class="headerlink" title="2 | 规范化"></a>2 | 规范化</h2><h3 id="2-1-函数依赖"><a href="#2-1-函数依赖" class="headerlink" title="2-1 | 函数依赖"></a>2-1 | 函数依赖</h3><p>函数依赖（Functional Dependencies）简写为FD</p><ul><li><p><strong>平凡函数依赖</strong>： (X→Y,Y⊆X) 平凡函数依赖没什么用, 不研究</p><p>例如(sno, cno)→sno</p></li><li><p><strong>非平凡函数依赖</strong>：(X→Y,Y⊈X) 如果不特别声明, 我们总是讨论非平凡函数依赖</p><p>例如(sno, cno)→grade</p><blockquote><p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反应新的语义，因此若不特别声明，我们总是讨论非平凡函数依赖。</p></blockquote></li><li><p><strong>完全函数依赖</strong>：在R(U)中，如果X→Y，并且对于X的任何一个真子集X‘，都有X‘/→Y</p></li><li><p><strong>部分函数依赖</strong>：若X→Y，但Y不完全函数依赖于X</p></li><li><p><strong>传递函数依赖</strong>：在R(U)中，X→Y，Y→Z，且Y/→X，则Z传递依赖于X, 如果Y→X则为直接函数依赖</p></li></ul><h3 id="2-2-码"><a href="#2-2-码" class="headerlink" title="2-2 | 码"></a>2-2 | 码</h3><blockquote><p>码是关系模式中的一个重要概念。在第二章关系数据库中已经给出了有关码的若干定义，这里用函数依赖的概念来定义码。</p></blockquote><p><strong>候选码</strong>：设K为R&lt;U,F&gt;中的属性或属性组合，若U完全函数依赖于K，则K为R的候选码。</p><p><strong>超码</strong>：如果U部分函数依赖于K，则K为超码</p><blockquote><p>候选码是最小的超码，即K的任何一个真子集都不是候选码</p><p>候选码是 一类特殊的超码，即候选码的超集一定是超码，候选码的任何真子集一定不是超码</p></blockquote><p><strong>主码</strong>：若关系模式R有多个候选码，则选定其中一个作为主码</p><p><strong>主属性</strong>：包含在任何一个候选码中的属性称为主属性</p><p><strong>非主属性</strong>：不包含在任何一个候选码中的属性称为非主属性或非码属性</p><p><strong>全码</strong>：整个属性组是码，称为全码</p><blockquote><p>例：关系模式R(P,W,A)中，属性P表示演奏者，W表示作品，A表示听众。假设一个演奏者可以演奏多个作品，某一个作品可以被多个演奏者演奏，听众也可以欣赏不同演奏者的不同作品，这个关系模式的码为(P,W,A)，即all-key。</p></blockquote><p><strong>外码</strong>：关系模式R&lt;U,F&gt;，U中属性或者属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码也称外码。</p><blockquote><p>主码与外码一起提供了表示关系间联系的手段</p></blockquote><h3 id="2-3-范式"><a href="#2-3-范式" class="headerlink" title="2-3 | 范式"></a>2-3 | 范式</h3><ul><li>范式：范式 是符合某一级别的关系模式的集合</li><li>关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。</li><li><strong>规范化</strong>：一个低一级范式的关系模式通过模式分解可以转换成为若干个高一级范式的关系模式的集合，这个过程就叫规范化。</li></ul><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p><strong>定义</strong>：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。</p><p>所有属性必须是原子的, 不允许表中套表</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p><strong>定义</strong>：若 R∈1NF，且每一个非主属性完全依赖于任何一个候选码，则R∈2NF。</p><p>满足1NF且不存在非主属性对候选码的部分函数依赖</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>满足2NF且不存在非主属性对候选码的传递函数依赖和部分函数依赖</p><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>修正的第三范式</p><p>没有任何属性对码的部分函数依赖和传递函数依赖</p><p>在关系模式R&lt;U,F&gt;中每一个决定因素都包含码，则R&lt;U,F&gt;∈BCNF</p><h2 id="3-数据库依赖的公理系统"><a href="#3-数据库依赖的公理系统" class="headerlink" title="3 | 数据库依赖的公理系统"></a>3 | 数据库依赖的公理系统</h2><h3 id="六条推理规则"><a href="#六条推理规则" class="headerlink" title="六条推理规则"></a>六条推理规则</h3><ul><li>自反律</li><li>增广律</li><li>传递律</li><li>合并规则</li><li>分解规则</li><li>伪传递规则</li></ul><p><a href="https://youpai.roccoshi.top/img/20210102192831.png"><img src="https://youpai.roccoshi.top/img/20210102192831.png" alt="img"></a></p><h3 id="函数依赖集的闭包"><a href="#函数依赖集的闭包" class="headerlink" title="函数依赖集的闭包"></a>函数依赖集的闭包</h3><p>在关系模式R中为F所逻辑蕴含的函数依赖的全体叫做F的闭包, 记为F+</p><p>注: F+一般超级多, 求F+属于NP完全问题</p><h3 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h3><p>设F为属性集U上的一组函数依赖, X⊆U, X关于函数依赖集F的闭包为XF+</p><p>能由根据公理导出XF+={A|X→A能由F根据Armstrong公理导出}</p><p>注: 即求X可以导出的所有属性集合</p><p><a href="https://youpai.roccoshi.top/img/20210102192832.png"><img src="https://youpai.roccoshi.top/img/20210102192832.png" alt="img"></a></p><h3 id="最小函数依赖集"><a href="#最小函数依赖集" class="headerlink" title="最小函数依赖集"></a>最小函数依赖集</h3><p>即用最少的函数依赖表示全部属性之间的依赖关系, 记为Fmin</p><p>最小函数依赖集的定义:</p><p><a href="https://youpai.roccoshi.top/img/20210102192833.png"><img src="https://youpai.roccoshi.top/img/20210102192833.png" alt="img"></a></p><h3 id="考点-最小函数依赖集的求解算法"><a href="#考点-最小函数依赖集的求解算法" class="headerlink" title="考点: 最小函数依赖集的求解算法"></a>考点: 最小函数依赖集的求解算法</h3><p>第一步: <strong>对每个函数依赖作右部属性分离</strong></p><p>第二步: <strong>去掉左部的冗余属性</strong></p><p>第三步: <strong>去除多余的函数依赖</strong></p><p>注意: 最小函数依赖集不是唯一的</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><a href="https://youpai.roccoshi.top/img/20210102192834.png"><img src="https://youpai.roccoshi.top/img/20210102192834.png" alt="img"></a></p><p>在第三步的时候可以采用「除本求包」的方法, 即除去正在考察的这个函数依赖, 看左部属性的闭包是否包含正在考察的函数依赖的右部属性, 如果包含则正在考察的这个函数依赖为多余的函数依赖, 例如上面的A-&gt;D, 除去A-&gt;D的这个函数依赖求A的闭包为{A, B, C, D, E}包含D, 则A-&gt;D为多余, 应该去除。</p><p><strong>正则覆盖</strong>: 将求出的最小函数依赖集左部属性相同的函数依赖合并(例如A-&gt;B A-&gt;C合并为A-&gt;BC)</p><h3 id="考点-候选码求解算法"><a href="#考点-候选码求解算法" class="headerlink" title="考点: 候选码求解算法"></a>考点: 候选码求解算法</h3><p>第一步: <strong>根据函数依赖集F将R的所有属性分为L类, R类, LR类和N类属性[<a href="https://blog.roccoshi.top/2021/%E8%A5%BF%E7%94%B5%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E5%A4%8D%E4%B9%A0/#fn:1">1]</a>, 令X为L, N类的集合, Y为LR类的集合</strong></p><p>第二步: <strong>如果XF+=U, 则X为R的唯一候选码, 结束, 否则到第三步</strong></p><p>第三步: <strong>逐一取Y中的单一属性A, 若(XA)F+=U, 则XA为候选码, 令Y = Y - {A}, 到第四步</strong></p><p>第四步: <strong>依次取Y中的两个, 三个…属性与X组成属性组XZ, 若XZ不包含已求得的候选码, 则求其关于F的闭包(XZ)F+</strong></p><p><strong>若(XZ)F+=U, 则XZ为候选码, 重复第四步直到所有Y中的属性取完为止, 算法结束</strong></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><a href="https://youpai.roccoshi.top/img/20210102192835.png"><img src="https://youpai.roccoshi.top/img/20210102192835.png" alt="img"></a></p><h2 id="4-模式分解"><a href="#4-模式分解" class="headerlink" title="4 | 模式分解"></a>4 | 模式分解</h2><p><a href="https://youpai.roccoshi.top/img/20210102192836.png"><img src="https://youpai.roccoshi.top/img/20210102192836.png" alt="img"></a></p><p>分解应该考虑的问题</p><ul><li>分解不能丢失信息</li><li>分解应该保持函数依赖</li><li>分解需要保持无损连接 (可以通过自然连接还原)</li></ul><h3 id="考点-模式的无损连接性判定算法"><a href="#考点-模式的无损连接性判定算法" class="headerlink" title="考点: 模式的无损连接性判定算法"></a>考点: 模式的无损连接性判定算法</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>R的一个分解为R1, R2</p><p><strong>若U1∩U2→U1−U2∈F+或者U1∩U2→U2−U1∈F+则分解R1, R2保持无损连接</strong> (<strong>充分必要条件</strong>, 用于一分为二模式的无损连接判断)</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>构造表</p><p><a href="https://youpai.roccoshi.top/img/20210102192837.png"><img src="https://youpai.roccoshi.top/img/20210102192837.png" alt="img"></a></p><h3 id="将模式分解为BCNF并保持无损连接"><a href="#将模式分解为BCNF并保持无损连接" class="headerlink" title="将模式分解为BCNF并保持无损连接"></a>将模式分解为BCNF并保持无损连接</h3><p><a href="https://youpai.roccoshi.top/img/20210102192838.png"><img src="https://youpai.roccoshi.top/img/20210102192838.png" alt="img"></a></p><h1 id="8-嵌入式SQL"><a href="#8-嵌入式SQL" class="headerlink" title="8. 嵌入式SQL"></a>8. 嵌入式SQL</h1><h2 id="1-主语言-SQLCA-主变量-游标"><a href="#1-主语言-SQLCA-主变量-游标" class="headerlink" title="1 | 主语言 SQLCA 主变量 游标"></a>1 | 主语言 SQLCA 主变量 游标</h2><p>主语言: C++, JAVA</p><p>SQLCA: sql communication area (SQL通信区)</p><p>主变量: sql使用主语言中的变量</p><p>游标: 一段缓冲区, 用于存放sql的执行结果</p><h3 id="数据库和源程序工作单元间的通信"><a href="#数据库和源程序工作单元间的通信" class="headerlink" title="数据库和源程序工作单元间的通信"></a>数据库和源程序工作单元间的通信</h3><ol><li>SQLCA向主语言传递SQL语句的执行信息(执行状态)</li><li>主语言通过主变量向SQL提供参数</li><li>主变量和游标将SQL语句查询数据库的结果交主语言处理</li></ol><h1 id="9-事务"><a href="#9-事务" class="headerlink" title="9. 事务"></a>9. 事务</h1><h2 id="1-事务的ACID特性"><a href="#1-事务的ACID特性" class="headerlink" title="1 | 事务的ACID特性"></a>1 | 事务的ACID特性</h2><ul><li>原子性Atomicity: 事务要么全做, 要么全不做</li><li>一致性Consistency: 事务让数据库从一个一致性状态—&gt;另一个一致性状态</li><li>隔离性Isolation: 事务的执行不能被其他事务干扰</li><li>持续性Durability: 事务提交后对数据库中数据的改变为永久性的</li></ul><h2 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2 | 并发控制"></a>2 | 并发控制</h2><p>几种并发冲突:</p><ol><li><strong>丢失修改</strong> (写-写冲突)</li><li><strong>不可重复读</strong> (读-写冲突)</li><li><strong>读“脏”数据</strong> (写-读冲突)</li></ol><h2 id="3-封锁机制"><a href="#3-封锁机制" class="headerlink" title="3 | 封锁机制"></a>3 | 封锁机制</h2><p><strong>X锁</strong>: 排他锁, 持有X锁的人能读写数据库</p><p><strong>S锁:</strong> 共享锁, 持有S锁的人能读不能写数据库</p><p>仅能有一个事务拥有X锁, 可以有多个事务同时拥有S锁</p><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p>修改数据之前先加X锁, 事务结束后释放</p><p>解决问题: <strong>丢失修改</strong></p><h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><p>在一级封锁协议基础上增加在读取数据前必须对数据加S锁, 读完后即可释放</p><p>解决问题: <strong>丢失修改和读“脏”数据</strong></p><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p>在一级封锁协议的基础上增加在读取数据前必须对数据加S锁, 在事务结束后才可释放</p><p>解决问题: <strong>丢失修改, 不可重复读, 读“脏”数据</strong></p><h2 id="4-并发调度的可串行性"><a href="#4-并发调度的可串行性" class="headerlink" title="4 | 并发调度的可串行性"></a>4 | 并发调度的可串行性</h2><p><strong>可串行化调度的定义:</strong></p><blockquote><p>定义: 多个并发事务的执行是正确的, 当且仅当其结果与按一定次序串行地执行这些事务时的结果相同</p></blockquote><p><strong>可串行性</strong>是并发事务正确调度的准则, 一个给定的并发调度当且仅当它是可串行化的才认为是正确的调度</p><p><strong>冲突可串行化调度:</strong></p><p>将并发调度保证冲突操作次序不变的情况下交换不冲突操作的次序得到另一个串行调度, 则称这个并发调度为冲突可串行化的调度, 如果一个调度是冲突可串行化的, 那么则一定是可串行化的调度。</p><p>注意: 冲突可串行化调度是可串行化调度的充分非必要条件</p><h2 id="5-两段锁协议"><a href="#5-两段锁协议" class="headerlink" title="5 | 两段锁协议"></a>5 | 两段锁协议</h2><p>两段锁协议:</p><blockquote><p>先统一加锁, 事务结束时统一释放锁</p></blockquote><ul><li>遵守两段锁协议也会发生死锁</li><li>遵守两段锁协议是可串行化调度的充分条件</li></ul><p>原博客转载于：<a href="https://blog.roccoshi.top/">https://blog.roccoshi.top/</a> + 本人增删修改</p>]]></content>
    
    
    <categories>
      
      <category>解忧杂货</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维矩阵的二分查找</title>
    <link href="/2022/04/06/%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/04/06/%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="LeeetCode-240：搜索二维矩阵"><a href="#LeeetCode-240：搜索二维矩阵" class="headerlink" title="LeeetCode 240：搜索二维矩阵"></a>LeeetCode 240：搜索二维矩阵</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>C++ lower_bound()函数</p><blockquote><p>lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。它的底层实现采用的都是二分查找的方式。</p><p>注意：</p><p>1.因为函数底层实现采用的是二维数组，所以该函数仅适用于已排好序的序列。</p><p>2.迭代器遍历时，函数返回的是迭代器</p><p>详解见博客：<a href="http://m.biancheng.net/view/7521.html">http://m.biancheng.net/view/7521.html</a></p></blockquote><p>用for(const auto row : matrix)遍历时会超时的原因</p><blockquote><p>1.auto即for(auto x:range) 会拷贝一份range元素，不会改变range中的元素；<br>2.只读取range中的元素,使用const auto&amp;,如：for(const auto&amp;x:range),它不会进行拷贝，也不会修改range,效率会比用auto快一点。</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h5 id="方法1：二分查找"><a href="#方法1：二分查找" class="headerlink" title="方法1：二分查找"></a>方法1：二分查找</h5><blockquote><p>由于矩阵 matrix 中每一行的元素都是升序排列的，因此我们可以对每一行都使用一次二分查找，判断 target 是否在该行中，从而判断 target 是否出现。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; row : matrix)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(row.<span class="hljs-built_in">begin</span>(),row.<span class="hljs-built_in">end</span>(),target);<br>            <span class="hljs-keyword">if</span>(it != row.<span class="hljs-built_in">end</span>() &amp;&amp; *it == target)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用库函数</title>
    <link href="/2022/04/05/C-%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <url>/2022/04/05/C-%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="builtin-popcount"><a href="#builtin-popcount" class="headerlink" title="__builtin_popcount"></a>__builtin_popcount</h3><blockquote><p>__builtin_popcount()</p><p>该函数是C++自带的库函数，内部实现是用查表实现的。<br><strong>作用</strong>：统计数字在二进制下“1”的个数。</p><p>Note：是__builtin_popcount()，千万别写成 _builtin_popcount()</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计哈希集合+设计哈希映射</title>
    <link href="/2022/03/31/%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/"/>
    <url>/2022/03/31/%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-705：设计哈希集合"><a href="#LeetCode-705：设计哈希集合" class="headerlink" title="LeetCode 705：设计哈希集合"></a>LeetCode 705：设计哈希集合</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：<br>1.哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。<br>2.冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现冲突时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：<br>  链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。<br>  开放地址法：当发现哈希值 hh 处产生冲突时，根据某种策略，从 hh 出发找到下一个不冲突的位  置。例如，一种最简单的策略是，不断地检查 h+1,h+2,h+3,… 这些整数对应的位置。<br>  再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。<br>3.扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。  </p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 实现 MyHashSet 类： </p><p>void add(key) 向哈希集合中插入值 key 。 </p><p>bool contains(key) 返回哈希集合中是否存在这个值 key 。 </p><p>void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：链地址法</strong> </p><p>设哈希表的大小为 base，则可以设计一个简单的哈希函数：hash(x) = x mod base。 开辟一个大小为 base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。 由于使用整数除法作为哈希函数，为了尽可能避免冲突，应当将 base 取为一个质数。取 base=769。   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashSet</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; data;  <span class="hljs-comment">//定义一个数组base,数组的每一个位置是一个链表</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">769</span>;  <span class="hljs-comment">//定义哈希表的大小</span><br>    <span class="hljs-comment">//用链地址法设计一个哈希表</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> key % base;<br>    &#125;<br><br>    <span class="hljs-built_in">MyHashSet</span>():<span class="hljs-built_in">data</span>(base) &#123;&#125;<br><br>    <span class="hljs-comment">//插入</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);  <span class="hljs-comment">//找出key在哈希表中对应的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)  <span class="hljs-comment">//迭代法遍历key在哈希表中对应位置的链表</span><br>        &#123;<br>            <span class="hljs-comment">//如果插入元素存在 则返回空</span><br>            <span class="hljs-keyword">if</span>(*it == key)<br>            &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果元素不存在则插入元素</span><br>        data[h].<span class="hljs-built_in">push_back</span>(key);<br>    &#125;<br><br>    <span class="hljs-comment">//删除</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(*it == key)<br>            &#123;<br>                data[h].<span class="hljs-built_in">erase</span>(it);<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                    注意：data\[h\].erase(it) 这里的it不可写成\*it或者key</span><br><span class="hljs-comment">                    因为删除的是key在链表上的地址而不是值</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断key是否存在</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(*it == key)  <span class="hljs-comment">/* 注意：*it */</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><h2 id="LeetCode-706：设计哈希映射"><a href="#LeetCode-706：设计哈希映射" class="headerlink" title="LeetCode 706：设计哈希映射"></a>LeetCode 706：设计哈希映射</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p><em><strong>设计哈希映射</strong></em> 与 <em><strong>设计哈希集合</strong></em> 解法接近，唯一的区别在于哈希映射存储的不是 key 本身，而是键值对(key,value)。   </p><blockquote><p>哈希表增加键值对的函数：map1.insert(make_pair(n,1))<br>哈希表删除键值对的函数：data[h].erase(it)<br>哈希表使用迭代器遍历时：<br>i-&gt;first：表示键<br>i-&gt;second：表示值  </p></blockquote><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。 实现 MyHashMap 类： </p><p>MyHashMap() 用空映射初始化对象 </p><p>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。 </p><p>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。 </p><p>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashMap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; data;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">769</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> key % base;<br>    &#125;<br><br>    <span class="hljs-built_in">MyHashMap</span>():<span class="hljs-built_in">data</span>(base) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;first == key)<br>            &#123;<br>                it-&gt;second = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(key,value));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;first == key)<br>            &#123;<br>                <span class="hljs-keyword">return</span> it-&gt;second;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;first == key)<br>            &#123;<br>                data[h].<span class="hljs-built_in">erase</span>(it);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三数之和</title>
    <link href="/2022/03/25/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/03/25/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-15-三数之和"><a href="#LeetCode-15-三数之和" class="headerlink" title="LeetCode 15:三数之和"></a>LeetCode 15:三数之和</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>本题与LeetCode 1：两数之和类似，是非常经典的面试题，但是做法不尽相同。  </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：排序+双指针</strong> </p><blockquote><p>关键字：不可以包含重复<br>模式识别：利用排序避免重复答案<br>降低复杂度变成twoSum<br>利用双指针找到所有解<br>数组有序，和为定值的两个数一定可以通过头尾指针向中间移动获得。<br>关键去重，每次移动跳过与当前值相同的元素，枚举第三个元素也要跳过重复元素。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">//对数组进行排序方便去重</span><br>        <span class="hljs-comment">//枚举a</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>])  <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//去重，需要和上次遍历的元素不同</span><br>            <span class="hljs-type">int</span> target = <span class="hljs-number">0</span>-nums[i];  <span class="hljs-comment">//定义目标值target，转化为二元组问题target = b+c</span><br>            <span class="hljs-type">int</span> l = i+<span class="hljs-number">1</span>,r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;  <span class="hljs-comment">//定义首尾指针，通过首尾指针移动获取定值target</span><br>            <span class="hljs-keyword">while</span>(l&lt;r)  <span class="hljs-comment">//通过首尾指针获取定值target</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[l]+nums[r] == target)<br>                &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);  <span class="hljs-comment">//将符合的元组加入结果ans中</span><br>                    <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[l] == nums[l+<span class="hljs-number">1</span>])  l++;  <span class="hljs-comment">//去除重复的左指针元素</span><br>                    <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[r] == nums[r<span class="hljs-number">-1</span>])  r--;  <span class="hljs-comment">//去除重复的右指针元素</span><br>                    l++;  <span class="hljs-comment">//左指针向右移</span><br>                    r--;  <span class="hljs-comment">//右指针向左移</span><br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[l]+nums[r] &gt; target)<br>                &#123;<br>                    r--;  <span class="hljs-comment">//结果大于目标值，右指针向左移</span><br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    l++;  <span class="hljs-comment">//结果小于目标值，左指针向右移</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;  <span class="hljs-comment">//返回结果</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1Jq4y1A7u7?spm_id_from=333.337.search-card.all.click">B站视频讲解</a>  </p><h2 id="LeetCode-1：两数之和"><a href="#LeetCode-1：两数之和" class="headerlink" title="LeetCode 1：两数之和"></a>LeetCode 1：两数之和</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个整数数组 nums 和一个整数目标值 target ，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：暴力枚举</strong> </p><p><strong>方法2：哈希表</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map1;  <span class="hljs-comment">//键为nums[i] 值为数组下标i</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> it = map1.<span class="hljs-built_in">find</span>(target-nums[i]);<br>            <span class="hljs-keyword">if</span>(it  != map1.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                <span class="hljs-keyword">return</span> &#123;it-&gt;second,i&#125;;<br>            &#125;<br>            map1[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一题四解：排序 集合 哈希表 位运算</title>
    <link href="/2022/03/25/%E4%B8%80%E9%A2%98%E5%9B%9B%E8%A7%A3%EF%BC%9A%E6%8E%92%E5%BA%8F-%E9%9B%86%E5%90%88-%E5%93%88%E5%B8%8C%E8%A1%A8-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/03/25/%E4%B8%80%E9%A2%98%E5%9B%9B%E8%A7%A3%EF%BC%9A%E6%8E%92%E5%BA%8F-%E9%9B%86%E5%90%88-%E5%93%88%E5%B8%8C%E8%A1%A8-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-136：只出现一次的数字"><a href="#LeetCode-136：只出现一次的数字" class="headerlink" title="LeetCode 136：只出现一次的数字"></a>LeetCode 136：只出现一次的数字</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>这道题 虽然是一道简单题，但是学到了很多东西。意识到大一学的C++其实有很多东西都没有学到，比如哈希表和集合的很多用法都不够了解。  </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：判断排序数组前后元素是否相等</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">2</span> &amp;&amp; nums[<span class="hljs-number">0</span>] !=  nums[<span class="hljs-number">1</span>])  <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">2</span> &amp;&amp; nums[n<span class="hljs-number">-1</span>] != nums[n<span class="hljs-number">-2</span>])  <span class="hljs-keyword">return</span> nums[n<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n<span class="hljs-number">-1</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != nums[i<span class="hljs-number">-1</span>] &amp;&amp; nums[i] != nums[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：集合</strong> </p><blockquote><p>set集合只能使用迭代器遍历，不能使用下标遍历。所以只能返回set1.begin()，而不能返回下标。 auto ans = set1.begin();  //这里只能用auto 而不能用<br>int return *ans;  //返回的必须是指针类型 因为set1.begin()是迭代器类型，所以 ans只能用auto定义，而不能用int类型定义。因此返回的值也必须是 指针类型的。  </p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(set1.<span class="hljs-built_in">count</span>(n))<br>            &#123;<br>                set1.<span class="hljs-built_in">erase</span>(n);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                set1.<span class="hljs-built_in">insert</span>(n);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> ans = set1.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">//这里只能用auto 而不能用int</span><br>        <span class="hljs-keyword">return</span> *ans;  <span class="hljs-comment">//返回的必须是指针类型</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法3：哈希表</strong> </p><blockquote><p>哈希表增加键值对的函数：map1.insert(make_pair(n,1));<br>哈希表使用迭代器遍历时： i-&gt;first：表示键 i-&gt;second：表示值  </p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(map1.<span class="hljs-built_in">find</span>(n) == map1.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(n,<span class="hljs-number">1</span>));  <span class="hljs-comment">//如果字典中不存在该key，则新增一个键值对(n,1)</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                map1[n]++;  <span class="hljs-comment">//如果字典中存在该key，则将值加1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=map1.<span class="hljs-built_in">begin</span>(); i!=map1.<span class="hljs-built_in">end</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i-&gt;second == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> i-&gt;first;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Note：相同类型的哈希表题目：</strong><a href="https://leetcode-cn.com/problems/majority-element/">LeetCode 169：多数元素</a>   </p><p><strong>方法4：位运算</strong> </p><p>这个方法太精妙了！   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和 - 输入 BST</title>
    <link href="/2022/03/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-iv-%E8%BE%93%E5%85%A5-bst/"/>
    <url>/2022/03/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-iv-%E8%BE%93%E5%85%A5-bst/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-653-两数之和IV-输入BST"><a href="#LeetCode-653-两数之和IV-输入BST" class="headerlink" title="LeetCode 653:两数之和IV-输入BST"></a>LeetCode 653:两数之和IV-输入BST</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个二叉搜索树 root 和一个目标结果 k ，如果 BST 中存在两个元素且它们的和等于 给定的目标结果，则返回 true 。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：深度优先搜索+哈希表</strong> </p><p>使用深度优先搜索的方式遍历整棵树，用哈希表记录遍历过的节点的值。 对于一个值为x的节点，我们检查哈希表中是否存在k-x即可。如果存在对应的元素，那么我们就可以在这棵树上找到两个节点的和为k，否则我们将x放入哈希表中。 如果遍历完整棵树都不存在对应的元素，那么该树上不存在两个和为k的节点   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; hashTable;  <span class="hljs-comment">//哈希表要定义在函数外面</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(hashTable.<span class="hljs-built_in">count</span>(k - root-&gt;val))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        hashTable.<span class="hljs-built_in">insert</span>(root-&gt;val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findTarget</span>(root-&gt;left,k)  <span class="hljs-built_in">findTarget</span>(root-&gt;right,k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：广度优先搜索+哈希表</strong> </p><p>使用广度优先搜索的方式遍历整棵树，用哈希表记录遍历过的节点的值。 </p><p>首先创建一个哈希表和一个队列，将根节点加入队列中，然后执行以下步骤： </p><p>1.从队列中取出队头，假设其值为 x </p><p>2.检查哈希表中是否存在 k - x，如果存在，返回 true </p><p>3.否则，将该节点的左右的非空子节点加入队尾 </p><p>4.重复以上步骤，直到队列为空 </p><p>5.如果队列为空，说明树上不存在两个和为 k的节点，返回 false   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; hashTable;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(hashTable.<span class="hljs-built_in">count</span>(k - node-&gt;val))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            hashTable.<span class="hljs-built_in">insert</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node-&gt;right != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><p><strong>方法3：深度优先搜索+中序遍历+双指针</strong>   <strong>方法4：迭代+中序遍历+双指针</strong>   </p><p><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/liang-shu-zhi-he-iv-shu-ru-bst-by-leetco-b4nl/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="/2022/03/20/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/03/20/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-98-验证二叉搜索树"><a href="#LeetCode-98-验证二叉搜索树" class="headerlink" title="LeetCode 98 :验证二叉搜索树"></a>LeetCode 98 :验证二叉搜索树</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>有效二叉搜索树定义：<br>1.节点左子树只包含小于当前节点的数<br>2.节点右子树只包含大于当前节点的数<br>3.所有左子树和右子树自身必须也是二叉搜索树  </p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：递归法</strong> </p><p>定义一个函数bool helper(TreeNode*,long long int lower,long long int upper) 如果上界和下界存在，判断当前节点的值是否在界内，如果不在界内，返回false。将当前节点的值作为上界，继续对node-&gt;left进行递归；将当前节点作为下界，继续对node-&gt;right进行递归。   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> lower,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> upper)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//空节点是合理的二叉搜索树</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt;= lower  root-&gt;val &gt;= upper)  <span class="hljs-comment">//节点不为空，判断节点上的值是否在上下界内</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//更改上下界 递归遍历二叉树的左右子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root-&gt;left,lower,root-&gt;val) &amp;&amp; <span class="hljs-built_in">helper</span>(root-&gt;right,root-&gt;val,upper);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root,LONG_MIN,LONG_MAX);  <span class="hljs-comment">//从根节点开始，上下界都为空</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：中序遍历</strong> </p><p>根据二叉搜索树的性质，得知二叉搜索树中序遍历得到的值构成的序列一定是升序的，在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是。</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; stack;  <span class="hljs-comment">//定义栈stack来存储未拜访过的树节点</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> inorder = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)INT_MIN<span class="hljs-number">-1</span>;  <span class="hljs-comment">//inorder用来存储上一个遍历到的树节点的值</span><br>        <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>()  root != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">//不断将root的左子节点加入栈 直到没有剩余的左节点</span><br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                stack.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//将当前子树最左边的节点从stack中取出</span><br>            <span class="hljs-comment">//如果中序遍历得到的节点的值小于等于前一个inorder，说明不是二叉搜索树</span><br>            <span class="hljs-keyword">if</span> (root-&gt;val &lt;= inorder)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            inorder = root-&gt;val;  <span class="hljs-comment">//将inorder设为当前节点的值</span><br>            root = root-&gt;right;  <span class="hljs-comment">//将root设为当前节点的右子节点，继续循环</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树路径总和</title>
    <link href="/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-112-路径总和"><a href="#LeetCode-112-路径总和" class="headerlink" title="LeetCode 112:路径总和"></a>LeetCode 112:路径总和</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>本题核心思想是对树进行一次遍历，在遍历是记录从根节点到当前节点的路径总和，以防止重复计算。 </p><p> </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：广度优先搜索</strong> </p><p>使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。 这样我们可以使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和。   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//首先判断根节点是否存在</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que_node;  <span class="hljs-comment">//定义一个队列 用于存储将要遍历的结点</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; que_val;  <span class="hljs-comment">//定义一个队列 用于记录从根节点到当前节点路径和</span><br>        que_node.<span class="hljs-built_in">push</span>(root);  <span class="hljs-comment">//将根节点加入第一个队列</span><br>        que_val.<span class="hljs-built_in">push</span>(root-&gt;val);  <span class="hljs-comment">//将根节点的值加入第二个队列</span><br>        <span class="hljs-comment">//迭代循环队列 直到队列为空</span><br>        <span class="hljs-keyword">while</span>(!que_node.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* now = que_node.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-type">int</span> temp = que_val.<span class="hljs-built_in">front</span>();<br>            que_node.<span class="hljs-built_in">pop</span>();<br>            que_val.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(now-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; now-&gt;right == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//不存在左右节点 则为叶节点</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(temp == targetSum)  <span class="hljs-comment">//判断路径和与目标值是否相等</span><br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//不相等则迭代继续</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(now-&gt;left != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//存在左子节点</span><br>            &#123;<br>                que_node.<span class="hljs-built_in">push</span>(now-&gt;left);  <span class="hljs-comment">//将左子节点加入第一个队列</span><br>                que_val.<span class="hljs-built_in">push</span>(now-&gt;left-&gt;val + temp);<span class="hljs-comment">//将左子节点值与当前路径和相加加入第二个队列</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(now-&gt;right != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//存在右子节点</span><br>            &#123;<br>                que_node.<span class="hljs-built_in">push</span>(now-&gt;right);  <span class="hljs-comment">//将右子节点加入第一个队列</span><br>                que_val.<span class="hljs-built_in">push</span>(now-&gt;right-val + temp);<span class="hljs-comment">//将右子节点值与当前路径和相加加入第二个队列</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//没有满足条件的 返回false</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：递归</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> sum == root-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) <br>               <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻转二叉树+对称二叉树</title>
    <link href="/2022/03/17/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/03/17/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-226-翻转二叉树"><a href="#LeetCode-226-翻转二叉树" class="headerlink" title="LeetCode 226:翻转二叉树"></a>LeetCode 226:翻转二叉树</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点root 的左右两颗子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以root 为根节点的整棵子树的翻转。</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode* left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        TreeNode* right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;left = right;<br>        root-&gt;right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><h2 id="LeetCode-101-对称二叉树"><a href="#LeetCode-101-对称二叉树" class="headerlink" title="LeetCode 101:对称二叉树"></a>LeetCode 101:对称二叉树</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。 </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：递归</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMirror</span><span class="hljs-params">(TreeNode* t1,TreeNode* t2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">nullptr</span> &amp;&amp; t2 == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">nullptr</span>  t2 == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t1-&gt;val == t2-&gt;val &amp;&amp; <span class="hljs-built_in">isMirror</span>(t1-&gt;left,t2-&gt;right) &amp;&amp; <span class="hljs-built_in">isMirror</span>(t1-&gt;right,t2-&gt;left);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isMirror</span>(root-&gt;left,root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：迭代（利用队列）</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMirror</span><span class="hljs-params">(TreeNode* t1,TreeNode* t2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(t1);<br>        q.<span class="hljs-built_in">push</span>(t2);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            t1 = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            t2 = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">nullptr</span> &amp;&amp; t2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>((t1 == <span class="hljs-literal">nullptr</span>  t2 == <span class="hljs-literal">nullptr</span>)  t1-&gt;val != t2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            q.<span class="hljs-built_in">push</span>(t1-&gt;left);<br>            q.<span class="hljs-built_in">push</span>(t2-&gt;right);<br>            q.<span class="hljs-built_in">push</span>(t1-&gt;right);<br>            q.<span class="hljs-built_in">push</span>(t2-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode\* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isMirror</span>(root-&gt;left,root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><p><a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的层序遍历</title>
    <link href="/2022/03/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/03/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-102-二叉树的层序遍历"><a href="#LeetCode-102-二叉树的层序遍历" class="headerlink" title="LeetCode 102:二叉树的层序遍历"></a>LeetCode 102:二叉树的层序遍历</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>二叉树 队列 广度优先搜索  </p><h4 id="二维vector容器的使用"><a href="#二维vector容器的使用" class="headerlink" title="二维vector容器的使用"></a>二维vector容器的使用</h4><p>res.push_back(vector<int>());  //向二维vector容器res中添加一行</p><p>res.back().push_back(node-&gt;val);  //向二维容器的最后一行插入一个元素node-&gt;val</p><p>其中res.back()是指二维容器res的最后一行</p><p><a href="https://www.cnblogs.com/tyty-Somnuspoppy/p/9361821.html">关于C++中vector&lt;vector<int> &gt;的使用</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>用广度优先搜索+队列解决二叉树的层序遍历 我们可以用一种巧妙的方法修改广度优先搜索： 首先根元素入队 当队列不为空的时候 求当前队列的长度 currentLevelSize 依次从队列中取currentLevelSize个元素进行拓展，然后进入下一次迭代 它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取currentLevelSize个元素。在上述过程中的第 i 次迭代就得到了二叉树的第 i层的 currentLevelSize个元素。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;  <span class="hljs-comment">//定义二维vector容器res用来存储树中元素</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        queue&lt;TreeNode*&gt; q;  <span class="hljs-comment">//定义队列q临时存储树中元素</span><br>        q.<span class="hljs-built_in">push</span>(root);  <span class="hljs-comment">//将树的根节点插入队列</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> currentLevelSize = q.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">//定义队列的当前长度currentLevelSize</span><br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());  <span class="hljs-comment">//向二维vector容器res中添加一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=currentLevelSize; i++)<br>            &#123;<br>                <span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">//定义临时结点node为队列头结点</span><br>                q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//弹出队列头结点</span><br>                res.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(node-&gt;val);  <span class="hljs-comment">//将队列头结点元素的值存入res中</span><br>                <span class="hljs-comment">//将结点的左右儿子节点插入队列中</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left)<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node-&gt;right)<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用栈实现队列+用队列实现栈</title>
    <link href="/2022/03/11/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2022/03/11/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-232-用栈实现队列"><a href="#LeetCode-232-用栈实现队列" class="headerlink" title="LeetCode 232:用栈实现队列"></a>LeetCode 232:用栈实现队列</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>栈 队列 模拟  </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>请你仅使用两个栈实现先入先出队列,队列支持一般队列支持的所有操作（push、pop、peek、empty） 实现 MyQueue 类： </p><p>void push(int x) 将元素 x 推到队列的末尾 </p><p>int pop() 从队列的开头移除并返回元素 </p><p>int peek() 返回队列开头的元素 </p><p>boolean empty() 如果队列为空，返回 true ；否则，返回 false  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stIn;  <span class="hljs-comment">//创建一个栈stIn 用于进栈</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stOut; <span class="hljs-comment">//创建一个栈stOut 用于出栈</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stIn.<span class="hljs-built_in">push</span>(x);  <span class="hljs-comment">//将元素压入栈中</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stOut.<span class="hljs-built_in">empty</span>())  <span class="hljs-comment">//如果栈stOut为空 则将栈stIn中所有元素压入栈stOut中</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(!stIn.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                stOut.<span class="hljs-built_in">push</span>(stIn.<span class="hljs-built_in">top</span>());  <span class="hljs-comment">//将栈stIn栈顶元素压入栈stOut中</span><br>                stIn.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//栈顶元素压入栈stOut后将元素删除</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//当栈stOut不为空时 则直接弹出栈stOut栈顶元素</span><br>        <span class="hljs-type">int</span> res = stOut.<span class="hljs-built_in">top</span>();<br>        stOut.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//直接使用已有的pop函数获取栈顶元素</span><br>        stOut.<span class="hljs-built_in">push</span>(res);  <span class="hljs-comment">//因为pop函数弹出了元素res 所以再添加回去</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stIn.<span class="hljs-built_in">empty</span>() &amp;&amp; stOut.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">//当栈stIn和栈stOut都不为空时 队列才不为空</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>  <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/232-yong-zhan-shi-xian-dui-lie-liang-ge-zhan-lai-m/">LeetCode题解+动画演示</a>  </p><h2 id="LeetCode-225：用队列实现栈"><a href="#LeetCode-225：用队列实现栈" class="headerlink" title="LeetCode 225：用队列实现栈"></a>LeetCode 225：用队列实现栈</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>队列 栈 模拟  </p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、 pop 和 empty）。 实现 MyStack 类： </p><p>void push(int x) 将元素 x 压入栈顶。 </p><p>int pop() 移除并返回栈顶元素。 </p><p>int top() 返回栈顶元素。 </p><p>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：两个队列实现栈</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue1;  <span class="hljs-comment">//创建一个队列queue1 用于存储所有入栈元素</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; queue2;  <span class="hljs-comment">//创建一个队列queue2 用于临时存储即将入栈的元素</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">//使用两个队列模拟元素入栈</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        queue2.<span class="hljs-built_in">push</span>(x);  <span class="hljs-comment">//将入栈元素插入临时队列queue2</span><br>        <span class="hljs-keyword">while</span>(!queue1.<span class="hljs-built_in">empty</span>())  <span class="hljs-comment">//将队列queue1中所有元素插入临时队列queue2</span><br>        &#123;<br>            queue2.<span class="hljs-built_in">push</span>(queue1.<span class="hljs-built_in">front</span>());  <span class="hljs-comment">//将队列queue1中头元素插入队列queue2中</span><br>            queue1.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//删除队列queue1头元素</span><br>        &#125;<br>        <span class="hljs-built_in">swap</span>(queue1,queue2);  <span class="hljs-comment">//为了避免打乱元素顺序 交换队列queue1和queue2</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = queue1.<span class="hljs-built_in">front</span>();<br>        queue1.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = queue1.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">//因为queue1包含了栈中所有元素 所以只需要检查queue1是否为空即可</span><br>        <span class="hljs-comment">//queue2作为临时队列 不永久存储栈中的元素</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><p><strong>方法二：一个队列实现栈</strong></p><p>入栈操作时，首先获得入栈前的元素个数 n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>        q.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            q.<span class="hljs-built_in">push</span>(q.<span class="hljs-built_in">front</span>());<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> r = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> r = q.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>N叉树的前序遍历</title>
    <link href="/2022/03/10/N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/03/10/N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-589题：N叉树的前序遍历"><a href="#LeetCode-589题：N叉树的前序遍历" class="headerlink" title="LeetCode 589题：N叉树的前序遍历"></a>LeetCode 589题：N叉树的前序遍历</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h4><blockquote><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p></blockquote><p> <a href="http://c.biancheng.net/view/6826.html">C++STL中emplace_back()和push_back()的区别</a>  </p><h4 id="C-const-关键字"><a href="#C-const-关键字" class="headerlink" title="C++ const 关键字"></a>C++ const 关键字</h4><blockquote><p>const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。 </p></blockquote><p><a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">菜鸟教程：C++ const 关键字小结</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个 n 叉树的根节点  root ，返回其节点值的前序遍历。 n 叉树在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-type">const</span> Node* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; ch : root-&gt;children) &#123;    <span class="hljs-comment">//auto 类型也是 C++11 新标准中的，用来自动获取变量的类型</span><br>            <span class="hljs-built_in">helper</span>(ch, res);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">helper</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的前序、中序、后序遍历</title>
    <link href="/2022/03/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/03/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-144题：二叉树的前序遍历"><a href="#LeetCode-144题：二叉树的前序遍历" class="headerlink" title="LeetCode 144题：二叉树的前序遍历"></a>LeetCode 144题：二叉树的前序遍历</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根-&gt;左-&gt;右   </p><p><strong>方法一：递归法</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">AC代码：<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode\* root,vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br><br>        &#123;<br><br>            <span class="hljs-keyword">return</span>;<br><br>        &#125;<br><br>        res.push\_back(root-&gt;val);<br><br>        <span class="hljs-built_in">preorder</span>(root-&gt;left,res);<br><br>        <span class="hljs-built_in">preorder</span>(root-&gt;right,res);<br><br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode\* root)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        <span class="hljs-built_in">preorder</span>(root,res);<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><h3 id="Note：参数传递时什么时候需要传入参数的引用-amp"><a href="#Note：参数传递时什么时候需要传入参数的引用-amp" class="headerlink" title="Note：参数传递时什么时候需要传入参数的引用&amp;"></a>Note：参数传递时什么时候需要传入参数的引用&amp;</h3><p>当对参数的修改结果需要带回主函数时在传递参数时则需要在参数前加取地址符&amp; </p><p><a href="https://blog.csdn.net/dyw_666666/article/details/107823466">CSDN博客：（易错点）什么时候要传入参数的引用“&amp;“</a>   </p><p><strong>方法二：迭代法</strong> </p><p>LeetCode题解+动画演示 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/">二叉树前序遍历 迭代法</a> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        stack&lt;TreeNode*&gt; stk;<br>        TreeNode* node = root;<br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>()  node != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(node-&gt;val);<br>                stk.<span class="hljs-built_in">emplace</span>(node);<br>                node = node-&gt;left;<br>            &#125;<br>            node = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            node = node-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><h2 id="LeetCode-94题：二叉树的中序遍历"><a href="#LeetCode-94题：二叉树的中序遍历" class="headerlink" title="LeetCode 94题：二叉树的中序遍历"></a>LeetCode 94题：二叉树的中序遍历</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>左-&gt;根-&gt;右   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left,ans);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right,ans);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">inorder</span>(root,ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><h2 id="LeetCode-145题：二叉树的后序遍历"><a href="#LeetCode-145题：二叉树的后序遍历" class="headerlink" title="LeetCode 145题：二叉树的后序遍历"></a>LeetCode 145题：二叉树的后序遍历</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>左-&gt;右-&gt;根   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">postorder</span>(root-&gt;left,ans);<br>        <span class="hljs-built_in">postorder</span>(root-&gt;right,ans);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">postorder</span>(root,ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表+合并链表+移除链表元素</title>
    <link href="/2022/03/04/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/03/04/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-206题：反转链表"><a href="#LeetCode-206题：反转链表" class="headerlink" title="LeetCode 206题：反转链表"></a>LeetCode 206题：反转链表</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">//定义一个当前节点的前一个节点 初始化为空</span><br>        ListNode* cur = head;  <span class="hljs-comment">//定义一个当前节点 初始化为头结点</span><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//当前节点不为空</span><br>        &#123;<br>            ListNode* tmp = cur-&gt;next;  <span class="hljs-comment">//定义一个tmp结点 用于保存当前节点的后序节点</span><br>            cur-&gt;next = pre;  <span class="hljs-comment">//反转链表 让cur节点指向pre节点</span><br>            pre = cur;  <span class="hljs-comment">//前序节点后移一位</span><br>            cur = tmp;  <span class="hljs-comment">//当前节点后移一位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;  <span class="hljs-comment">//返回新链表指向的头结点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><p><a href="https://www.bilibili.com/video/BV1KZ4y157Up/?spm_id_from=333.788">B站反转链表讲解</a></p><p> </p><h2 id="LeetCode-21题：合并两个有序链表"><a href="#LeetCode-21题：合并两个有序链表" class="headerlink" title="LeetCode 21题：合并两个有序链表"></a>LeetCode 21题：合并两个有序链表</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>只会迭代法 递归法有点复杂  </p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* preHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);  <span class="hljs-comment">//定义哨兵节点preHead</span><br>        ListNode* prev = preHead;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>                prev-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            prev = prev-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br>        prev-&gt;next = l1 == <span class="hljs-literal">nullptr</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> preHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>  LeetCode题解合并两个有序链表动画演示非常nice！ <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">LeetCode题解</a>  </p><h2 id="LeetCode-203题：移除链表元素"><a href="#LeetCode-203题：移除链表元素" class="headerlink" title="LeetCode 203题：移除链表元素"></a>LeetCode 203题：移除链表元素</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val  的节点,并返回新的头结点。  </p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：迭代法</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//由于链表头结点Head可能需要被删除 创建哑结点preHead 令pre-&gt;next = head</span><br>        ListNode* preHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        ListNode* tmp = preHead;  <span class="hljs-comment">//定义当前节点 初始化为preHead</span><br>        <span class="hljs-keyword">while</span>(tmp-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmp-&gt;next-&gt;val == val)<br>            &#123;<br>                tmp-&gt;next = tmp-&gt;next-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tmp = tmp-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> preHead-&gt;next;  <span class="hljs-comment">//返回删除操作后的头结点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++标准模板库（C++STL）</title>
    <link href="/2022/03/04/c%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88cstl%EF%BC%89/"/>
    <url>/2022/03/04/c%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88cstl%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-iterator迭代器"><a href="#1-iterator迭代器" class="headerlink" title="1.iterator迭代器"></a>1.iterator迭代器</h2><h3 id="1-定义和初始化"><a href="#1-定义和初始化" class="headerlink" title="1.定义和初始化"></a>1.定义和初始化</h3><p>每种容器都定义了自己的迭代器类型，如vector </p><p>vector<int>::iterator it;  //定义一个名为it的变量 </p><p>每种容器都定义了一对名为begin和end的函数，用于返回迭代器 </p><p>vector<int> ivec; </p><p>vector<int>::iterator it1 = ivec.begin();  //将迭代器it1指向ivec的第一个元素 </p><p>vector<int>::iterator it2 = ivec.end();  //将迭代器it2指向ivec容器的最后一个元素的下一个位置 end并不指向容器的任何元素  </p><h3 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2.常用操作"></a>2.常用操作</h3><p>vector<int>:: iterator it; </p><p>1.it +/- n; </p><p>2.it1 +/-= it2; </p><p>3.it1-it2; </p><p>4.&gt;,&gt;=,&lt;,&lt;=  </p><h2 id="2-vector容器"><a href="#2-vector容器" class="headerlink" title="2.vector容器"></a>2.vector容器</h2><h3 id="1-创建vector对象"><a href="#1-创建vector对象" class="headerlink" title="1.创建vector对象"></a>1.创建vector对象</h3><p>创建vector容器有三种形式 </p><p>1.不指定容器的个数：vector<int> v;</p><p>2.创建时指定容器的大小：vector<double> v(10);</p><p>3.创建一个具有n个元素的向量容器，每个元素具有指定的初始值 vector<double> v(10,8.6)  //v向量容器，共有10个元素，每个元素的初始值为8.6  </p><h3 id="2-尾部元素扩张"><a href="#2-尾部元素扩张" class="headerlink" title="2.尾部元素扩张"></a>2.尾部元素扩张</h3><p>v.push_back(num);  </p><h3 id="3-下标方式访问vector元素"><a href="#3-下标方式访问vector元素" class="headerlink" title="3.下标方式访问vector元素"></a>3.下标方式访问vector元素</h3><p>类似于数组的访问方式。对于vector对象，可以采用下标方式随意访问它的某个元素，也可以通过下标方式对某个元素重新赋值 </p><p>vector<int> v(3); </p><p>v[0]=2,v[1]=7,v[2]=9; </p><p>cout&lt;&lt;v[0]&lt;&lt;” “&lt;&lt;v[1]&lt;&lt;” “&lt;&lt;v[2]&lt;&lt;endl;  </p><h3 id="4-用迭代器访问vector容器"><a href="#4-用迭代器访问vector容器" class="headerlink" title="4.用迭代器访问vector容器"></a>4.用迭代器访问vector容器</h3><p>vector<int> v(3); </p><p>v[0]=2,v[1]=7,v[2]=9; </p><p>vector<int>::iterator it;  //定义迭代器 变量 </p><p>for(it=v.begin(); it!=v.end(); it++) </p><p>{ cout&lt;&lt;*it&lt;&lt;” “;  //输出迭代器上的元素值 }  </p><h3 id="5-插入元素"><a href="#5-插入元素" class="headerlink" title="5.插入元素"></a>5.插入元素</h3><p>insert()方法可以在vector对象的任意位置前插入一个新元素 </p><p>insert()方法要求插入的位置是元素的迭代器的位置，而不是元素的下标 </p><p>v.insert(v.begin(),8);  //在最前面插入新元素，元素值为8 </p><p>v.insert(v.begin()+2,1);  //在第2个元素前插入新元素1 </p><p>v.insert(v.end(),3);  //在向量末尾追加新元素3  </p><h3 id="6-元素的删除"><a href="#6-元素的删除" class="headerlink" title="6.元素的删除"></a>6.元素的删除</h3><p>erase()方法可以删除vector中迭代器所指向的一个元素或者一段区间中的所有元素 </p><p>v.erase(v.begin()+2);  //删除第二个元素，从0开始计数 </p><p>v.erase(v.begin()+1,v.begin()+5);  //删除迭代器第1到5区间的所有元素 </p><p>clear()方法则一次性删除vector中的所有元素 </p><p>v.clear();  //清空向量  </p><h3 id="7-使用reverse反向排列算法"><a href="#7-使用reverse反向排列算法" class="headerlink" title="7.使用reverse反向排列算法"></a>7.使用reverse反向排列算法</h3><p>reverse(v.begin(),v.end());  //反向排列向量从首到尾间的元素  </p><h3 id="8-使用sort算法对向量元素排序"><a href="#8-使用sort算法对向量元素排序" class="headerlink" title="8.使用sort算法对向量元素排序"></a>8.使用sort算法对向量元素排序</h3><p>sort(v.begin(),v.end());   自定义降序排列比较函数cmp bool cmp(const int &amp;a,const int &amp;b) { return a&gt;b; } sort(v.begin(),v.end(),cmp)  //按cmp函数比较规则排序  </p><h3 id="9-向量的大小"><a href="#9-向量的大小" class="headerlink" title="9.向量的大小"></a>9.向量的大小</h3><p>v.size()  //方法返回向量大小，即元素的个数 v.empty()  //方法返回向量是否为空  </p><h2 id="3-string容器"><a href="#3-string容器" class="headerlink" title="3.string容器"></a>3.string容器</h2><p> </p><h2 id="4-set容器"><a href="#4-set容器" class="headerlink" title="4.set容器"></a>4.set容器</h2><p> </p><h2 id="5-multiset容器"><a href="#5-multiset容器" class="headerlink" title="5.multiset容器"></a>5.multiset容器</h2><p> </p><h2 id="6-map容器"><a href="#6-map容器" class="headerlink" title="6.map容器"></a>6.map容器</h2><p> </p><h2 id="7-multimap容器"><a href="#7-multimap容器" class="headerlink" title="7.multimap容器"></a>7.multimap容器</h2><p> </p><h2 id="8-queue容器"><a href="#8-queue容器" class="headerlink" title="8.queue容器"></a>8.queue容器</h2><p> </p><h2 id="9-priority-queue容器"><a href="#9-priority-queue容器" class="headerlink" title="9.priority_queue容器"></a>9.priority_queue容器</h2><p> </p><h2 id="10-stack容器"><a href="#10-stack容器" class="headerlink" title="10.stack容器"></a>10.stack容器</h2><p> </p><h2 id="11-algorithm容器"><a href="#11-algorithm容器" class="headerlink" title="11.algorithm容器"></a>11.algorithm容器</h2>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组</title>
    <link href="/2022/02/28/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2022/02/28/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-566题：重塑矩阵"><a href="#LeetCode-566题：重塑矩阵" class="headerlink" title="LeetCode 566题：重塑矩阵"></a>LeetCode 566题：重塑矩阵</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>vector容器定义二维数组  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将二维数组映射成一个一维数组，将这个一维数组映射回 r 行 c 列的二维数组。 对于x∈[0,mn)，第 x个元素在 nums 中对应的下标为(x / n,x % n)，而在新的重塑矩阵中对应的下标为(x / c,x % c)。我们直接进行赋值即可。   AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) &#123;<br>        <span class="hljs-type">int</span> m = mat.<span class="hljs-built_in">size</span>(),n = mat\[<span class="hljs-number">0</span>\].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(m*n != r*c)<br>        &#123;<br>            <span class="hljs-keyword">return</span> mat;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(r,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(c));  <span class="hljs-comment">//vector容器定义一个二维数组ans</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m*n; i++)<br>        &#123;<br>            ans[i/c][i%c] = mat[i/n][i%n];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><h2 id="LeetCode-118题：杨辉三角"><a href="#LeetCode-118题：杨辉三角" class="headerlink" title="LeetCode 118题：杨辉三角"></a>LeetCode 118题：杨辉三角</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>动态规划  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(numRows);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numRows; i++)<br>        &#123;<br>            ans[i].<span class="hljs-built_in">resize</span>(i + <span class="hljs-number">1</span>);  <span class="hljs-comment">//resize 改变当前使用数据的大小，如果它比当前使用的大，则填充默认值</span><br>            ans[i][<span class="hljs-number">0</span>]=ans[i][i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;i; j++)<br>            &#123;<br>                ans[i][j] = ans[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+ans[i<span class="hljs-number">-1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ vector 容器浅析</title>
    <link href="/2022/02/27/c-vector-%E5%AE%B9%E5%99%A8%E6%B5%85%E6%9E%90/"/>
    <url>/2022/02/27/c-vector-%E5%AE%B9%E5%99%A8%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>刷LeetCode有所收获的第一天！  </p><h2 id="LeetCode-350题：两个数组的交集"><a href="#LeetCode-350题：两个数组的交集" class="headerlink" title="LeetCode 350题：两个数组的交集"></a>LeetCode 350题：两个数组的交集</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1</strong></p><p>哈希表（不太会） 学习C++算法哈希（Hash） B站收藏   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums1.<span class="hljs-built_in">size</span>()&gt;nums2.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersect</span>(nums2,nums1);<br>        &#125;<br>        unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums1)<br>        &#123;<br>            m[num]++;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; intersection;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(num))<br>            &#123;<br>                intersection.<span class="hljs-built_in">push_back</span>(num);<br>                m[num]--;<br>                <span class="hljs-keyword">if</span>(m[num] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    m.<span class="hljs-built_in">erase</span>(num);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intersection;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2</strong> </p><p>排序+双指针（用到了C++ vector容器） </p><p>学习C++  STL标准库函数+vector 容器 </p><p><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector 容器浅析</a>   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(),nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(),nums2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> length1 = nums1.<span class="hljs-built_in">size</span>(),length2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>,index2 = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(index1&lt;length1 &amp;&amp; index2&lt;length2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums1[index1]&gt;nums2[index2])<br>            &#123;<br>                index2++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[index1]&lt;nums2[index2])<br>            &#123;<br>                index1++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(nums1[index1]);<br>                index1++;<br>                index2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中国石油大学（华东）校园网络认证脚本</title>
    <link href="/2022/02/23/%E4%B8%AD%E5%9B%BD%E7%9F%B3%E6%B2%B9%E5%A4%A7%E5%AD%A6%EF%BC%88%E5%8D%8E%E4%B8%9C%EF%BC%89%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%BB%9C%E8%AE%A4%E8%AF%81%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/02/23/%E4%B8%AD%E5%9B%BD%E7%9F%B3%E6%B2%B9%E5%A4%A7%E5%AD%A6%EF%BC%88%E5%8D%8E%E4%B8%9C%EF%BC%89%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%BB%9C%E8%AE%A4%E8%AF%81%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>本脚本采用Python3编写，依赖于</p><p>Requests </p><p>urllib/urllib.parse </p><p>快速安装依赖</p><p>pip install -r requirements.txt  </p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>在config.py文件下输入学号、密码和运营商编号，然后运行python3 NetworkAuth.py </p><p>运营商对应编号：</p><p>default -&gt; 校园网 unicom -&gt; 联通 cmcc -&gt; 移动 ctcc -&gt; 电信 local -&gt; 校园内网 </p><p>可自动判别登录情况，引导用户交互。  </p><h3 id="目前支持的网络类型："><a href="#目前支持的网络类型：" class="headerlink" title="目前支持的网络类型："></a>目前支持的网络类型：</h3><p>有线网络（认证IP地址:121.251.251.207) </p><p>无线网络(SSID: UPC, 认证IP地址:121.251.251.217) </p><p>802.1X网络无需使用本脚本 </p><p>转载于：<a href="https://github.com/EndangeredF1sh/UPCNet">https://github.com/EndangeredF1sh/UPCNet</a></p>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UPC疫情防控通自动提交脚本—云函数实现</title>
    <link href="/2022/02/23/upc%E7%96%AB%E6%83%85%E9%98%B2%E6%8E%A7%E9%80%9A%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC-%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/02/23/upc%E7%96%AB%E6%83%85%E9%98%B2%E6%8E%A7%E9%80%9A%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC-%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p> </p><h3 id="1、获取Server酱的API-Key实现微信推送"><a href="#1、获取Server酱的API-Key实现微信推送" class="headerlink" title="1、获取Server酱的API Key实现微信推送"></a>1、获取Server酱的API Key实现微信推送</h3><p>打开<a href="http://sc.ftqq.com/3.version">Server酱主页</a>，按照页面指示获取Key并绑定微信，复制Key备用。</p><p> </p><h3 id="2、代码文件准备"><a href="#2、代码文件准备" class="headerlink" title="2、代码文件准备"></a>2、代码文件准备</h3><p>下载本仓库的代码，修改Index.js中的代码，使用上述准备的内容替换对应内容即可，修改完后打包即可。</p><p> </p><h3 id="3、新建云函数"><a href="#3、新建云函数" class="headerlink" title="3、新建云函数"></a>3、新建云函数</h3><p>这里以腾讯云为例，进入<a href="https://console.cloud.tencent.com/scf">腾讯云函数页面</a>，点击侧栏的函数服务，新建一个函数。</p><p>如果需要Server酱通知，请不要选择广州地区，其他地区请自行测试</p><p>函数名称随意，运行环境选择Nodejs12.16，创建方式选择空白函数即可，点击完成。 选择函数代码标签，提交方法选择本地上传zip包，上传方式选择在线安装依赖，选择保存并测试。成功的话转下一步，失败的话请检查相关字符串是否正确。  </p><h3 id="4、设置触发器"><a href="#4、设置触发器" class="headerlink" title="4、设置触发器"></a>4、设置触发器</h3><p>选择左侧触发管理，创建一个新的触发器。选择定时触发，出发周期自定义，自己根据想要自动提交的时间输入Cron数据即可。推荐使用0 1 1,8 * * * *即可，该触发时间为每天的01:01和08:01，防止因为系统或某方面原因而失败。</p><p> </p><h3 id="5、数据配置"><a href="#5、数据配置" class="headerlink" title="5、数据配置"></a>5、数据配置</h3><p>如果需要修改表单数据，在自动提交之前手动通过提交一次数据即可，第二天将会自动修正数据。</p><p> </p><p>博客转载于：<a href="https://github.com/tienskowl/AutoReport">https://github.com/tienskowl/AutoReport</a></p>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题！</title>
    <link href="/2022/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2022/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>立个flag 每日一道LeetCode算法题+百词斩背单词！</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
