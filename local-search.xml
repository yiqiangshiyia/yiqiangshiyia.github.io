<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java-集合框架</title>
    <link href="/2022/07/04/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/07/04/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="1-集合的概念"><a href="#1-集合的概念" class="headerlink" title="1. 集合的概念"></a>1. 集合的概念</h2><h3 id="1-1-集合概念"><a href="#1-1-集合概念" class="headerlink" title="1.1 集合概念"></a>1.1 集合概念</h3><p>集合是对象的容器，定义了多个对对象进行操作的常用方法。可实现数组的功能。</p><h3 id="1-2-集合和数组的区别"><a href="#1-2-集合和数组的区别" class="headerlink" title="1.2 集合和数组的区别"></a>1.2 集合和数组的区别</h3><ul><li>数组的长度固定，集合的长度不固定</li><li>数组可以存储基本类型和引用类型，集合只能存储引用类型</li><li>位置：java.util.*</li></ul><h2 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2. Collection接口"></a>2. Collection接口</h2><h3 id="2-1-Collection体系集合"><a href="#2-1-Collection体系集合" class="headerlink" title="2.1 Collection体系集合"></a>2.1 Collection体系集合</h3><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220628162522.png" alt="QQ截图20220628162522"></p><h3 id="2-2-Collection父接口"><a href="#2-2-Collection父接口" class="headerlink" title="2.2 Collection父接口"></a>2.2 Collection父接口</h3><blockquote><p>public interface Collection&lt;E&gt;<br>extends Iterable&lt;E&gt;</p><p>集合层次结构中的根界面。 集合表示一组被称为其元素的对象。  一些集合允许重复元素，而其他集合不允许。 有些被命令和其他无序。  JDK不提供此接口的任何直接实现：它提供了更具体的子接口的实现，如 Set 和 List 。 该界面通常用于传递集合，并在需要最大的通用性的情况下对其进行操作。 </p></blockquote><p><strong>特点：</strong>代表一组任意类型的对象，无序、无下标、不能重复</p><p><strong>方法：</strong></p><ul><li>boolean add(Object obj)    //添加一个对象</li><li>boolean addAll(Collection c)    //将一个集合中的所有对象添加到此集合中</li><li>void clear()    //清空此集合中的所有对象</li><li>boolean contains(Object o)    //判断此集合中是否包含o对象</li><li>boolean equals(Object o)    //比较此集合是否与指定对象相等</li><li>boolean isEmpty()    //判断此集合是否为空</li><li>boolean remove(Object o)    //在此集合中移除o对象</li><li>int size()    //返回此集合中的元素个数</li><li>Object[] toArray()    //将此集合转换成数组</li></ul><p><strong>Collection接口使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Collection;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">//集合添加、删除、遍历、判断</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Collection</span> <span class="hljs-variable">collection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <span class="hljs-comment">//实例化ArrayList</span><br>        <span class="hljs-comment">//添加</span><br>        collection.add(<span class="hljs-string">&quot;1&quot;</span>);<br>        collection.add(<span class="hljs-string">&quot;2&quot;</span>);<br>        collection.add(<span class="hljs-string">&quot;3&quot;</span>);<br>        collection.add(<span class="hljs-string">&quot;4&quot;</span>);<br>        System.out.println(collection);<br><br>        <span class="hljs-comment">//删除</span><br>        collection.remove(<span class="hljs-string">&quot;3&quot;</span>);<br>        System.out.println(collection);<br><br>        <span class="hljs-comment">//遍历1:增强for遍历</span><br>        <span class="hljs-keyword">for</span>(Object obj : collection)&#123;<br>            System.out.println(obj);<br>        &#125;<br>        <span class="hljs-comment">//遍历2:迭代器遍历</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> collection.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            System.out.println(it.next());<br>        &#125;<br><br>        <span class="hljs-comment">//判断</span><br>        System.out.println(collection.isEmpty());<br>        System.out.println(collection.contains(<span class="hljs-string">&quot;4&quot;</span>));<br>        System.out.println(collection.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-List接口与实现类"><a href="#3-List接口与实现类" class="headerlink" title="3. List接口与实现类"></a>3. List接口与实现类</h2><h3 id="3-1-List子接口"><a href="#3-1-List子接口" class="headerlink" title="3.1 List子接口"></a>3.1 List子接口</h3><blockquote><p>public interface List&lt;E&gt;<br>extends Collection&lt;E&gt;</p><p>有序集合（也称为序列 ）。 该界面的用户可以精确控制列表中每个元素的插入位置。  用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 </p></blockquote><p><strong>特点：</strong>有序、有下标、元素可以重复</p><p><strong>方法：</strong></p><ul><li><p>void add(int index, Object o)    //在index位置插入对象o</p></li><li><p>boolean addAll(int index, Collection c)    //将一个集合中的元素添加到此集合中的index位置</p></li><li><p>Object get(int index)    //返回集合中指定位置的元素</p></li><li><p>int indexOf(Object o)    //返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-1</p></li><li><p>List subList(int fromIndex, int toIndex)    //返回fromIndex和toIndex之间的集合元素</p></li><li><p>包含Collection中的所有方法</p></li></ul><p><strong>List接口使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> List;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">//添加元素</span><br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;2&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;3&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;5&quot;</span>);<br>        list.add(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;4&quot;</span>);<br>        System.out.println(list.toString());<br><br>        <span class="hljs-comment">//删除</span><br>        list.remove(<span class="hljs-string">&quot;2&quot;</span>);<br>        list.remove(<span class="hljs-number">3</span>);<br>        System.out.println(list.toString());<br><br>        <span class="hljs-comment">//遍历1 for循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>            System.out.println(list.get(i));  <span class="hljs-comment">//Note:和数组遍历略有区别</span><br>        &#125;<br>        <span class="hljs-comment">//遍历2 增强for循环</span><br><br>        <span class="hljs-comment">//遍历3 迭代器遍历</span><br><br>        <span class="hljs-comment">//遍历4 列表迭代器 list特有 功能更加强大 listIterator可以向前或向后遍历，添加、删除、修改元素</span><br>        <span class="hljs-type">ListIterator</span> <span class="hljs-variable">lit</span> <span class="hljs-operator">=</span> list.listIterator();<br>        <span class="hljs-keyword">while</span>(lit.hasNext())&#123;<br>            System.out.println(lit.nextIndex()+<span class="hljs-string">&quot;:&quot;</span>+lit.next());<br>        &#125;<br>        <span class="hljs-comment">//从后往前遍历</span><br>        <span class="hljs-keyword">while</span>(lit.hasPrevious())&#123;<br>            System.out.println(lit.previousIndex()+<span class="hljs-string">&quot;:&quot;</span>+lit.previous());<br>        &#125;<br><br>        <span class="hljs-comment">//获取位置</span><br>        System.out.println(list.indexOf(<span class="hljs-string">&quot;4&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-ArrayList"><a href="#3-2-ArrayList" class="headerlink" title="3.2 ArrayList"></a>3.2 ArrayList</h3><blockquote><p>public class ArrayList<E><br>extends AbstractList<E><br>implements List<E>, RandomAccess, Cloneable, Serializable</p><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。ArrayList 继承了 AbstractList ，并实现了 List 接口。</p></blockquote><p><strong>特点：</strong>数组结构实现，查询快，增删慢；运行效率快，线程不安全</p><p><strong>方法：</strong></p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-add.html">add()</a></td><td align="left">将元素插入到指定位置的 arraylist 中</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-addall.html">addAll()</a></td><td align="left">添加集合中的所有元素到 arraylist 中</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-clear.html">clear()</a></td><td align="left">删除 arraylist 中的所有元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-clone.html">clone()</a></td><td align="left">复制一份 arraylist</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-contains.html">contains()</a></td><td align="left">判断元素是否在 arraylist</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-get.html">get()</a></td><td align="left">通过索引值获取 arraylist 中的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-indexof.html">indexOf()</a></td><td align="left">返回 arraylist 中元素的索引值</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-removeall.html">removeAll()</a></td><td align="left">删除存在于指定集合中的 arraylist 里的所有元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-remove.html">remove()</a></td><td align="left">删除 arraylist 里的单个元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-size.html">size()</a></td><td align="left">返回 arraylist 里元素数量</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-isempty.html">isEmpty()</a></td><td align="left">判断 arraylist 是否为空</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-sublist.html">subList()</a></td><td align="left">截取部分 arraylist 的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-set.html">set()</a></td><td align="left">替换 arraylist 中指定索引的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-sort.html">sort()</a></td><td align="left">对 arraylist 元素进行排序</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-toarray.html">toArray()</a></td><td align="left">将 arraylist 转换为数组</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-tostring.html">toString()</a></td><td align="left">将 arraylist 转换为字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-surecapacity.html">ensureCapacity</a>()</td><td align="left">设置指定容量大小的 arraylist</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-lastindexof.html">lastIndexOf()</a></td><td align="left">返回指定元素在 arraylist 中最后一次出现的位置</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-retainall.html">retainAll()</a></td><td align="left">保留 arraylist 中在指定集合中也存在的那些元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-containsall.html">containsAll()</a></td><td align="left">查看 arraylist 是否包含指定集合中的所有元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-trimtosize.html">trimToSize()</a></td><td align="left">将 arraylist 中的容量调整为数组中的元素个数</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-removerange.html">removeRange()</a></td><td align="left">删除 arraylist 中指定索引之间存在的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-replaceall.html">replaceAll()</a></td><td align="left">将给定的操作内容替换掉数组中每一个元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-removeif.html">removeIf()</a></td><td align="left">删除所有满足特定条件的 arraylist 元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/java/java-arraylist-foreach.html">forEach()</a></td><td align="left">遍历 arraylist 中每一个元素并执行特定操作</td></tr></tbody></table><p><strong>ArrayList的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ArrayList;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        ArrayList&lt;String&gt; arraylist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <span class="hljs-comment">//&lt;&gt;代表泛型 ()代表无参构造</span><br>        <span class="hljs-comment">//添加元素</span><br>        arraylist.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        arraylist.add(<span class="hljs-string">&quot;world&quot;</span>);<br>        arraylist.add(<span class="hljs-string">&quot;!&quot;</span>);<br>        arraylist.add(<span class="hljs-string">&quot;java&quot;</span>);<br>        System.out.println(arraylist);<br><br>        <span class="hljs-comment">//访问元素</span><br>        System.out.println(arraylist.get(<span class="hljs-number">3</span>));<br><br>        <span class="hljs-comment">//修改元素</span><br>        arraylist.set(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;javase&quot;</span>);<br>        System.out.println(arraylist);<br><br>        <span class="hljs-comment">//删除元素</span><br>        arraylist.remove(<span class="hljs-number">3</span>);<br>        System.out.println(arraylist);<br><br>        <span class="hljs-comment">//计算大小</span><br>        System.out.println(arraylist.size());<br><br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-comment">//遍历1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;arraylist.size(); i++)&#123;<br>            System.out.println(arraylist.get(i));<br>        &#125;<br>        <span class="hljs-comment">//遍历2</span><br>        <span class="hljs-keyword">for</span>(Object obj : arraylist)&#123;<br>            System.out.println(obj);<br>        &#125;<br>        <span class="hljs-comment">//遍历3</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> arraylist.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            System.out.println(it.next());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-LinkedList"><a href="#3-3-LinkedList" class="headerlink" title="3.3 LinkedList"></a>3.3 LinkedList</h3><blockquote><p>public class LinkedList<E><br>extends AbstractSequentialList<E><br>implements List<E>, Deque<E>, Cloneable, Serializable</p><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p><p>存储结构：双向链表</p></blockquote><p><strong>特点：</strong>链表结构实现，增删快，查询慢</p><p><strong>分类：</strong></p><p>链表可分为单向链表和双向链表。</p><p>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/06/408px-Singly-linked-list.svg_.png" alt="img"></p><p>一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/06/610px-Doubly-linked-list.svg_.png" alt="img"></p><p>Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。</p><p><strong>实现与继承：</strong></p><p><img src="https://img.yiqiangshiyia.cn/blog/linkedlist.png" alt="linkedlist"></p><ul><li>LinkedList 继承了 AbstractSequentialList 类。</li><li>LinkedList 实现了 Queue 接口，可作为队列使用。</li><li>LinkedList 实现了 List 接口，可进行列表的相关操作。</li><li>LinkedList 实现了 Deque 接口，可作为队列使用。</li><li>LinkedList 实现了 Cloneable 接口，可实现克隆。</li><li>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</li></ul><p><strong>方法：</strong></p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">public boolean add(E e)</td><td align="left">链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public void add(int index, E element)</td><td align="left">向指定位置插入元素。</td></tr><tr><td align="left">public boolean addAll(Collection c)</td><td align="left">将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public boolean addAll(int index, Collection c)</td><td align="left">将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public void addFirst(E e)</td><td align="left">元素添加到头部。</td></tr><tr><td align="left">public void addLast(E e)</td><td align="left">元素添加到尾部。</td></tr><tr><td align="left">public void clear()</td><td align="left">清空链表。</td></tr><tr><td align="left">public E removeFirst()</td><td align="left">删除并返回第一个元素。</td></tr><tr><td align="left">public E removeLast()</td><td align="left">删除并返回最后一个元素。</td></tr><tr><td align="left">public boolean remove(Object o)</td><td align="left">删除某一元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public E remove(int index)</td><td align="left">删除指定位置的元素。</td></tr><tr><td align="left">public E remove()</td><td align="left">删除并返回第一个元素。</td></tr><tr><td align="left">public boolean contains(Object o)</td><td align="left">判断是否含有某一元素。</td></tr><tr><td align="left">public E get(int index)</td><td align="left">返回指定位置的元素。</td></tr><tr><td align="left">public E getFirst()</td><td align="left">返回第一个元素。</td></tr><tr><td align="left">public E getLast()</td><td align="left">返回最后一个元素。</td></tr><tr><td align="left">public int indexOf(Object o)</td><td align="left">查找指定元素从前往后第一次出现的索引。</td></tr><tr><td align="left">public int lastIndexOf(Object o)</td><td align="left">查找指定元素最后一次出现的索引。</td></tr><tr><td align="left">public E set(int index, E element)</td><td align="left">设置指定位置的元素。</td></tr><tr><td align="left">public Object clone()</td><td align="left">克隆该列表。</td></tr><tr><td align="left">public int size()</td><td align="left">返回链表元素个数。</td></tr><tr><td align="left">public Object[] toArray()</td><td align="left">返回一个由链表元素组成的数组。</td></tr></tbody></table><p><strong>LinkedList的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> LinkedList;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//创建集合</span><br>        LinkedList&lt;String&gt; sites = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br><br>        <span class="hljs-comment">//添加</span><br>        sites.add(<span class="hljs-string">&quot;Geogle&quot;</span>);<br>        sites.add(<span class="hljs-string">&quot;runoob&quot;</span>);<br>        sites.add(<span class="hljs-string">&quot;firefox&quot;</span>);<br>        sites.add(<span class="hljs-string">&quot;baidu&quot;</span>);<br>        System.out.println(sites.size());<br>        System.out.println(sites);<br>        <span class="hljs-comment">//头部添加</span><br>        sites.addFirst(<span class="hljs-string">&quot;taobao&quot;</span>);<br>        <span class="hljs-comment">//尾部添加</span><br>        sites.addLast(<span class="hljs-string">&quot;wiki&quot;</span>);<br>        System.out.println(sites);<br><br>        <span class="hljs-comment">//删除</span><br>        sites.remove(<span class="hljs-string">&quot;firefox&quot;</span>);<br>        <span class="hljs-comment">//删除头部元素</span><br>        sites.removeFirst();<br>        <span class="hljs-comment">//删除尾部元素</span><br>        sites.removeLast();<br>        System.out.println(sites);<br><br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-comment">//遍历1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;sites.size(); i++)&#123;<br>            System.out.println(sites.get(i));<br>        &#125;<br>        <span class="hljs-comment">//遍历2</span><br>        <span class="hljs-keyword">for</span>(Object obj : sites)&#123;<br>            System.out.println(obj);<br>        &#125;<br>        <span class="hljs-comment">//遍历3</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> sites.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            System.out.println(it.next());<br>        &#125;<br>        <br>        <span class="hljs-comment">//获取</span><br>        <span class="hljs-comment">//使用getFirst()获取头部元素</span><br>        System.out.println(sites.getFirst());<br>        <span class="hljs-comment">//使用getLast()获取尾部元素</span><br>        System.out.println(sites.getLast());<br>        <span class="hljs-comment">//获取index</span><br>        System.out.println(sites.indexOf(<span class="hljs-string">&quot;runoob&quot;</span>));<br><br>        <span class="hljs-comment">//判断</span><br>        System.out.println(sites.isEmpty());<br>        System.out.println(sites.contains(<span class="hljs-string">&quot;runoob&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-ArrayList和LinkedList区别"><a href="#3-4-ArrayList和LinkedList区别" class="headerlink" title="3.4 ArrayList和LinkedList区别"></a>3.4 ArrayList和LinkedList区别</h3><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220704160627.png" alt="QQ截图20220704160627"></p><h3 id="3-5-Vector"><a href="#3-5-Vector" class="headerlink" title="3.5 Vector"></a>3.5 Vector</h3><blockquote><p>public class Vector<E><br>extends AbstractList<E><br>implements List<E>, RandomAccess, Cloneable, Serializable</p><p>Vector类实现了可扩展的对象数组。  像数组一样，它包含可以使用整数索引访问的组件。 但是， Vector的大小可以根据需要增长或缩小，以适应在创建Vector之后添加和删除项目。</p></blockquote><p><strong>特点：</strong>数组结构实现，查询快，增删慢；运行效率慢，线程安全</p><p><strong>vector的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Vector;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//创建集合</span><br>        <span class="hljs-type">Vector</span> <span class="hljs-variable">vector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>        <span class="hljs-comment">//添加</span><br>        vector.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        vector.add(<span class="hljs-string">&quot;world&quot;</span>);<br>        vector.add(<span class="hljs-string">&quot;!&quot;</span>);<br>        vector.add(<span class="hljs-string">&quot;java&quot;</span>);<br>        System.out.println(vector);<br><br>        <span class="hljs-comment">//删除</span><br>        vector.remove(<span class="hljs-string">&quot;!&quot;</span>);<br><span class="hljs-comment">//      vector.remove(2);</span><br>        System.out.println(vector);<br><br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-comment">//使用枚举器</span><br>        <span class="hljs-type">Enumeration</span> <span class="hljs-variable">en</span> <span class="hljs-operator">=</span> vector.elements();<br>        <span class="hljs-keyword">while</span>(en.hasMoreElements())&#123;<br>            System.out.println(en.nextElement());<br>        &#125;<br><br>        <span class="hljs-comment">//判断</span><br>        System.out.println(vector.contains(<span class="hljs-string">&quot;java&quot;</span>));<br>        System.out.println(vector.isEmpty());<br>        <br>        <span class="hljs-comment">//vector其他方法:firstElement、lastElement、elementAt()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-Iterator"><a href="#3-6-Iterator" class="headerlink" title="3.6 Iterator"></a>3.6 Iterator</h3><h4 id="3-6-1-Iterator"><a href="#3-6-1-Iterator" class="headerlink" title="3.6.1 Iterator"></a>3.6.1 Iterator</h4><blockquote><p>public interface Iterator<E></p><p>位于java.util包下</p><p>Iterator(迭代器)不是一个集合，它是一种用于访问集合的方法，可用于迭代ArrayList和HashSet等集合。</p></blockquote><p><strong>常用方法：</strong></p><ul><li>iterator()    //获取迭代器</li><li>boolean hasNext()    //检测集合中是否还有元素</li><li>E next()    //返回迭代器的下一个元素，并且更新迭代器的状态</li><li>void remove()    //将迭代器返回的元素删除</li></ul><h4 id="3-6-1-ListIterator"><a href="#3-6-1-ListIterator" class="headerlink" title="3.6.1 ListIterator"></a>3.6.1 ListIterator</h4><blockquote><p>public interface ListIterator<E><br>extends Iterator<E></p><p>用于允许程序员沿任一方向遍历列表的列表的迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。 </p></blockquote><p><strong>常用方法：</strong></p><ul><li>void add(E e)    //将指定的元素插入列表</li><li>boolean hasNext()    //如果此列表迭代器在向前方向遍历列表时具有更多元素，则返回true</li><li>boolean hasPrevious()    //如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true</li><li>E next()    //返回列表中的下一个元素，并且前进光标位置。</li><li>int nextIndex()    //返回由后续调用返回的元素的索引 next()</li><li>E previous()    //返回列表中的上一个元素，并向后移动光标位置。 </li><li>int previousIndex()    //返回由后续调用返回的元素的索引 previous()</li><li>void remove()    //从列表中删除 next() 或 previous() 返回的最后一个元素。 </li><li>void set(E e)    //用指定的元素替换 next() 或 previous() 返回的最后一个元素。 </li></ul><h2 id="4-泛型和工具类"><a href="#4-泛型和工具类" class="headerlink" title="4. 泛型和工具类"></a>4. 泛型和工具类</h2><h3 id="4-1-泛型"><a href="#4-1-泛型" class="headerlink" title="4.1 泛型"></a>4.1 泛型</h3><ul><li>Java泛型是JDK1.5中引入的一个新特性，其本质是参数化类型，把类型作为参数传递</li><li>常见的形式有泛型类、泛型接口、泛型方法</li><li>语法：&lt;E,….&gt; E称为类型占位符，表示一种引用类型</li><li>好处：<ul><li>提高代码的复用性</li><li>防止类型转换异常，提高代码的安全性</li></ul></li></ul><h2 id="5-Set接口与实现类"><a href="#5-Set接口与实现类" class="headerlink" title="5. Set接口与实现类"></a>5. Set接口与实现类</h2><h2 id="6-Map接口与实现类"><a href="#6-Map接口与实现类" class="headerlink" title="6. Map接口与实现类"></a>6. Map接口与实现类</h2><h1 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h1><h2 id="Java数组-1"><a href="#Java数组-1" class="headerlink" title="Java数组"></a>Java数组</h2><p><strong>数组的创建：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*格式1：</span><br><span class="hljs-comment">元素类型[] 数组名 = new 元素类型[元素个数或数组长度];</span><br><span class="hljs-comment">示例：</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">格式2：</span><br><span class="hljs-comment">元素类型[] 数组名 = new 元素类型[]&#123;元素，元素，……&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>&#125;;<br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>数组的遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一：for循环</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listFor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span>[] arrs = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrs.length; i++) &#123;<br>            System.out.print(arrs[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;   <br><span class="hljs-comment">//方式二：for-each</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listFor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span>[] arrs = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> arr : arrs) &#123;<br>            System.out.print(arr+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><ul><li>菜鸟笔记：<a href="https://www.runoob.com/java/java-array.html">https://www.runoob.com/java/java-array.html</a></li></ul><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p><p><strong>具有以下功能：</strong></p><ul><li>给数组赋值：通过 fill 方法。</li><li>对数组排序：通过 sort 方法,按升序。</li><li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul><p><strong>实现方法：</strong></p><ul><li><p><strong>public static void fill(int[] a, int val)</strong></p><p>将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>Arrays.fill(arr,<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>public static void sort(Object[] a)</strong></p><p>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;;<br>Arrays.sort(arr);<br></code></pre></td></tr></table></figure></li><li><p><strong>public static boolean equals(long[] a, long[] a2)</strong></p><p>如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p></li><li><p><strong>public static int binarySearch(Object[] a, Object key)</strong></p><p>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</p></li></ul><h1 id="Java字符串"><a href="#Java字符串" class="headerlink" title="Java字符串"></a>Java字符串</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>菜鸟笔记：<a href="https://www.runoob.com/java/java-string.html">https://www.runoob.com/java/java-string.html</a></li></ul><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ul><li>菜鸟笔记：<a href="https://www.runoob.com/java/java-stringbuffer.html">https://www.runoob.com/java/java-stringbuffer.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Hyperledger Fabric石油能源交易系统</title>
    <link href="/2022/07/03/%E5%9F%BA%E4%BA%8EHyperledger-Fabric%E7%9F%B3%E6%B2%B9%E8%83%BD%E6%BA%90%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/07/03/%E5%9F%BA%E4%BA%8EHyperledger-Fabric%E7%9F%B3%E6%B2%B9%E8%83%BD%E6%BA%90%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="基于Hyperledger-Fabric石油能源交易系统"><a href="#基于Hyperledger-Fabric石油能源交易系统" class="headerlink" title="基于Hyperledger Fabric石油能源交易系统"></a>基于Hyperledger Fabric石油能源交易系统</h1><h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><p>​        项目使用 Hyperledger Fabric 构建底层区块链网络, go语言编写智能合约，应用层使用 gin+fabric-sdk-go ，前端使用 vue+element-ui框架，系统的设计主要是基于区块链的去中心化，数据共享和不可篡改的特点。项目的核心是分布式账本，记录区块上发生的所有石油交易。区块链账本是去中心化的，它会被复制到许多区块参与者中，每个参与者都在协作维护账本；数据共享是当某个客户发起交易后，所有位于区块链上的客户都可以进行竞价交易且交易信息共享；不可篡改指发起一笔交易后不能单方面撤销交易,如果需要撤销之前的交易必须再花几笔交易告诉全区块我需要撤销之前的交易。系统中有管理员和五个客户，管理员为客户创建石油，客户可以查看和交易石油。客户交易信息以附加的方式记录到区块链上，使用加密技术保证一旦将交易添加到账本就无法修改。</p><p>​        客户发起销售，所有的客户都可以查看销售列表，在有效期期间可以随时取消交易，有效期到期后自动关闭交易，购买者购买后进行扣款操作，并等待发起销售的客户确认，交易完成后，更新石油拥有者。客户发起捐赠，指定受赠人，受赠人确认接收受赠前，双方可取消捐赠/受赠。</p><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h4 id="区块链部分"><a href="#区块链部分" class="headerlink" title="区块链部分"></a>区块链部分</h4><ol><li><p>crypto-config.yaml文件</p><p>crypto-config.yaml定义了生成证书的数量，还有用户的数量，使用cryptogen工具读取改文件生成相应的公私钥和证书，生成的证书在crypto-config文件夹中</p></li><li><p>configtx.yaml文件</p><p>configtx.yaml中定义了组织与Fabric共识、区块大小，超时时间等参数，用于生成创世区块</p></li><li><p>docker-compose文件</p><p> 这个是docker-compose启动时读取的文件，将一次性启动多个容器，这些容器是peer节点和orderer节点，文件中写明了具体的配置信息，比如挂载一些本地文件，使用的镜像文件等，比如使用1.4.12版本的fabric镜像</p></li><li><p>start.sh 文件</p><p>这个是启动区块链网络的脚本</p></li><li><p>hyperledger-fabric-linux-amd64-1.4.12 文件夹</p><p>文件夹内有生成证书、创世区块的工具</p></li><li><p>explorer文件夹</p><p>这个是区块链浏览器的文件夹，文件夹中的start.sh文件，每次重启区块链网络时私钥会变，因此该文件中有替换密钥的操作。connection-profile中的network_temp.json是配置文件，定义了读取区块链网络的信息与登陆区块链浏览器的账号密码。</p></li></ol><h4 id="智能合约部分"><a href="#智能合约部分" class="headerlink" title="智能合约部分"></a>智能合约部分</h4><ol><li><p>go.mod 文件</p><p>这个文件是定义了一个模块，一般就是本目录，在本项目中是chaincode，然后有go的版本和需要的依赖</p></li><li><p>go.sum文件</p><p>这个是固定项目的依赖文件版本</p></li><li><p>chaincode.go文件</p><p>这个里边主要关注两个函数，一个是Init函数，就是在链码进行实例化时会进行的操作，在这个项目中是向区块链中写入预先设定的账户；下边是Invoke函数，除了Init时对区块链的操作都是Invoke，可以看到当传入参数时，会读取api里相应的函数。</p></li><li><p>api中的.go文件</p><p>这里就是智能合约中函数的位置，当接收到sdk的请求时，调用这里的函数，实现相应的操作。比较重要的有QueryAccountList(),CreateRealEstate(),QueryRealEstateList()，分别完成了对账户的查询、创建石油与查询石油列表。</p></li><li><p>model文件夹中的model.go文件</p><p>该文件定义了一些结构体，包含了字段的属性，例如定义了一个石油的所有属性</p></li></ol><h4 id="app部分"><a href="#app部分" class="headerlink" title="app部分"></a>app部分</h4><ol><li><p>build.sh</p><p>这个是构建app的容器，将app放在容器中运行，具体做的事情在Dockfile文件里</p></li><li><p>start.sh、docker-compose.yml就是启动app容器</p></li><li><p>server文件夹就是后端，使用的gin框架</p><p>当后端接收到web的请求后，就会查看routers的路由信息，找到对应的api进行操作。在api中，接收到web发来的请求后进行处理，然后调用智能合约实现对区块链网络的交互</p></li><li><p>blockchain/sdk.go config.yaml</p><p>这里定义了 sdk的配置信息</p></li><li><p>web文件夹是前端的部分 使用的vue + element ui</p></li><li><p>api文件夹中的js文件定义了函数相对应的url、method、携带的数据，就是与后端进行交互</p></li><li><p>views文件夹是前端</p><p>当用户在页面填写数据后，使用vue文件里的方法，调用api里的函数，与后端进行交互</p></li></ol><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><h4 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h4><p>VMware虚拟机上安装Ubuntu环境，Ubuntu的版本为20.04，一开始安装的Ubuntu18.04在配置环境遇到了很多不明原因的报错。</p><h4 id="2-安装docker和docker-compose"><a href="#2-安装docker和docker-compose" class="headerlink" title="2.安装docker和docker-compose"></a>2.安装docker和docker-compose</h4><p>安装docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<br></code></pre></td></tr></table></figure><p>将用户添加到docker组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure><p>更新用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">newgrp docker<br></code></pre></td></tr></table></figure><p>安装docker-compose</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo curl -L <span class="hljs-string">&quot;https://mirror.ghproxy.com/https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>增加运行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>测试是否安装成功，有输出内容即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose <br></code></pre></td></tr></table></figure><p>给docker换源 编辑 /etc/docker/daemon.json 写入以下内容保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>重启docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><p>启动区块链网络以及部署智能合约：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/admin001/桌面/fabdeal-master/network<br>sudo ./start.sh<br></code></pre></td></tr></table></figure><p>编译镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/admin001/桌面/fabdeal-master/application<br>sudo ./build.sh<br></code></pre></td></tr></table></figure><p>启动应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ./start.sh<br></code></pre></td></tr></table></figure><p>虚拟机浏览器访问：<a href="http://localhost:8000/web">http://localhost:8000/web</a><br>主机浏览器访问：<a href="http://192.168.80.129:8000/web">http://192.168.80.129:8000/web</a></p><p>启动区块链浏览器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/admin001/桌面/fabdeal-master/network/explorer<br>sudo ./start.sh<br></code></pre></td></tr></table></figure><p>虚拟机浏览器访问：<a href="http://localhost:8080/">http://localhost:8080</a>    用户名:admin，密码:123456</p><p>主机浏览器访问：<a href="http://192.168.80.129:8080/">http://192.168.80.129:8080</a></p><p>清理环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/admin001/桌面/fabdeal-master/network<br>sudo ./stop.sh<br><span class="hljs-built_in">cd</span> /home/admin001/桌面/fabdeal-master/application<br>sudo ./stop.sh<br></code></pre></td></tr></table></figure><p>项目演示视频：</p><ul><li><a href="https://www.bilibili.com/video/BV1N34y1p7EW?spm_id_from=333.999.list.card_archive.click&amp;vd_source=7ad06c95735c5cae130daf28b94f5d0f">https://www.bilibili.com/video/BV1N34y1p7EW?spm_id_from=333.999.list.card_archive.click&amp;vd_source=7ad06c95735c5cae130daf28b94f5d0f</a></li></ul><p>Note：</p><ul><li>本项目改自Github项目：基于区块链（Hyperledger Fabric）的房地产交易系统</li><li>原项目Github地址：<a href="https://github.com/togettoyou/fabric-realty">https://github.com/togettoyou/fabric-realty</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows10电脑重装系统</title>
    <link href="/2022/06/27/windows10%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/06/27/windows10%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="windows10电脑重装系统"><a href="#windows10电脑重装系统" class="headerlink" title="windows10电脑重装系统"></a>windows10电脑重装系统</h2><p>安装系统主要有两种方法：</p><ul><li>微软官方IOS镜像文件直接写入</li><li>使用PE便携式操作系统辅助安装</li></ul><p><strong>装系统的本质就是运行提前在U盘内放好的windows安装包</strong></p><h2 id="win10官方IOS镜像直装"><a href="#win10官方IOS镜像直装" class="headerlink" title="win10官方IOS镜像直装"></a>win10官方IOS镜像直装</h2><ul><li>好处：纯净、方便、简单</li><li>缺点：功能简单僵硬</li></ul><p>相比之下，我选择微PE辅助安装！😂</p><h2 id="微PE辅助安装"><a href="#微PE辅助安装" class="headerlink" title="微PE辅助安装"></a>微PE辅助安装</h2><h3 id="1-下载微PE"><a href="#1-下载微PE" class="headerlink" title="1.下载微PE"></a>1.下载微PE</h3><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627184541.png" alt="QQ截图20220627184541"></p><h3 id="2-把PE安装进U盘内"><a href="#2-把PE安装进U盘内" class="headerlink" title="2.把PE安装进U盘内"></a>2.把PE安装进U盘内</h3><p>打开下载好的微PE安装包</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627184959.png" alt="QQ截图20220627184959"></p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627185806.png" alt="QQ截图20220627185806"></p><p>等待3-10分钟</p><h3 id="3-完成安装，PE成功安装进U盘内"><a href="#3-完成安装，PE成功安装进U盘内" class="headerlink" title="3.完成安装，PE成功安装进U盘内"></a>3.完成安装，PE成功安装进U盘内</h3><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627190210.png" alt="QQ截图20220627190210"></p><ul><li>空白分区：普通U盘</li><li>EFI分区：PE本身所在的分区，不要更改</li></ul><h3 id="4-下载win10安装包"><a href="#4-下载win10安装包" class="headerlink" title="4.下载win10安装包"></a>4.下载win10安装包</h3><ul><li>下载网站：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></li></ul><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627190955.png" alt="QQ截图20220627190955"></p><p>复制连接迅雷下载</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627191516.png" alt="QQ截图20220627191516"></p><p>下载完成之后比对哈希值，确保镜像文件完整性</p><h3 id="5-启动盘制作完成！"><a href="#5-启动盘制作完成！" class="headerlink" title="5.启动盘制作完成！"></a>5.启动盘制作完成！</h3><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627211853.png" alt="QQ截图20220627211853"></p><h3 id="6-进入主板BIOS"><a href="#6-进入主板BIOS" class="headerlink" title="6.进入主板BIOS"></a>6.进入主板BIOS</h3><p><strong>将启动盘插入待重装系统的电脑（重装系统从这一步开始，前面操作是在制作启动盘）</strong></p><p>不同品牌以及台式和笔记本电脑进入BIOS页面的方式不同，具体可百度或者查阅笔记本官网</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627200128.png" alt="QQ截图20220627200128"></p><h3 id="7-修改启动项"><a href="#7-修改启动项" class="headerlink" title="7.修改启动项"></a>7.修改启动项</h3><ol><li>将UEFI开头的U盘设为第一启动项，保存并重启</li><li>或者直接进入以UEFI开头的U盘启动项</li></ol><p><img src="https://img.yiqiangshiyia.cn/blog/20211115142040.png" alt="20211115142040"></p><p>等待启动进入winPE桌面</p><h3 id="8-进入winPE桌面"><a href="#8-进入winPE桌面" class="headerlink" title="8.进入winPE桌面"></a>8.进入winPE桌面</h3><p>由于第一启动项更改成了U盘，而U盘内有PE便携式操作系统，所以会自动进入winPE的桌面</p><p><img src="https://img.yiqiangshiyia.cn/blog/20211115142115.png" alt="20211115142115"></p><h3 id="9-磁盘分区"><a href="#9-磁盘分区" class="headerlink" title="9.磁盘分区"></a>9.磁盘分区</h3><p>不用微软自带的分区工具（麻烦且不方便使用），改用更高级的程序。打开win PE桌面的分区工具（一般叫分区精灵），分区精灵是一个磁盘管理程序，它相当于win10的安装程序自带的磁盘管理，不仅有图形化界面且功能多</p><p><strong>删除/保留磁盘</strong></p><p>如果磁盘存在分区，删除所有磁盘分区并保存更改；新磁盘则默认空闲状态</p><p><strong>转换分区表类型</strong></p><ul><li>UEFI启动对应分区类型：GUID（也就是GPT）</li><li>Legacy启动对应分区类型：MBR</li></ul><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627203514.png" alt="QQ截图20220627203514"></p><p><strong>快速分区</strong></p><p>磁盘的分区数目和大小以及磁盘名称都是可以自定义的</p><p>系统盘建议大小：50-100G</p><p><strong>需要注意的是：勾选对齐分区到此扇区的整数倍：2048扇区</strong>（固态硬盘的4K对齐，不勾选会损坏硬盘的性能以及降低固态硬盘的使用寿命）</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627203654.png" alt="QQ截图20220627203654"></p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627204112.png" alt="QQ截图20220627204112"></p><p>确定之后，稍等10s，等待分区精灵运作</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627204559.png" alt="QQ截图20220627204559"></p><p>完成分区，关闭分区精灵</p><h3 id="10-重装系统"><a href="#10-重装系统" class="headerlink" title="10.重装系统"></a>10.重装系统</h3><p>接下来打开我的电脑，找到之前放在U盘的win10安装包</p><p><img src="https://img.yiqiangshiyia.cn/blog/20211115142337.png" alt="20211115142337"></p><p>然后右键装载或者双击之后，打开setup.exe安装程序</p><p><img src="https://img.yiqiangshiyia.cn/blog/20211115142412.png" alt="20211115142412"></p><p><img src="https://img.yiqiangshiyia.cn/blog/20211115142432.png" alt="20211115142432"></p><p>后面就一直是傻瓜式安装！</p><p>到这一步之后需要注意！</p><p><img src="https://img.yiqiangshiyia.cn/blog/20211115142721.png" alt="20211115142721"></p><p>由于已经使用过分区精灵对磁盘进行了分区，所有这里就不用再使用微软自带的分区工具进行分区了</p><p>因此直接选择将系统安装到之前分好区的80G的C盘上就好了</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627205414.png" alt="QQ截图20220627205414"></p><p>点击下一步，等待win10安装程序自动走完流程</p><p><img src="https://img.yiqiangshiyia.cn/blog/20211115142856.png" alt="20211115142856"></p><p>安装完成后，10s后电脑会自动重启！拔掉U盘</p><p>之后不要动电脑，期间电脑自动重启2-3次，耐心等待就哦可了</p><h3 id="11-重装系统完成"><a href="#11-重装系统完成" class="headerlink" title="11.重装系统完成"></a>11.重装系统完成</h3><p>之后进入win10初始化主界面</p><p>完成一系列设置之后，然后win10会花费几分钟的时间完成最后的初始化操作，耐心等待几分钟，系统安装成功，大功告成！！！</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627210814.png" alt="QQ截图20220627210814"></p><h3 id="12-后序"><a href="#12-后序" class="headerlink" title="12.后序"></a>12.后序</h3><p>系统重装后可能会出现缺少驱动程序的情况，比如连接wifi的驱动，可以利用U盘安装驱动精灵软件安装驱动</p><p><strong>驱动管理可以检测电脑缺少的驱动</strong></p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220627211128.png" alt="QQ截图20220627211128"></p>]]></content>
    
    
    <categories>
      
      <category>解忧杂货</category>
      
    </categories>
    
    
    <tags>
      
      <tag>win10</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 24.两两交换链表中的节点</title>
    <link href="/2022/06/26/LC-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2022/06/26/LC-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-24-两两交换链表中的节点"><a href="#LC-24-两两交换链表中的节点" class="headerlink" title="LC 24.两两交换链表中的节点"></a>LC 24.两两交换链表中的节点</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><blockquote><p>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：迭代法</strong></p><p>具体题解就不写了，看一下画的图应该就理解了！</p><p><img src="https://img.yiqiangshiyia.cn/blog/IMG_20220626_162039.jpg" alt="IMG_20220626_162039"></p><p>当 temp = node1 时退出循环</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummyhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyhead-&gt;next = head;<br>        ListNode* temp = dummyhead;  <span class="hljs-comment">//定义链表的指针</span><br>        <span class="hljs-keyword">while</span>(temp-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; temp-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>            ListNode* node1 = temp-&gt;next;<br>            ListNode* node2 = temp-&gt;next-&gt;next;<br>            temp-&gt;next = node2;<br>            node1-&gt;next = node2-&gt;next;<br>            node2-&gt;next = node1;<br>            temp = node1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyhead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：递归法</strong></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指OfferII 091.粉刷房子</title>
    <link href="/2022/06/25/%E5%89%91%E6%8C%87OfferII-091-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"/>
    <url>/2022/06/25/%E5%89%91%E6%8C%87OfferII-091-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指OfferII-091-粉刷房子"><a href="#剑指OfferII-091-粉刷房子" class="headerlink" title="剑指OfferII 091.粉刷房子"></a>剑指OfferII 091.粉刷房子</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>很经典的一道动态规划题目！</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。</p><p>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。</p><p>请计算出粉刷完所有房子最少的花费成本。</p><p>示例 1：</p><blockquote><p>输入: costs = [[17,2,17],[16,16,5],[14,3,19]]<br>输出: 10<br>解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。<br>     最少花费: 2 + 5 + 3 = 10。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法1：动态规划"><a href="#方法1：动态规划" class="headerlink" title="方法1：动态规划"></a>方法1：动态规划</h4><p>每个房子可以被粉刷成三种颜色中的一种，需要计算在满足相邻房子的颜色不同的情况下粉刷所有房子的最小花费成本。由于当已知粉刷前 i 个房子的最小花费成本时，根据粉刷第 i + 1 号房子的花费成本可以计算粉刷前 i+1 个房子的最小花费成本，因此可以使用动态规划计算最小花费成本。</p><p>由于每个房子可以被粉刷成三种颜色中的一种，因此需要分别考虑粉刷成三种颜色时的最小花费成本。</p><p>用 dp[i][j] 表示粉刷第 0 号房子到第 i 号房子且第 i 号房子被粉刷成第 j 种颜色时的最小花费成本。由于一共有 n 个房子和 3 种颜色，因此 0≤i&lt;n，0≤j&lt;3。</p><p><strong>边界条件是：对于任意 0≤j&lt;3，dp[0][j]=costs[0][j]。</strong></p><p><strong>状态转移方程：</strong></p><p>dp[i][0] = min(dp[i-1][1],dp[i-1][2]) + costs[i][0]</p><p>dp[i][1] = min(dp[i-1][0],dp[i-1][2]) + costs[i][1]</p><p>dp[i][2] = min(dp[i-1][0],dp[i-1][1]) + costs[i][2]</p><p><strong>合并后的状态转移方程：</strong></p><p>dp[i][j] = min(dp[i-1][(j+1)%3],dp[i-1][(j+2)%3]) + costs[i][j];</p><p>dp[n−1] 中的最小值即为粉刷所有房子的最小花费成本。</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCost</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = costs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dp[n][<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">3</span>; j++)&#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][(j+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>],dp[i<span class="hljs-number">-1</span>][(j+<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>]) + costs[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]),dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高校学籍管理系统</title>
    <link href="/2022/06/14/%E9%AB%98%E6%A0%A1%E5%AD%A6%E7%B1%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/06/14/%E9%AB%98%E6%A0%A1%E5%AD%A6%E7%B1%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="高校学籍管理系统"><a href="#高校学籍管理系统" class="headerlink" title="高校学籍管理系统"></a>高校学籍管理系统</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p><strong>高校学籍管理系统</strong></p><p>功能要求：</p><ul><li>实现学生信息、班级、院系、专业等的管理；</li><li>实现课程、学生成绩信息管理；实现学生的奖惩信息管理；</li><li>创建规则用于限制性别项只能输入“男”或“女”；</li><li>创建视图查询各个学生的学号、姓名、班级、专业、院系；</li><li>创建存储过程查询指定学生的成绩单；</li><li>创建触发器当增加、删除学生和修改学生班级信息时自动修改相应班级学生人数；</li><li>建立数据库相关表之间的参照完整性约束。</li></ul><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>本数据库课程设计选题为高校学籍管理系统，课程设计的系统架构为C/S架构，数据库采用的是MySQL，选用的编程语言为Java，连接数据库的方式为JDBC。课程设计报告主要包括以下内容：需求分析、概念结构设计、逻辑结构设计、数据库物理设计与实施、数据库操作要求及实现、概念结构设计、逻辑结构设计、物理设计、数据库实施、系统设计相关代码、感想及心得体会。</p><h3 id="部分展示"><a href="#部分展示" class="headerlink" title="部分展示"></a>部分展示</h3><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-06-14%20114814.png" alt="屏幕截图 2022-06-14 114814"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%88%9D%E5%A7%8B%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.jpg" alt="初始登录界面"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E8%BF%9B%E5%85%A5%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.jpg" alt="进入学生管理系统"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E6%9F%A5%E8%AF%A2%E5%AD%A6%E7%94%9F%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF.jpg" alt="查询学生基本信息"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-06-14%20115014.png" alt="屏幕截图 2022-06-14 115014"></p><h3 id="数据库代码"><a href="#数据库代码" class="headerlink" title="数据库代码"></a>数据库代码</h3><h4 id="基本表创建"><a href="#基本表创建" class="headerlink" title="基本表创建"></a>基本表创建</h4><p>1.创建学生表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE student(<br>snoVARCHAR(20) PRIMARY KEY,<br>sname VARCHAR(20) NOT NULL,<br>sex VARCHAR(6) NOT NULL,<br>birth DATE,<br>telVARCHAR(20),<br>qq VARCHAR(20),<br>sdeptVARCHAR(20)NOT NULL,<br>classVARCHAR(20)NOT NULL,<br>addressVARCHAR(50)<br>);<br></code></pre></td></tr></table></figure><p>2.创建教师表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE teacher(<br>tno VARCHAR(20) PRIMARY KEY,<br>tname VARCHAR(20) NOT NULL,<br>classVARCHAR(20)NOT NULL,<br>cnoVARCHAR(20)NOT NULL,<br>Foreign KEY (cno) REFERENCES Course(cno)<br>);<br></code></pre></td></tr></table></figure><p>3.创建学生成绩表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE sc(<br>snoVARCHAR(20),<br>cnoVARCHAR(20),<br>gradeFLOAT,<br>point FLOAT,<br>PRIMARY KEY(sno,cno),<br>Foreign KEY (sno) REFERENCES Student(sno),<br>Foreign KEY (cno) REFERENCES Course(cno)<br>);<br></code></pre></td></tr></table></figure><p>4.创建学生奖惩表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE rp(<br>  rpno VARCHAR(20),<br>styleVARCHAR(2),<br>snoVARCHAR(20),<br>snameVARCHAR(20),<br>repunish VARCHAR(50),<br>PRIMARY KEY(sno,rpno),<br>Foreign Key(sno) REFERENCES Student(sno)<br>);<br></code></pre></td></tr></table></figure><p>5.创建课程表 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE course( <br>   cno VARCHAR(20) PRIMARY KEY,<br>   cname VARCHAR(20) NOT NULL,<br>   cpnoVARCHAR(20) ,<br>   creditFLOAT NOT NULL,<br>   tnameVARCHAR(20) NOT NULL<br>);<br></code></pre></td></tr></table></figure><p>6.创建部门、专业和班级表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE dmc(<br>department VARCHAR(20) NOT NULL,<br>sdeptVARCHAR(20)NOT NULL,<br>classVARCHAR(20) NOT NULL,<br>renshu VARCHAR(20) NOT NULL<br>);<br></code></pre></td></tr></table></figure><p>7.创建用户信息表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE user( <br>  unameVARCHAR(20) NOT NULL,<br>  upassVARCHAR(30) NOT NULL,<br>  bs INT NOT NULL<br>);<br></code></pre></td></tr></table></figure><h4 id="CHECK约束"><a href="#CHECK约束" class="headerlink" title="CHECK约束"></a>CHECK约束</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE student<br>ADD CONSTRAINT C1 CHECK(sex=&#x27;男&#x27; OR sex=&#x27;女&#x27;);<br></code></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>为学生表的学号创建索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX index_id ON student(sno)<br></code></pre></td></tr></table></figure><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>1.创建学生-班级视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW Stu_DMC<br>AS<br>SELECT sno,sname,sex,dmc.class,dmc.sdept,department<br>FROM student,dmc<br>WHERE student.class=dmc.class<br></code></pre></td></tr></table></figure><p>2.创建学生-课程-成绩视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW Stu_Cou_SC<br>AS<br>SELECT sc.sno,student.sname,sc.cno,cname,credit,grade,point,tname<br>FROM student,sc,course<br>WHERE student.sno=sc.sno AND sc.cno=course.cno<br></code></pre></td></tr></table></figure><p>3.创建教师-课程视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW Tea_Cou<br>AS<br>SELECT tno,teacher.tname,class,teacher.cno,cname<br>FROM teacher,course<br>WHERE teacher.cno=course.cno<br></code></pre></td></tr></table></figure><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>1.创建触发器当增加学生班级信息时自动修改相应班级学生人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER tri_renshu_insert<br>AFTER INSERT ON student<br>FOR EACH ROW<br>BEGIN<br>UPDATE dmc<br>SET  renshu=renshu+1<br>WHERE dmc.class=new.class;<br>END;<br></code></pre></td></tr></table></figure><p>2.创建触发器当删除学生班级信息时自动修改相应班级学生人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER tri_renshu_delete<br>AFTER DELETE ON student<br>FOR EACH ROW<br>BEGIN<br>UPDATE dmc<br>SET  renshu=renshu-1<br>WHERE dmc.class=old.class;<br>END;<br></code></pre></td></tr></table></figure><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>创建存储过程查询指定学生的成绩单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE show_grade(sno VARCHAR(20))<br>BEGIN<br>SELECT grade<br>FROM sc<br>WHERE sc.sno=sno;<br>END<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库课程设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 450.删除二叉搜索树中的节点</title>
    <link href="/2022/06/07/LC%20450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2022/06/07/LC%20450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-450-删除二叉搜索树中的节点"><a href="#LC-450-删除二叉搜索树中的节点" class="headerlink" title="LC 450.删除二叉搜索树中的节点"></a>LC 450.删除二叉搜索树中的节点</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>二叉搜索树有以下性质：</p><ul><li>左子树的所有节点（如果有）的值均小于当前节点的值</li><li>右子树的所有节点（如果有）的值均大于当前节点的值</li><li>左子树和右子树均为二叉搜索树</li><li>二叉搜索树的中序遍历有序</li></ul><p>二叉搜索树的题目往往可以用递归来解决，本题 LC难度：中等，核心思想：分类讨论删除不同位置处的节点如何保持二叉树的性质</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><img src="https://img.yiqiangshiyia.cn/blog/del_node_1.jpg" alt="del_node_1"></p><blockquote><p>输入：root = [5,3,6,2,4,null,7], key = 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>核心思想：分类讨论删除不同位置处的节点如何保持二叉树的性质，思路很简单，两张图就能明白了</p><p>删除节点后，若删除节点的左右子树均不为空，则要保持二叉搜索树的性质有两种答案</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220607205952.png" alt="方式1"></p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220607202437.png" alt="方式2"></p><p><strong>方法1：递归</strong></p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)  <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; key)&#123;<br>            root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left,key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; key)&#123;<br>            root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right,key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val == key)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span> root-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)&#123;<br>                TreeNode* node = root-&gt;right;<br>                <span class="hljs-keyword">while</span>(node-&gt;left)&#123;<br>                    node = node-&gt;left;<br>                &#125;<br>                root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right,node-&gt;val);<br>                node-&gt;left = root-&gt;left;<br>                node-&gt;right = root-&gt;right;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：迭代</strong></p><blockquote><p>迭代法我没看懂在干什么😅</p></blockquote><p>官解思路：方法一的递归深度最多为 n，而大部分是由寻找值为 key 的节点贡献的，而寻找节点这一部分可以用迭代来优化。寻找并删除 successor 时，也可以用一个变量保存它的父节点，从而可以节省一步递归操作。</p><p>官解AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        TreeNode *cur = root, *curParent = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (cur &amp;&amp; cur-&gt;val != key) &#123;<br>            curParent = cur;<br>            <span class="hljs-keyword">if</span> (cur-&gt;val &gt; key) &#123;<br>                cur = cur-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!cur) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;<br>            cur = <span class="hljs-literal">nullptr</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!cur-&gt;right) &#123;<br>            cur = cur-&gt;left;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!cur-&gt;left) &#123;<br>            cur = cur-&gt;right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            TreeNode *successor = cur-&gt;right, *successorParent = cur;<br>            <span class="hljs-keyword">while</span> (successor-&gt;left) &#123;<br>                successorParent = successor;<br>                successor = successor-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (successorParent-&gt;val == cur-&gt;val) &#123;<br>                successorParent-&gt;right = successor-&gt;right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                successorParent-&gt;left = successor-&gt;right;<br>            &#125;<br>            successor-&gt;right = cur-&gt;right;<br>            successor-&gt;left = cur-&gt;left;<br>            cur = successor;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!curParent) &#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (curParent-&gt;left &amp;&amp; curParent-&gt;left-&gt;val == key) &#123;<br>                curParent-&gt;left = cur;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curParent-&gt;right = cur;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM-MyBatis</title>
    <link href="/2022/06/06/SSM-MyBatis/"/>
    <url>/2022/06/06/SSM-MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="SSM-MyBatis"><a href="#SSM-MyBatis" class="headerlink" title="SSM-MyBatis"></a>SSM-MyBatis</h1><p>环境说明：</p><ul><li><p>jdk 8 +</p></li><li><p>MySQL 5.7.</p></li><li><p>maven-3.6.</p></li><li><p>IDEA</p></li></ul><p>学习前需要掌握：</p><ul><li><p>JDBC</p></li><li><p>MySQL</p></li><li><p>Java 基础</p></li><li><p>Maven</p></li><li><p>Junit</p></li></ul><h2 id="1-、Mybatis简介"><a href="#1-、Mybatis简介" class="headerlink" title="1 、Mybatis简介"></a>1 、Mybatis简介</h2><p><img src="https://mybatis.org/images/mybatis-logo.png" alt="MyBatis logo"></p><h3 id="1-1、什么是MyBatis"><a href="#1-1、什么是MyBatis" class="headerlink" title="1.1、什么是MyBatis"></a>1.1、什么是MyBatis</h3><ul><li><p>MyBatis 是一款优秀的<strong>持久层框架</strong></p></li><li><p>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程</p></li><li><p>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。</p></li><li><p>MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。</p></li><li><p>2013 年 11 月迁移到 <strong>Github</strong>.</p></li><li><p>Mybatis官方文档 : <a href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></p></li><li><p>GitHub : <a href="https://github.com/mybatis/mybatis-">https://github.com/mybatis/mybatis-</a></p></li></ul><h3 id="1-2、持久化"><a href="#1-2、持久化" class="headerlink" title="1.2、持久化"></a>1.2、持久化</h3><ul><li><p><strong>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</strong></p><ul><li><p>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</p></li><li><p>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</p></li><li><p>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。</p></li></ul></li><li><h5 id="为什么需要持久化服务呢？那是由于内存本身的缺陷引起的"><a href="#为什么需要持久化服务呢？那是由于内存本身的缺陷引起的" class="headerlink" title="为什么需要持久化服务呢？那是由于内存本身的缺陷引起的"></a>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</h5><ul><li><p>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。</p></li><li><p>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</p></li></ul></li></ul><h3 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h3><ul><li><p>什么是持久层？</p><ul><li><p>完成持久化工作的代码块. —-&gt; dao层 【DAO (Data Access Object) 数据访问对象】</p></li><li><p>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</p></li><li><p>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专著于数据持久化逻辑的实现.</p></li><li><p>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。 【说白了就是用来操作数据库存在的！】</p></li></ul></li></ul><h3 id="1-4、为什么需要Mybatis"><a href="#1-4、为什么需要Mybatis" class="headerlink" title="1.4、为什么需要Mybatis"></a>1.4、为什么需要Mybatis</h3><ul><li><p>Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据.</p></li><li><p>传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率.</p></li><li><p>MyBatis 是一个半自动化的 <strong>ORM框架 (Object Relationship Mapping) –&gt;对象关系映射</strong></p></li><li><p>所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！ 技术没有高低之分，只有使用这个技术的人有高低之别</p></li><li><p>MyBatis的优点</p><ul><li><p>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</p></li><li><p>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</p></li><li><p>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</p></li><li><p>提供xml标签，支持编写动态sql。</p></li><li><p>…….</p></li><li><p>最重要的一点，使用的人多！公司需要！</p></li></ul></li></ul><h2 id="2-、第一个MyBatis程序"><a href="#2-、第一个MyBatis程序" class="headerlink" title="2 、第一个MyBatis程序"></a>2 、第一个MyBatis程序</h2><p>思路流程：搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220609172441.png" alt="QQ截图20220609172441"></p><p>测试结果</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220609172503.png" alt="QQ截图20220609172503"></p><h3 id="2-1、代码演示"><a href="#2-1、代码演示" class="headerlink" title="2.1、代码演示"></a>2.1、代码演示</h3><ol><li><p><strong>搭建实验数据库</strong></p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220609172323.png" alt="QQ截图20220609172323"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE `mybatis`;<br><br>CREATE TABLE `user` (<br>`id` int(20) PRIMARY KEY,<br>`name` varchar(20) NOT NULL,<br>`pwd` varchar(20) NOT NULL<br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>导入MyBatis相关 jar 包（pom.xml）</strong></p><ul><li>GitHub上找</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--父工程--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--子模块--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>mybatis-01<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--导入依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--mysql驱动--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--mybatis--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--junit--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--在build中配置resources,来防止我们资源导出失败的问题--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>编写MyBatis核心配置文件（mybatis-config.xml）</strong></p><ul><li>查看帮助文档</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--configuration核心配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>  <span class="hljs-comment">&lt;!--事物管理--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--每一个Mappper.xml都需要在mybatis核心配置文件中注册--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;ssm/study/dao/userMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>编写MyBatis工具类（MybatisUtils.java）</strong></p><ul><li>查看帮助文档</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> ssm.study.utils;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取SqlSessionFactory对象</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取SqlSession连接</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        既然有了SqlSessionFactory，我们就可以从中获取SqlSession实例了</span><br><span class="hljs-comment">        SqlSession完全包含了面向数据库执行sql所需要的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>创建实体类（User.java）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ssm.study.pojo;<br><br><span class="hljs-comment">//实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id; <span class="hljs-comment">//id</span><br>    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">private</span> String pwd; <span class="hljs-comment">//密码</span><br><br>    <span class="hljs-comment">//构造,有参,无参</span><br>    <span class="hljs-comment">//set/get</span><br>    <span class="hljs-comment">//toString()</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, String pwd)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.pwd = pwd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPwd</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> pwd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPwd</span><span class="hljs-params">(String pwd)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pwd = pwd;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>编写Mapper接口类（UserMapper.java）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ssm.study.dao;<br><br><span class="hljs-keyword">import</span> ssm.study.pojo.User;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    List&lt;User&gt; <span class="hljs-title function_">selectUser</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>编写Mapper.xml配置文件（UserMapper.xml）</strong></p><ul><li>namespace 十分重要，不能写错！</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--namespace绑定一个对应的Mapper/Dao接口--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;ssm.study.dao.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;ssm.study.pojo.User&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--sql语句--&gt;</span><br>        select * from user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>编写测试类（UserMapperTest.java）</strong></p><ul><li>Junit 包测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ssm.study.dao;<br><br><span class="hljs-keyword">import</span> ssm.study.pojo.User;<br><span class="hljs-keyword">import</span> ssm.study.utils.MybatisUtils;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//第一步 ：获得sqlSession对象</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><br>        <span class="hljs-comment">//方式一：getMappper</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>        List&lt;User&gt; userList = mapper.selectUser();<br><br>        <span class="hljs-keyword">for</span> (User user: userList)&#123;<br>            System.out.println(user);<br>        &#125;<br><br>        <span class="hljs-comment">//关闭SqlSession</span><br>        session.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>运行测试</strong></p></li></ol><h3 id="2-2、问题说明"><a href="#2-2、问题说明" class="headerlink" title="2.2、问题说明"></a>2.2、问题说明</h3><p><strong>可能出现问题说明：Maven静态资源过滤问题</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>遇到的问题</strong></p><ul><li>都是一些小问题，百度都可以解决</li></ul><h2 id="3-、CRUD操作"><a href="#3-、CRUD操作" class="headerlink" title="3 、CRUD操作"></a>3 、CRUD操作</h2><h3 id="3-1、namespace"><a href="#3-1、namespace" class="headerlink" title="3.1、namespace"></a>3.1、namespace</h3><ol><li><p>将上面案例中的UserMapper接口改名为 UserDao；</p></li><li><p>将UserMapper.xml中的namespace改为为UserDao的路径.</p></li><li><p>再次测试</p></li></ol><h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><p>配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名,必须一致！</p><h3 id="3-2、select"><a href="#3-2、select" class="headerlink" title="3.2、select"></a>3.2、select</h3><ul><li><p>select标签是mybatis中最常用的标签之一</p></li><li><p>select语句有很多属性可以详细配置每一条SQL语句</p><ul><li><p>id</p><ul><li><p>命名空间中唯一的标识符</p></li><li><p>接口中的方法名与映射文件中的SQL语句ID 一一对应</p></li></ul></li><li><p>parameterType</p><ul><li>传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】</li></ul></li><li><p>resultType</p><ul><li>SQL语句返回值类型。【完整的类名或者别名】</li></ul></li></ul></li></ul><h5 id="需求：根据id查询用户"><a href="#需求：根据id查询用户" class="headerlink" title="需求：根据id查询用户"></a>需求：根据id查询用户</h5><ol><li><p>在UserMapper中添加对应方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><span class="hljs-comment">//查询全部用户</span><br>List&lt;User&gt; <span class="hljs-title function_">selectUser</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//根据id查询用户</span><br>User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在UserMapper.xml中添加Select语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span><br>select * from user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试类中测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tsetSelectUserById</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();  <span class="hljs-comment">//获取SqlSession连接</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectUserById( <span class="hljs-number">1</span> );<br>System.out.println(user);<br>session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="课堂练习-：根据-密码-和-名字-查询用户"><a href="#课堂练习-：根据-密码-和-名字-查询用户" class="headerlink" title="课堂练习 ：根据 密码 和 名字 查询用户"></a>课堂练习 ：根据 密码 和 名字 查询用户</h5><p>思路一：直接在方法中传递参数</p><ol><li><p>在接口方法的参数前加 @Param属性</p></li><li><p>Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过密码和名字查询用户</span><br>User <span class="hljs-title function_">selectUserByNP</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username,<span class="hljs-meta">@Param(&quot;pwd&quot;)</span> String pwd)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="hljs-comment">select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;</span><br><span class="hljs-comment">&lt;/select&gt;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>思路二：使用万能的Map</p><ol><li><p>在接口方法中，参数直接传递Map；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> User <span class="hljs-title function_">selectUserByNP2</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写sql语句的时候，需要传递参数类型，参数类型为map</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByNP2&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span><br>select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>map.put(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;小明&quot;</span>);<br>map.put(<span class="hljs-string">&quot;pwd&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectUserByNP2(map);<br></code></pre></td></tr></table></figure></li></ol><p>总结：</p><p>如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可</p><h3 id="3-3、insert"><a href="#3-3、insert" class="headerlink" title="3.3、insert"></a>3.3、insert</h3><p>我们一般使用insert标签进行插入操作，它的配置和select标签差不多！</p><p><strong>需求：给数据库增加一个用户</strong></p><ol><li><p>在UserMapper接口中添加对应的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加一个用户</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;<br></code></pre></td></tr></table></figure></li><li><p>在UserMapper.xml中添加insert语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span><br>insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddUser</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>( <span class="hljs-number">5</span> ,<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-string">&quot;zxcvbn&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> mapper.addUser(user);<br>System.out.println(i);<br>session.commit(); <span class="hljs-comment">//提交事务,重点!不写的话不会提交到数据库</span><br>session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>注意点：增、删、改操作需要提交事务！</strong></p><h3 id="3-4、update"><a href="#3-4、update" class="headerlink" title="3.4、update"></a>3.4、update</h3><p>我们一般使用update标签进行更新操作，它的配置和select标签差不多！</p><h5 id="需求：修改用户的信息"><a href="#需求：修改用户的信息" class="headerlink" title="需求：修改用户的信息"></a>需求：修改用户的信息</h5><ol><li><p>同理，编写接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改一个用户</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(User user)</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写对应的配置文件SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span><br>update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateUser</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectUserById( <span class="hljs-number">1</span> );<br>user.setPwd(<span class="hljs-string">&quot;asdfgh&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> mapper.updateUser(user);<br>System.out.println(i);<br>session.commit(); <span class="hljs-comment">//提交事务,重点!不写的话不会提交到数据库</span><br>session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-5、delete"><a href="#3-5、delete" class="headerlink" title="3.5、delete"></a>3.5、delete</h3><p>我们一般使用delete标签进行删除操作，它的配置和select标签差不多！</p><h5 id="需求：根据id删除一个用户"><a href="#需求：根据id删除一个用户" class="headerlink" title="需求：根据id删除一个用户"></a>需求：根据id删除一个用户</h5><ol><li><p>同理，编写接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据id删除用户</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写对应的配置文件SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>delete from user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteUser</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> mapper.deleteUser( <span class="hljs-number">5</span> );<br>System.out.println(i);<br>session.commit(); <span class="hljs-comment">//提交事务,重点!不写的话不会提交到数据库</span><br>session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><ul><li><p>所有的增删改操作都需要提交事务！</p></li><li><p>接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！</p></li><li><p>有时候根据业务的需求，可以考虑使用map传递参数！</p></li><li><p>为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！</p></li></ul><h3 id="3-6、思考题"><a href="#3-6、思考题" class="headerlink" title="3.6、思考题"></a>3.6、思考题</h3><h5 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写?"></a>模糊查询like语句该怎么写?</h5><p>第 1 种：在Java代码中添加sql通配符。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">string wildcardname = “%smi%”;<br>list<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);<br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”selectlike”</span>&gt;</span><br>select * from foo where bar like #&#123;value&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第 2 种：在sql语句中拼接通配符，会引起sql注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">string wildcardname = “smi”;<br>list<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);<br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”selectlike”</span>&gt;</span><br>select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-、配置解析"><a href="#4-、配置解析" class="headerlink" title="4 、配置解析"></a>4 、配置解析</h2><h3 id="4-1、核心配置文件"><a href="#4-1、核心配置文件" class="headerlink" title="4.1、核心配置文件"></a>4.1、核心配置文件</h3><ul><li><p>mybatis-config.xml 系统核心配置文件</p></li><li><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</p></li><li><p>能配置的内容如下：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">configuration（配置）<br>properties（属性）<br>settings（设置）<br>typeAliases（类型别名）<br>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins（插件）<br>environments（环境配置）<br>environment（环境变量）<br>transactionManager（事务管理器）<br>dataSource（数据源）<br>databaseIdProvider（数据库厂商标识）<br>mappers（映射器）<br><span class="hljs-comment">&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以阅读 mybatis-config.xml 上面的dtd的头文件！【演示】</p><h3 id="4-2、environments元素"><a href="#4-2、environments元素" class="headerlink" title="4.2、environments元素"></a>4.2、environments元素</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）</p></li><li><p>子元素节点： environment</p><ul><li><p>具体的一套环境，通过设置id进行区别，id保证唯一！</p></li><li><p>子元素节点：transactionManager - [ 事务管理器 ]</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;[ JDBC | MANAGED ]&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>详情：[点击查看官方文档](<a href="https://mybatis.org/mybatis-3/zh/configuration.html#environments">mybatis – MyBatis 3 | 配置</a>)</p></li><li><p>这两种事务管理器类型都不需要设置任何属性。</p></li></ul></li><li><p>子元素节点： <strong>数据源（dataSource）</strong></p><ul><li><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p></li><li><p>数据源是必须配置的。</p></li><li><p>有三种内建的数据源类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">type=<span class="hljs-string">&quot;[UNPOOLED|POOLED|JNDI]&quot;</span>）<br></code></pre></td></tr></table></figure></li><li><p>unpooled： 这个数据源的实现只是每次被请求时打开和关闭连接。</p></li><li><p><strong>pooled</strong> ： 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p></li><li><p>jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p></li><li><p>数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等….</p></li></ul></li></ul></li></ul><h3 id="4-3、mappers元素"><a href="#4-3、mappers元素" class="headerlink" title="4.3、mappers元素"></a>4.3、mappers元素</h3><h4 id="4-3-1、mappers"><a href="#4-3-1、mappers" class="headerlink" title="4.3.1、mappers"></a>4.3.1、mappers</h4><ul><li><p>映射器 : 定义映射SQL语句文件</p></li><li><p>既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。</p></li></ul><h4 id="4-3-2、引入资源方式"><a href="#4-3-2、引入资源方式" class="headerlink" title="4.3.2、引入资源方式"></a>4.3.2、引入资源方式</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">使用映射器接口实现类的完全限定类名</span><br><span class="hljs-comment">需要配置文件名称和接口名称一致，并且位于同一目录下</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">将包内的映射器接口实现全部注册为映射器</span><br><span class="hljs-comment">但是需要配置文件名称和接口名称一致，并且位于同一目录下</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis.builder&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-3-3、Mapper文件"><a href="#4-3-3、Mapper文件" class="headerlink" title="4.3.3、Mapper文件"></a>4.3.3、Mapper文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta"><span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kuang.mapper.UserMapper&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>namespace中文意思：命名空间，作用如下：</p><ol><li><p>namespace和子元素的id联合保证唯一 , 区别不同的mapper</p></li><li><p>绑定DAO接口</p><ul><li><p>namespace的命名必须跟某个接口同名</p></li><li><p>接口中的方法与映射文件中sql语句id应该一一对应</p></li></ul></li><li><p>namespace命名规则 : 包名+类名</p></li></ol></li></ul><p>MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。</p><h3 id="4-4、Properties优化"><a href="#4-4、Properties优化" class="headerlink" title="4.4、Properties优化"></a>4.4、Properties优化</h3><p>数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过properties 元素的子元素来传递。具体的[官方文档](<a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">mybatis – MyBatis 3 | 配置</a>)</p><p>我们来优化我们的配置文件</p><p>第一步 ; 在资源目录下新建一个db.properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">driver=com.mysql.jdbc.Driver<br>url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/mybatis?</span><br>useSSL=<span class="hljs-literal">true</span>&amp;useUnicode=<span class="hljs-literal">true</span>&amp;characterEncoding=utf<br>username=root<br>password= <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>第二步 : 将文件导入properties 配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!--导入properties文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>/&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更多操作，可以查看官方文档！【演示带领学习】</p><ul><li><p>配置文件优先级问题</p></li><li><p>新特性：使用占位符</p></li></ul><h3 id="4-5、typeAliases优化"><a href="#4-5、typeAliases优化" class="headerlink" title="4.5、typeAliases优化"></a>4.5、typeAliases优化</h3><p>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置别名,注意顺序--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.kuang.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当这样配置时， User 可以用在任何使用 com.kuang.pojo.User 的地方。</p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kuang.pojo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>每一个在包 com.kuang.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</p><p>若有注解，则别名为其注解值。见下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Alias(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>【演示】去官网查看一下Mybatis默认的一些类型别名！</p><h3 id="4-6、其他配置浏览"><a href="#4-6、其他配置浏览" class="headerlink" title="4.6、其他配置浏览"></a>4.6、其他配置浏览</h3><h4 id="4-6-1、设置"><a href="#4-6-1、设置" class="headerlink" title="4.6.1、设置"></a>4.6.1、设置</h4><ul><li><p>[设置（settings）](<a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">mybatis – MyBatis 3 | 配置</a>) 相关 =&gt; 查看帮助文档</p><ul><li><p>懒加载</p></li><li><p>日志实现</p></li><li><p>缓存开启关闭</p></li></ul></li><li><p>一个配置完整的 settings 元素的示例如下：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;multipleResultSetsEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useColumnLabel&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PARTIAL&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;WARNING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultExecutorType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SIMPLE&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultStatementTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;25&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultFetchSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;safeRowBoundsEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localCacheScope&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SESSION&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcTypeForNull&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;OTHER&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-6-2、类型处理器"><a href="#4-6-2、类型处理器" class="headerlink" title="4.6.2、类型处理器"></a>4.6.2、类型处理器</h4><p>[官方文档](<a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">mybatis – MyBatis 3 | 配置</a>)</p><ul><li><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</p></li><li><p>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】</p></li></ul><h4 id="4-6-3、对象工厂"><a href="#4-6-3、对象工厂" class="headerlink" title="4.6.3、对象工厂"></a>4.6.3、对象工厂</h4><p>[官方文档](<a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">mybatis – MyBatis 3 | 配置</a>)</p><ul><li><p>MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。</p></li><li><p>默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。</p></li><li><p>如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】</p></li></ul><h3 id="4-7-生命周期和作用域"><a href="#4-7-生命周期和作用域" class="headerlink" title="4.7 生命周期和作用域"></a>4.7 生命周期和作用域</h3><h5 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h5><p>理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。</p><p>我们可以先画一个流程图，分析一下Mybatis的执行过程！</p><p><img src="https://img.yiqiangshiyia.cn/blog/image-20220606201346911.png" alt="image-20220606201346911"></p><h5 id="作用域理解"><a href="#作用域理解" class="headerlink" title="作用域理解"></a>作用域理解</h5><ul><li><p>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 <strong>SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域</strong> （也就是局部方法变量）。</p></li><li><p>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。</p></li><li><p>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</p></li><li><p>因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 <strong>SqlSessionFactory 的最佳作用域是应用作用域</strong>。</p></li><li><p>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。</p></li><li><h5 id="所以-SqlSession-的最佳的作用域是请求或方法作用域。"><a href="#所以-SqlSession-的最佳的作用域是请求或方法作用域。" class="headerlink" title="所以 SqlSession 的最佳的作用域是请求或方法作用域。"></a>所以 SqlSession 的最佳的作用域是请求或方法作用域。</h5></li></ul><p><img src="https://img.yiqiangshiyia.cn/blog/image-20220606201920246.png" alt="image-20220606201920246"></p><h2 id="5-、ResultMap"><a href="#5-、ResultMap" class="headerlink" title="5 、ResultMap"></a>5 、ResultMap</h2><p><strong>要解决的问题：属性名和字段名不一致</strong></p><p>环境：新建一个项目，将之前的项目拷贝过来</p><h3 id="5-1、查询为null问题"><a href="#5-1、查询为null问题" class="headerlink" title="5.1、查询为null问题"></a>5.1、查询为null问题</h3><ol><li><p>查看之前的数据库的字段名</p><p><img src="https://img.yiqiangshiyia.cn/blog/image-20220606202022616.png" alt="image-20220606202022616"></p></li><li><p>Java中的实体类设计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <span class="hljs-comment">//id</span><br><span class="hljs-keyword">private</span> String name; <span class="hljs-comment">//姓名</span><br><span class="hljs-keyword">private</span> String password; <span class="hljs-comment">//密码和数据库不一样！</span><br>    <br>    <span class="hljs-comment">//构造</span><br><span class="hljs-comment">//set/get</span><br><span class="hljs-comment">//toString()</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据id查询用户</span><br>User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>mapper映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select * from user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectUserById</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();  <span class="hljs-comment">//获取SqlSession连接</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectUserById( <span class="hljs-number">1</span> );<br>System.out.println(user);<br>session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h5><ul><li><p>User{id=1, name=’狂神’, password=’null’}</p></li><li><p>查询出来发现 password 为空. 说明出现了问题！</p></li></ul><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><ul><li><p>select * from user where id = #{id} 可以看做 select id,name,pwd from user where id = #{id}</p></li><li><p>mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】</p></li></ul><h3 id="5-2、解决方案"><a href="#5-2、解决方案" class="headerlink" title="5.2、解决方案"></a>5.2、解决方案</h3><p>方案一：为列名指定别名 , 别名和java实体类的属性名一致.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>select id , name , pwd as password from user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>方案二：使用结果集映射-&gt;ResultMap 【推荐】</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- id为主键 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span><br>select id , name , pwd from user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-3、ResultMap"><a href="#5-3、ResultMap" class="headerlink" title="5.3、ResultMap"></a>5.3、ResultMap</h3><h4 id="5-3-1、自动映射"><a href="#5-3-1、自动映射" class="headerlink" title="5.3.1、自动映射"></a>5.3.1、自动映射</h4><ul><li><p>resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来。</p></li><li><p>实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的长达数千行的代码。</p></li><li><p>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。</p></li></ul><p>你已经见过简单映射语句的示例了，但并没有显式指定 resultMap 。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>select id , name , pwd<br>from user<br>where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。</p><p>ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。</p><h4 id="5-3-2、手动映射"><a href="#5-3-2、手动映射" class="headerlink" title="5.3.2、手动映射"></a>5.3.2、手动映射</h4><ol><li><p>返回值类型为resultMap</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span><br>select id , name , pwd from user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写resultMap，实现手动映射！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- id为主键 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>如果世界总是这么简单就好了。但是肯定不是的，数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些，我们将在之后讲解，今天你们需要把这些知识都消化掉才是最重要的！理解结果集映射的这个概念！</p><h2 id="6-、分页的实现"><a href="#6-、分页的实现" class="headerlink" title="6 、分页的实现"></a>6 、分页的实现</h2><h3 id="6-1、日志工厂"><a href="#6-1、日志工厂" class="headerlink" title="6.1、日志工厂"></a>6.1、日志工厂</h3><p>思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？</p><p>如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。</p><p>对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。</p><p>Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：</p><ul><li><p>SLF4J</p></li><li><p>Apache Commons Logging</p></li><li><p>Log4j 2</p></li><li><p>Log4j</p></li><li><p>JDK logging</p></li></ul><p>具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。 如果一个都未找到，日志功能就会被禁用。</p><h5 id="标准日志实现"><a href="#标准日志实现" class="headerlink" title="标准日志实现"></a>标准日志实现</h5><p>指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug</p><h3 id="6-2、Log4j"><a href="#6-2、Log4j" class="headerlink" title="6.2、Log4j"></a>6.2、Log4j</h3><h5 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h5><ul><li><p>Log4j是Apache的一个开源项目</p></li><li><p>通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件….</p></li><li><p>我们也可以控制每一条日志的输出格式；</p></li><li><p>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p></li></ul><h5 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h5><ol><li><p>导入log4j的包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件编写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下<br>面的代码<br>log4j.rootLogger=DEBUG,console,file<br><br>#控制台输出的相关设置<br>log4j.appender.console = org.apache.log4j.ConsoleAppender<br>log4j.appender.console.Target = System.out<br>log4j.appender.console.Threshold=DEBUG<br>log4j.appender.console.layout = org.apache.log4j.PatternLayout<br>log4j.appender.console.layout.ConversionPattern=[%c]-%m%n<br><br>#文件输出的相关设置<br>log4j.appender.file = org.apache.log4j.RollingFileAppender<br>log4j.appender.file.File=./log/kuang.log<br>log4j.appender.file.MaxFileSize=10mb<br>log4j.appender.file.Threshold=DEBUG<br>log4j.appender.file.layout=org.apache.log4j.PatternLayout<br>log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n<br><br>#日志输出级别<br>log4j.logger.org.mybatis=DEBUG<br>log4j.logger.java.sql=DEBUG<br>log4j.logger.java.sql.Statement=DEBUG<br>log4j.logger.java.sql.ResultSet=DEBUG<br>log4j.logger.java.sql.PreparedStatement=DEBUG<br></code></pre></td></tr></table></figure></li><li><p>setting设置日志实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在程序中使用Log4j进行输出！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意导包：org.apache.log4j.Logger</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(MyTest.class);<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectUser</span><span class="hljs-params">()</span> &#123;<br>logger.info(<span class="hljs-string">&quot;info：进入selectUser方法&quot;</span>);<br>logger.debug(<span class="hljs-string">&quot;debug：进入selectUser方法&quot;</span>);<br>logger.error(<span class="hljs-string">&quot;error: 进入selectUser方法&quot;</span>);<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>List&lt;User&gt; users = mapper.selectUser();<br><span class="hljs-keyword">for</span> (User user: users)&#123;<br>System.out.println(user);<br>&#125;<br>session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试，看控制台输出！</p><ul><li><p>使用Log4j 输出日志</p></li><li><p>可以看到还生成了一个日志的文件 【需要修改file的日志级别】</p></li></ul></li></ol><h3 id="6-3、limit实现分页"><a href="#6-3、limit实现分页" class="headerlink" title="6.3、limit实现分页"></a>6.3、limit实现分页</h3><p><strong>思考：为什么需要分页？</strong></p><p>在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。</p><p><strong>使用Limit实现分页</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#语法<br>SELECT * FROM table LIMIT stratIndex，pageSize<br><br>SELECT * FROM table LIMIT 5 , 10 ; // 检索记录行 6 - 15<br><br>#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 - 1 ：<br>SELECT * FROM table LIMIT 95 ,- 1 ; // 检索记录行 96 -last.<br><br>#如果只给定一个参数，它表示返回最大的记录行数目：<br>SELECT * FROM table LIMIT 5 ; //检索前 5 个记录行<br><br>#换句话说，LIMIT n 等价于 LIMIT 0 ,n。<br></code></pre></td></tr></table></figure><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><ol><li><p>修改Mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Mapper接口，参数为map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//选择全部用户实现分页</span><br>List&lt;User&gt; <span class="hljs-title function_">selectUser</span><span class="hljs-params">(Map&lt;String,Integer&gt; map)</span>;<br></code></pre></td></tr></table></figure></li><li><p>在测试类中传入参数测试</p><ul><li>推断：起始位置 = （当前页面 - 1 ） * 页面大小</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分页查询 , 两个参数startIndex , pageSize</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectUser</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>    <br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">currentPage</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ;  <span class="hljs-comment">//第几页</span><br><span class="hljs-type">int</span> <span class="hljs-variable">pageSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ;  <span class="hljs-comment">//每页显示几个</span><br>Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,Integer&gt;();<br>map.put(<span class="hljs-string">&quot;startIndex&quot;</span>,(currentPage- <span class="hljs-number">1</span> )*pageSize);<br>map.put(<span class="hljs-string">&quot;pageSize&quot;</span>,pageSize);<br>    <br>    List&lt;User&gt; users = mapper.selectUser(map);<br>    <br>    <span class="hljs-keyword">for</span> (User user: users)&#123;<br>System.out.println(user);<br>&#125;<br>    <br>   session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="6-4、RowBounds分页"><a href="#6-4、RowBounds分页" class="headerlink" title="6.4、RowBounds分页"></a>6.4、RowBounds分页</h3><p>我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！</p><h5 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h5><ol><li><p>mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//选择全部用户RowBounds实现分页</span><br>List&lt;User&gt; <span class="hljs-title function_">getUserByRowBounds</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li><li><p>mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByRowBounds&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select * from user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试类</p><p>在这里，我们需要使用RowBounds类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUserByRowBounds</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">currentPage</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ;  <span class="hljs-comment">//第几页</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ;  <span class="hljs-comment">//每页显示几个</span><br>    <span class="hljs-type">RowBounds</span> <span class="hljs-variable">rowBounds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RowBounds</span>((currentPage-<span class="hljs-number">1</span> )*pageSize,pageSize);<br><br>    <span class="hljs-comment">//通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]</span><br>    List&lt;User&gt; users session.selectList(<span class="hljs-string">&quot;com.kuang.mapper.UserMapper.getUserByRowBounds&quot;</span>,<br><span class="hljs-literal">null</span>, rowBounds);<br><br>    <span class="hljs-keyword">for</span> (User user: users)&#123;<br>        System.out.println(user);<br>    &#125;<br><br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="6-5、PageHelper"><a href="#6-5、PageHelper" class="headerlink" title="6.5、PageHelper"></a>6.5、PageHelper</h3><p><img src="https://img.yiqiangshiyia.cn/blog/image-20220606204945977.png" alt="image-20220606204945977"></p><p>了解即可，可以自己尝试使用</p><p>官方文档：<a href="https://pagehelper.github.io/">https://pagehelper.github.io/</a></p><h2 id="7-、使用注解开发"><a href="#7-、使用注解开发" class="headerlink" title="7 、使用注解开发"></a>7 、使用注解开发</h2><h3 id="7-1、面向接口编程"><a href="#7-1、面向接口编程" class="headerlink" title="7.1、面向接口编程"></a>7.1、面向接口编程</h3><ul><li><p>大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程</p></li><li><p><strong>根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准, 使得开发变得容易 , 规范性更好</strong></p></li><li><p>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了</p></li><li><p>而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</p></li></ul><h5 id="关于接口的理解"><a href="#关于接口的理解" class="headerlink" title="关于接口的理解"></a>关于接口的理解</h5><ul><li><p>接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。</p></li><li><p>接口的本身反映了系统设计人员对系统的抽象理解。</p></li><li><p>接口应有两类：</p><ul><li><p>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)</p></li><li><p>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）</p></li></ul></li><li><p>一个体有可能有多个抽象面。抽象体与抽象面是有区别的。</p></li></ul><h5 id="三个面向区别"><a href="#三个面向区别" class="headerlink" title="三个面向区别"></a>三个面向区别</h5><ul><li><p>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法.</p></li><li><p>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现.</p></li><li><p>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构</p></li></ul><h3 id="7-2、利用注解开发"><a href="#7-2、利用注解开发" class="headerlink" title="7.2、利用注解开发"></a>7.2、利用注解开发</h3><ul><li><p><strong>mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建</strong></p></li><li><p>sql 类型主要分成 :</p><ul><li><p>@select ()</p></li><li><p>@update ()</p></li><li><p>@Insert ()</p></li><li><p>@delete ()</p></li></ul></li></ul><p>【注意】利用注解开发就不需要mapper.xml映射文件了.</p><ol><li><p>我们在我们的接口中添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询全部用户</span><br><span class="hljs-meta">@Select(&quot;select id,name,pwd password from user&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getAllUser</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li><li><p>在mybatis的核心配置文件中注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--使用class绑定接口--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.mapper.UserMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>我们去进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetAllUser</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-comment">//本质上利用了jvm的动态代理机制</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>    <br>    List&lt;User&gt; users = mapper.getAllUser();<br><span class="hljs-keyword">for</span> (User user : users)&#123;<br>System.out.println(user);<br>&#125;<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用Debug查看本质</p></li></ol><p><img src="https://img.yiqiangshiyia.cn/blog/image-20220606205608273.png" alt="image-20220606205608273"></p><ol start="5"><li><p>本质上利用了jvm的动态代理机制</p><p><img src="https://img.yiqiangshiyia.cn/blog/image-20220606205657776.png" alt="image-20220606205657776"></p></li><li><p>Mybatis详细的执行流程</p></li></ol><p><img src="https://img.yiqiangshiyia.cn/blog/image-20220606205813597.png" alt="image-20220606205813597"></p><h3 id="7-3、注解增删改"><a href="#7-3、注解增删改" class="headerlink" title="7.3、注解增删改"></a>7.3、注解增删改</h3><p>改造MybatisUtils工具类的getSession( ) 方法，重载实现。【鸡汤：多看源码实现】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取SqlSession连接</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> getSession(<span class="hljs-literal">true</span>); <span class="hljs-comment">//事务自动提交</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSession</span><span class="hljs-params">(<span class="hljs-type">boolean</span> flag)</span>&#123;<br><span class="hljs-keyword">return</span> sqlSessionFactory.openSession(flag);<br>&#125;<br></code></pre></td></tr></table></figure><p>【注意】确保实体类和数据库字段对应</p><h5 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h5><ol><li><p>编写接口方法注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据id查询用户</span><br><span class="hljs-meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span><br>User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectUserById</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectUserById( <span class="hljs-number">1</span> );<br>System.out.println(user);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="新增："><a href="#新增：" class="headerlink" title="新增："></a>新增：</h5><ol><li><p>编写接口方法注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加一个用户</span><br><span class="hljs-meta">@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddUser</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>( <span class="hljs-number">6</span> , <span class="hljs-string">&quot;秦疆&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>mapper.addUser(user);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h5><ol><li><p>编写接口方法注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改一个用户</span><br><span class="hljs-meta">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(User user)</span>;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateUser</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>( <span class="hljs-number">6</span> , <span class="hljs-string">&quot;秦疆&quot;</span>, <span class="hljs-string">&quot;zxcvbn&quot;</span>);<br>mapper.updateUser(user);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h5><ol><li><p>编写接口方法注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据id删除用</span><br><span class="hljs-meta">@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span><span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteUser</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>    <br>mapper.deleteUser( <span class="hljs-number">6</span> );<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>【注意点：增删改一定记得对事务的处理】</p><h3 id="7-4、关于-Param"><a href="#7-4、关于-Param" class="headerlink" title="7.4、关于@Param"></a>7.4、关于@Param</h3><p>@Param注解用于给方法参数起一个名字。以下是总结的使用原则：</p><ul><li><p>在方法只接受一个参数的情况下，可以不使用@Param。</p></li><li><p>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</p></li><li><p>如果参数是 JavaBean ， 则不能使用@Param。</p></li><li><p>不使用@Param注解时，参数只能有一个，并且是Javabean。</p></li></ul><h3 id="7-5、-与-的区别"><a href="#7-5、-与-的区别" class="headerlink" title="7.5、#与$的区别"></a>7.5、#与$的区别</h3><ul><li><p>#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">INSERT INTO <span class="hljs-title function_">user</span> <span class="hljs-params">(name)</span> VALUES (#&#123;name&#125;);<br>INSERT INTO <span class="hljs-title function_">user</span> <span class="hljs-params">(name)</span> VALUES (?);<br></code></pre></td></tr></table></figure></li><li><p>${} 的作用是直接进行字符串替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">INSERT INTO <span class="hljs-title function_">user</span> <span class="hljs-params">(name)</span> VALUES (<span class="hljs-string">&#x27;$&#123;name&#125;&#x27;</span>);<br>INSERT INTO <span class="hljs-title function_">user</span> <span class="hljs-params">(name)</span> VALUES (<span class="hljs-string">&#x27;kuangshen&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="8-、多对一的处理"><a href="#8-、多对一的处理" class="headerlink" title="8 、多对一的处理"></a>8 、多对一的处理</h2><p>多对一的理解：</p><ul><li><p>多个学生对应一个老师</p></li><li><p>如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！</p></li></ul><h3 id="8-1、数据库设计"><a href="#8-1、数据库设计" class="headerlink" title="8.1、数据库设计"></a>8.1、数据库设计</h3><p><img src="https://img.yiqiangshiyia.cn/blog/image-20220606211459972.png" alt="image-20220606211459972"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `teacher` (<br>`id` INT( 10 ) NOT NULL,<br>`name` VARCHAR( 30 ) DEFAULT NULL,<br>PRIMARY KEY (`id`)<br>) ENGINE=INNODB DEFAULT CHARSET=utf8<br><br>INSERT INTO teacher(`id`, `name`) VALUES ( 1 , &#x27;秦老师&#x27;);<br><br>CREATE TABLE `student` (<br>`id` INT( 10 ) NOT NULL,<br>`name` VARCHAR( 30 ) DEFAULT NULL,<br>`tid` INT( 10 ) DEFAULT NULL,<br>PRIMARY KEY (`id`),<br>KEY `fktid` (`tid`),<br>CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)<br>) ENGINE=INNODB DEFAULT CHARSET=utf8<br><br>INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;);<br>INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;);<br>INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;);<br>INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;);<br>INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;);<br></code></pre></td></tr></table></figure><h3 id="8-2、搭建测试环境"><a href="#8-2、搭建测试环境" class="headerlink" title="8.2、搭建测试环境"></a>8.2、搭建测试环境</h3><p>【Lombok的使用】</p><ol><li><p>IDEA安装Lombok插件</p></li><li><p>引入Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在代码中增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span> <span class="hljs-comment">//GET,SET,ToString，有参，无参构造</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-comment">//多个学生可以是同一个老师，即多对一</span><br><span class="hljs-keyword">private</span> Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写实体类对应的Mapper接口 【两个】</p><ul><li><strong>无论有没有需求，都应该写上，以备后来之需！</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentMapper</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TeacherMapper</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写Mapper接口对应的 mapper.xml配置文件 【两个】</p><ul><li><strong>无论有没有需求，都应该写上，以备后来之需！</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta"><span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kuang.mapper.StudentMapper&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;!DOCTYPE mapper<br>PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;<br>&lt;mapper namespace=<span class="hljs-string">&quot;com.kuang.mapper.TeacherMapper&quot;</span>&gt;<br>    <br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-3、按查询嵌套处理"><a href="#8-3、按查询嵌套处理" class="headerlink" title="8.3、按查询嵌套处理"></a>8.3、按查询嵌套处理</h3><ol><li><p>给StudentMapper接口增加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取所有学生及对应老师的信息</span><br><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">getStudents</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写对应的Mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta"><span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kuang.mapper.StudentMapper&quot;</span>&gt;</span><br>    <br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">需求：获取所有学生及对应老师的信息</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment">1. 获取所有学生的信息</span><br><span class="hljs-comment">2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息</span><br><span class="hljs-comment">3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？</span><br><span class="hljs-comment">1. 做一个结果集映射：StudentTeacher</span><br><span class="hljs-comment">2. StudentTeacher结果集的类型为 Student</span><br><span class="hljs-comment">3. 学生中老师的属性为teacher，对应数据库中为tid。多个 [1,...）学生关联一个老师=&gt; 一对一，一对多</span><br><span class="hljs-comment">4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查</span><br><span class="hljs-comment">询</span><br><span class="hljs-comment">--&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudents&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span>&gt;</span><br>select * from student<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span><span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">这里传递过来的id，只有一个属性的时候，下面可以写任何值</span><br><span class="hljs-comment">association中column多参数配置：column=&quot;&#123;key=value,key=value&#125;&quot;</span><br><span class="hljs-comment">其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。</span><br><span class="hljs-comment">--&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;teacher&quot;</span>&gt;</span><br>select * from teacher where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写完毕去Mybatis配置文件中，注册Mapper！</p></li><li><p>注意点说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;&#123;id=tid,name=tid&#125;&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">这里传递过来的id，只有一个属性的时候，下面可以写任何值</span><br><span class="hljs-comment">association中column多参数配置：</span><br><span class="hljs-comment">column=&quot;&#123;key=value,key=value&#125;&quot;</span><br><span class="hljs-comment">其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段</span><br><span class="hljs-comment">名。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;teacher&quot;</span>&gt;</span><br>select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetStudents</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">StudentMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(StudentMapper.class);<br>    <br>    List&lt;Student&gt; students = mapper.getStudents();<br>    <br>    <span class="hljs-keyword">for</span> (Student student : students)&#123;<br>System.out.println(<br><span class="hljs-string">&quot;学生名:&quot;</span>+ student.getName()+<span class="hljs-string">&quot;\t老师:&quot;</span>+student.getTeacher().getName());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-4-、按结果嵌套处理"><a href="#8-4-、按结果嵌套处理" class="headerlink" title="8.4 、按结果嵌套处理"></a>8.4 、按结果嵌套处理</h3><p>除了上面这种方式，还有其他思路吗？</p><p>我们还可以按照结果进行嵌套处理；</p><ol><li><p>接口方法编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">getStudents2</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写对应的mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">按查询结果嵌套处理</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment">1. 直接查询出结果，进行结果集的映射</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudents2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher2&quot;</span> &gt;</span><br>select s.id sid, s.name sname , t.name tname<br>from student s,teacher t<br>where s.tid = t.id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>去mybatis-config文件中注入【此处应该处理过了】</p></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetStudents2</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">StudentMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(StudentMapper.class);<br>    <br>    List&lt;Student&gt; students = mapper.getStudents2();<br>    <br>    <span class="hljs-keyword">for</span> (Student student : students)&#123;<br>System.out.println(<br><span class="hljs-string">&quot;学生名:&quot;</span>+ student.getName()+<span class="hljs-string">&quot;\t老师:&quot;</span>+student.getTeacher().getName());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-5、小结"><a href="#8-5、小结" class="headerlink" title="8.5、小结"></a>8.5、小结</h3><ul><li><p>按照查询进行嵌套处理就像SQL中的子查询</p></li><li><p>按照结果进行嵌套处理就像SQL中的联表查询</p></li></ul><h2 id="9-、一对多的处理"><a href="#9-、一对多的处理" class="headerlink" title="9 、一对多的处理"></a>9 、一对多的处理</h2><p>一对多的理解：</p><ul><li><p>一个老师拥有多个学生</p></li><li><p>如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！</p></li></ul><h3 id="9-1、实体类编写"><a href="#9-1、实体类编写" class="headerlink" title="9.1、实体类编写"></a>9.1、实体类编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tid;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-comment">//一个老师多个学生</span><br><span class="hljs-keyword">private</span> List&lt;Student&gt; students;<br>&#125;<br></code></pre></td></tr></table></figure><p>….. 和之前一样，搭建测试的环境！</p><h3 id="9-2、按结果嵌套处理"><a href="#9-2、按结果嵌套处理" class="headerlink" title="9.2、按结果嵌套处理"></a>9.2、按结果嵌套处理</h3><ol><li><p>TeacherMapper接口编写方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取指定老师，及老师下的所有学生</span><br><span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">getTeacher</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写接口对应的Mapper配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kuang.mapper.TeacherMapper&quot;</span>&gt;</span><br>    <br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">思路:</span><br><span class="hljs-comment">1. 从学生表和老师表中查出学生id，学生姓名，老师姓名</span><br><span class="hljs-comment">2. 对查询出来的操作做结果集映射</span><br><span class="hljs-comment">1. 集合的话，使用collection！</span><br><span class="hljs-comment">JavaType和ofType都是用来指定对象类型的</span><br><span class="hljs-comment">JavaType是用来指定pojo中属性的类型</span><br><span class="hljs-comment">ofType指定的是映射到list集合属性中pojo的类型。</span><br><span class="hljs-comment">--&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span>&gt;</span><br>select s.id sid, s.name sname , t.name tname, t.id tid<br>from student s,teacher t<br>where s.tid = t.id and t.id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>将Mapper文件注册到MyBatis-config文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper/TeacherMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetTeacher</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">TeacherMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(TeacherMapper.class);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> mapper.getTeacher( <span class="hljs-number">1</span> );<br>System.out.println(teacher.getName());<br>System.out.println(teacher.getStudents());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="9-3、按查询嵌套处理"><a href="#9-3、按查询嵌套处理" class="headerlink" title="9.3、按查询嵌套处理"></a>9.3、按查询嵌套处理</h3><ol><li><p>TeacherMapper接口编写方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">getTeacher2</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写接口对应的Mapper配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent2&quot;</span>&gt;</span><br>select * from teacher where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;ArrayList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getStudentByTeacherId&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentByTeacherId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>select * from student where tid = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>将Mapper文件注册到MyBatis-config文件中</p></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetTeacher2</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">TeacherMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(TeacherMapper.class);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> mapper.getTeacher2( <span class="hljs-number">1</span> );<br>System.out.println(teacher.getName());<br>System.out.println(teacher.getStudents());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="9-4、小结"><a href="#9-4、小结" class="headerlink" title="9.4、小结"></a>9.4、小结</h3><ol><li><p>关联-association</p></li><li><p>集合-collection</p></li><li><p>所以association是用于一对一和多对一，而collection是用于一对多的关系</p></li><li><p>JavaType和ofType都是用来指定对象类型的</p><ul><li><p>JavaType是用来指定pojo中属性的类型</p></li><li><p>ofType指定的是映射到list集合属性中pojo的类型。</p></li></ul></li></ol><h5 id="注意说明："><a href="#注意说明：" class="headerlink" title="注意说明："></a>注意说明：</h5><ol><li><p>保证SQL的可读性，尽量通俗易懂</p></li><li><p>根据实际要求，尽量编写性能更高的SQL语句</p></li><li><p>注意属性名和字段不一致的问题</p></li><li><p>注意一对多和多对一 中：字段和属性对应的问题</p></li><li><p>尽量使用Log4j，通过日志来查看自己的错误</p></li></ol><h2 id="10-、动态SQL"><a href="#10-、动态SQL" class="headerlink" title="10 、动态SQL"></a>10 、动态SQL</h2><p>[官方文档](<a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">mybatis – MyBatis 3 | 动态 SQL</a>)</p><h3 id="10-1、介绍"><a href="#10-1、介绍" class="headerlink" title="10.1、介绍"></a>10.1、介绍</h3><p>什么是动态SQL： <strong>动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.</strong></p><blockquote><p>官网描述：</p><p>​        MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。<br>​        虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。<br>​        动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。</p><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul></blockquote><p>我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。</p><p>那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise,trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。</p><h3 id="10-2、搭建环境"><a href="#10-2、搭建环境" class="headerlink" title="10.2、搭建环境"></a>10.2、搭建环境</h3><h5 id="新建一个数据库表：blog"><a href="#新建一个数据库表：blog" class="headerlink" title="新建一个数据库表：blog"></a>新建一个数据库表：blog</h5><p>字段：id，title，author，create_time，views</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `blog` (<br>`id` varchar( 50 ) NOT NULL COMMENT &#x27;博客id&#x27;,<br>`title` varchar( 100 ) NOT NULL COMMENT &#x27;博客标题&#x27;,<br>`author` varchar( 30 ) NOT NULL COMMENT &#x27;博客作者&#x27;,<br>`create_time` datetime NOT NULL COMMENT &#x27;创建时间&#x27;,<br>`views` int( 30 ) NOT NULL COMMENT &#x27;浏览量&#x27;<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8<br></code></pre></td></tr></table></figure><ol><li>创建Mybatis基础工程</li></ol><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://img.yiqiangshiyia.cn/blog/image-20220606214419031.png" alt="image-20220606214419031"></h6><ol start="2"><li><p>IDutil工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDUtil</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">genId</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实体类编写 【注意set方法作用】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String id;<br><span class="hljs-keyword">private</span> String title;<br><span class="hljs-keyword">private</span> String author;<br><span class="hljs-keyword">private</span> Date createTime;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> views;<br><span class="hljs-comment">//set，get....</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写Mapper接口及xml文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlogMapper</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta"><span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kuang.mapper.BlogMapper&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span> <br></code></pre></td></tr></table></figure></li><li><p>mybatis核心配置文件，下划线驼峰自动转换</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-comment">&lt;!--注册Mapper.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper/BlogMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>插入初始数据</p><p>编写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//新增一个博客</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">addBlog</span><span class="hljs-params">(Blog blog)</span>;<br></code></pre></td></tr></table></figure><p>sql配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addBlog&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>insert into blog (id, title, author, create_time, views)<br>values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>初始化博客方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInitBlog</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);<br>    <br>    <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blog</span>();<br>blog.setId(IDUtil.genId());<br>blog.setTitle(<span class="hljs-string">&quot;Mybatis如此简单&quot;</span>);<br>blog.setAuthor(<span class="hljs-string">&quot;狂神说&quot;</span>);<br>blog.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>blog.setViews( <span class="hljs-number">9999</span> );<br>    <br>    mapper.addBlog(blog);<br>    <br>    blog.setId(IDUtil.genId());<br>blog.setTitle(<span class="hljs-string">&quot;Java如此简单&quot;</span>);<br>mapper.addBlog(blog);<br>    <br>    blog.setId(IDUtil.genId());<br>blog.setTitle(<span class="hljs-string">&quot;Spring如此简单&quot;</span>);<br>mapper.addBlog(blog);<br>    <br>    blog.setId(IDUtil.genId());<br>    blog.setTitle(<span class="hljs-string">&quot;微服务如此简单&quot;</span>);<br>mapper.addBlog(blog);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化数据完毕！</p></li></ol><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><h3 id="10-3、if-语句"><a href="#10-3、if-语句" class="headerlink" title="10.3、if 语句"></a>10.3、if 语句</h3><p><strong>需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</strong></p><ol><li><p>编写接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//需求 1</span><br>List&lt;Blog&gt; <span class="hljs-title function_">queryBlogIf</span><span class="hljs-params">(Map map)</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写SQL语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--需求1：</span><br><span class="hljs-comment">根据作者名字和博客名字来查询博客！</span><br><span class="hljs-comment">如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</span><br><span class="hljs-comment">select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogIf&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>select * from blog where<br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>title = #&#123;title&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>and author = #&#123;author&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryBlogIf</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);<br>    <br>    HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>map.put(<span class="hljs-string">&quot;title&quot;</span>,<span class="hljs-string">&quot;Mybatis如此简单&quot;</span>);<br>map.put(<span class="hljs-string">&quot;author&quot;</span>,<span class="hljs-string">&quot;狂神说&quot;</span>);<br>List&lt;Blog&gt; blogs = mapper.queryBlogIf(map);<br>    <br>    System.out.println(blogs);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#{title},但是如果title为空呢？那么查询语句为 select * from user where and author=#{author}，这是错误的SQL 语句，如何解决呢？请看下面的 where 语句！</p><h3 id="10-4、Where"><a href="#10-4、Where" class="headerlink" title="10.4、Where"></a>10.4、Where</h3><p>修改上面的SQL语句；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogIf&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>select * from blog<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>title = #&#123;title&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>and author = #&#123;author&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。【这是我们使用的最多的案例】</p><h3 id="10-5、Set"><a href="#10-5、Set" class="headerlink" title="10.5、Set"></a>10.5、Set</h3><p>同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？</p><ol><li><p>编写接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">updateBlog</span><span class="hljs-params">(Map map)</span>;<br></code></pre></td></tr></table></figure></li><li><p>sql配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注意set是用的逗号隔开--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBlog&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>update blog<br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>title = #&#123;title&#125;,<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>author = #&#123;author&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>where id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateBlog</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);<br>    <br>    HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>map.put(<span class="hljs-string">&quot;title&quot;</span>,<span class="hljs-string">&quot;动态SQL&quot;</span>);<br>map.put(<span class="hljs-string">&quot;author&quot;</span>,<span class="hljs-string">&quot;秦疆&quot;</span>);<br>map.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;9d6a763f5e1347cebda43e2a32687a77&quot;</span>);<br>    <br>    mapper.updateBlog(map);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>【演示】SQL分析</p><h3 id="10-6、choose语句"><a href="#10-6、choose语句" class="headerlink" title="10.6、choose语句"></a>10.6、choose语句</h3><p>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose标签可以解决此类问题，类似于 Java 的 switch 语句</p><ol><li><p>编写接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Blog&gt; <span class="hljs-title function_">queryBlogChoose</span><span class="hljs-params">(Map map)</span>;<br></code></pre></td></tr></table></figure></li><li><p>sql配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogChoose&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>select * from blog<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>title = #&#123;title&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>and author = #&#123;author&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>and views = #&#123;views&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryBlogChoose</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);<br>    <br>    HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>map.put(<span class="hljs-string">&quot;title&quot;</span>,<span class="hljs-string">&quot;Java如此简单&quot;</span>);<br>map.put(<span class="hljs-string">&quot;author&quot;</span>,<span class="hljs-string">&quot;狂神说&quot;</span>);<br>map.put(<span class="hljs-string">&quot;views&quot;</span>, <span class="hljs-number">9999</span> );<br>List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map);<br>    <br>    System.out.println(blogs);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>【演示】SQL分析</p><h3 id="10-7、SQL片段"><a href="#10-7、SQL片段" class="headerlink" title="10.7、SQL片段"></a>10.7、SQL片段</h3><p>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</p><p><strong>提取SQL片段：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;if-title-author&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>title = #&#123;title&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>and author = #&#123;author&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>引用SQL片段：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogIf&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>select * from blog<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;if-title-author&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：①、最好基于 单表来定义 sql 片段，提高片段的可重用性</p><p>​            ②、在 sql 片段中不要包括 where</p><h3 id="10-8、Foreach"><a href="#10-8、Foreach" class="headerlink" title="10.8、Foreach"></a>10.8、Foreach</h3><p>将数据库中前三个数据的id修改为1,2,3；</p><p>需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息</p><ol><li><p>编写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> List&lt;Blog&gt; <span class="hljs-title function_">queryBlogForeach</span><span class="hljs-params">(Map map)</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写SQL语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogForeach&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>select * from blog<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">collection:指定输入对象中的集合属性</span><br><span class="hljs-comment">item:每次遍历生成的对象</span><br><span class="hljs-comment">open:开始遍历时的拼接字符串</span><br><span class="hljs-comment">close:结束时拼接的字符串</span><br><span class="hljs-comment">separator:遍历对象之间需要拼接的字符串</span><br><span class="hljs-comment">select * from blog where 1=1 and (id=1 or id=2 or id=3)</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;and (&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryBlogForeach</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);<br>    <br>    <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>List&lt;Integer&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>ids.add( <span class="hljs-number">1</span> );<br>ids.add( <span class="hljs-number">2</span> );<br>ids.add( <span class="hljs-number">3</span> );<br>map.put(<span class="hljs-string">&quot;ids&quot;</span>,ids);<br>    <br>    List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);<br>    <br>    System.out.println(blogs);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧</p><h2 id="11-、缓存"><a href="#11-、缓存" class="headerlink" title="11 、缓存"></a>11 、缓存</h2><h3 id="11-1、简介"><a href="#11-1、简介" class="headerlink" title="11.1、简介"></a>11.1、简介</h3><ol><li><p>什么是缓存 [ Cache ]？</p><ul><li><p>存在内存中的临时数据。</p></li><li><p>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</p></li></ul></li><li><p>为什么使用缓存？</p><ul><li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li></ul></li><li><p>什么样的数据能使用缓存？</p><ul><li>经常查询并且不经常改变的数据。</li></ul></li></ol><h3 id="11-2、Mybatis缓存"><a href="#11-2、Mybatis缓存" class="headerlink" title="11.2、Mybatis缓存"></a>11.2、Mybatis缓存</h3><ul><li><p>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。</p></li><li><p>MyBatis系统中默认定义了两级缓存： 一级缓存 和 二级缓存</p><ul><li><p>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</p></li><li><p>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</p></li><li><p>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</p></li></ul></li></ul><h3 id="11-3、一级缓存"><a href="#11-3、一级缓存" class="headerlink" title="11.3、一级缓存"></a>11.3、一级缓存</h3><ul><li><p>一级缓存也叫本地缓存：</p><ul><li><p>与数据库同一次会话期间查询到的数据会放在本地缓存中。</p></li><li><p>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</p></li></ul></li></ul><h4 id="11-3-1、初体验测试"><a href="#11-3-1、初体验测试" class="headerlink" title="11.3.1、初体验测试"></a>11.3.1、初体验测试</h4><ol><li><p>在mybatis中加入日志，方便测试结果</p></li><li><p>编写接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据id查询用户</span><br>User <span class="hljs-title function_">queryUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>接口对应的Mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select * from user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user);<br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user2);<br>System.out.println(user==user2);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结果分析</p><p><img src="https://img.yiqiangshiyia.cn/blog/image-20220606221215646.png" alt="image-20220606221215646"></p></li></ol><h4 id="11-3-2、一级缓存失效的四种情况"><a href="#11-3-2、一级缓存失效的四种情况" class="headerlink" title="11.3.2、一级缓存失效的四种情况"></a>11.3.2、一级缓存失效的四种情况</h4><ul><li><p>一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；</p></li><li><p>一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！</p></li></ul><ol><li><p>sqlSession不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session2</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> session2.getMapper(UserMapper.class);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user);<br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper2.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user2);<br>System.out.println(user==user2);<br>    <br>    session.close();<br>session2.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>观察结果：发现发送了两条SQL语句！</p><p>结论： <strong>每个sqlSession中的缓存相互独立</strong></p></li><li><p>sqlSession相同，查询条件不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user);<br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper2.queryUserById( <span class="hljs-number">2</span> );<br>System.out.println(user2);<br>System.out.println(user==user2);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>观察结果：发现发送了两条SQL语句！很正常的理解</p><p>结论： <strong>当前缓存中，不存在这个数据</strong></p></li><li><p>sqlSession相同，两次查询之间执行了增删改操作！</p><ul><li><p>增加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改用户</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(Map map)</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>update user set name = #&#123;name&#125; where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>    <br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user);<br>    <br>    <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;kuangshen&quot;</span>);<br>map.put(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">4</span> );<br>mapper.updateUser(map);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user2);<br>    <br>    System.out.println(user==user2);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>观察结果：查询在中间执行了增删改操作后，重新执行了</p><p>结论： <strong>因为增删改操作可能会对当前数据产生影响</strong></p></li></ul></li><li><p>sqlSession相同，手动清除一级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user);<br>    <br>    session.clearCache();<span class="hljs-comment">//手动清除缓存</span><br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user2);<br>    <br>    System.out.println(user==user2);<br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>一级缓存就是一个map</p><h3 id="11-4、二级缓存"><a href="#11-4、二级缓存" class="headerlink" title="11.4、二级缓存"></a>11.4、二级缓存</h3><ul><li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p></li><li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p></li><li><p>工作机制</p><ul><li><p>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</p></li><li><p>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</p></li><li><p>新的会话查询信息，就可以从二级缓存中获取内容；</p></li><li><p>不同的mapper查出的数据会放在自己对应的缓存（map）中；</p></li></ul></li></ul><h4 id="11-4-1、使用步骤"><a href="#11-4-1、使用步骤" class="headerlink" title="11.4.1、使用步骤"></a>11.4.1、使用步骤</h4><p>[官方文档](<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache">mybatis – MyBatis 3 | XML 映射器</a>)</p><ol><li><p>开启全局缓存 【mybatis-config.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br><br>官方示例=====&gt;查看官方文档<br><span class="hljs-tag">&lt;<span class="hljs-name">cache</span></span><br><span class="hljs-tag"><span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的<br>512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者<br>产生冲突。<br></code></pre></td></tr></table></figure></li><li><p>代码测试</p><ul><li><p>所有的实体类先实现序列化接口</p></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session2</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>    <br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> session2.getMapper(UserMapper.class);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user);<br>session.close();<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper2.queryUserById( <span class="hljs-number">1</span> );<br>System.out.println(user2);<br>System.out.println(user==user2);<br>    <br>    session2.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="11-4-2、结论"><a href="#11-4-2、结论" class="headerlink" title="11.4.2、结论"></a>11.4.2、结论</h4><ul><li><p>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</p></li><li><p>查出的数据都会被默认先放在一级缓存中</p></li><li><p>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</p></li></ul><h3 id="11-5、缓存原理"><a href="#11-5、缓存原理" class="headerlink" title="11.5、缓存原理"></a>11.5、缓存原理</h3><p><img src="https://img.yiqiangshiyia.cn/blog/image-20220606222550369.png" alt="image-20220606222550369"></p><h3 id="11-6、EhCache"><a href="#11-6、EhCache" class="headerlink" title="11.6、EhCache"></a>11.6、EhCache</h3><p>第三方缓存实现–EhCache: 查看百度百科</p><ul><li><p>[官方文档](<a href="http://mybatis.org/ehcache-cache/">mybatis-ehcache – MyBatis Ehcache | Reference Documentation</a>)</p></li><li><p>Ehcache是一种广泛使用的java分布式缓存，用于通用缓存；</p></li><li><p>要在应用程序中使用Ehcache，需要引入依赖的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-</span><br><span class="hljs-comment">ehcache --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.caches<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在mapper.xml中使用对应的缓存即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span> = <span class="hljs-string">“org.acme.FooMapper”</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span> = <span class="hljs-string">“org.mybatis.caches.ehcache.EhcacheCache”</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写ehcache.xml文件，如果在 加载时 未找到 /ehcache.xml 资源或出现问题，则将使用默认配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">updateCheck</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：</span><br><span class="hljs-comment">user.home – 用户主目录</span><br><span class="hljs-comment">user.dir – 用户当前工作目录</span><br><span class="hljs-comment">java.io.tmpdir – 默认临时文件路径</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;./tmpdir/Tmp_EhCache&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span></span><br><span class="hljs-tag"><span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;10000&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;1800&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;259200&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">&quot;LRU&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span></span><br><span class="hljs-tag"><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cloud_user&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;5000&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;1800&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;1800&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">&quot;LRU&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">name:缓存名称。</span><br><span class="hljs-comment">maxElementsInMemory:缓存最大数目</span><br><span class="hljs-comment">maxElementsOnDisk：硬盘最大缓存个数。</span><br><span class="hljs-comment">eternal:对象是否永久有效，一但设置了，timeout将不起作用。</span><br><span class="hljs-comment">overflowToDisk:是否保存到磁盘，当系统当机时</span><br><span class="hljs-comment">timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当</span><br><span class="hljs-comment">eternal=false对象不是永久有效时使用，可选属性，默认值是 0 ，也就是可闲置时间无穷大。</span><br><span class="hljs-comment">timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</span><br><span class="hljs-comment">diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</span><br><span class="hljs-comment">diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</span><br><span class="hljs-comment">diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是 120 秒。</span><br><span class="hljs-comment">memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</span><br><span class="hljs-comment">clearOnFlush：内存数量最大时是否清除。</span><br><span class="hljs-comment">memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。FIFO，first in first out，这个是大家最熟的，先进先出。LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</span><br><span class="hljs-comment">--&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>夜爬泰山Vlog</title>
    <link href="/2022/06/05/%E5%A4%9C%E7%88%AC%E6%B3%B0%E5%B1%B1Vlog/"/>
    <url>/2022/06/05/%E5%A4%9C%E7%88%AC%E6%B3%B0%E5%B1%B1Vlog/</url>
    
    <content type="html"><![CDATA[<h2 id="夜爬泰山看日出Vlog"><a href="#夜爬泰山看日出Vlog" class="headerlink" title="夜爬泰山看日出Vlog"></a>夜爬泰山看日出Vlog</h2><blockquote><p>2022.06.02端午节放假的前一天，山东这边已经没有什么疫情了，离开青岛市导员审批就可以了。上午英语课买完火车票，下午三点多就踏上了夜爬泰山之旅。至于攻略计划之类的早就计划好了，只是由于疫情一直没有什么机会出去。</p></blockquote><h4 id="记录一下夜爬泰山的时间线"><a href="#记录一下夜爬泰山的时间线" class="headerlink" title="记录一下夜爬泰山的时间线"></a>记录一下夜爬泰山的时间线</h4><p><strong>17：23 青岛市出发</strong></p><p><strong>22：46 抵达泰安市</strong></p><blockquote><p>将近五个小时的绿皮火车硬座+硬卧，还没开始爬泰山就已经略感疲惫了</p></blockquote><p><strong>23：13 抵达泰山山脚 开始出发</strong></p><p><strong>23：40 检票出发</strong></p><blockquote><p>夜爬山的人挺多，倒也不是很拥挤，我们选择了最经典的爬泰山路线，从红门宫出发，经中天门、十八盘、南天门、天街，最后登顶玉皇顶。</p></blockquote><p><strong>凌晨01：46 抵达中天门</strong></p><blockquote><p>到达中天门算是爬完了一半的路程，休息的时间比较长，因为后面还有最陡最难爬的十八盘。</p></blockquote><p><strong>凌晨04：25 登顶泰山玉皇顶 站在了齐鲁大地的最高处 静待日出</strong></p><p><strong>凌晨04：55 日出</strong></p><blockquote><p>运气还不错，看见了泰山的绝美日出！远赴人间惊鸿宴，一睹人间盛世颜！真的有被惊艳到！</p></blockquote><h4 id="记录拍的img"><a href="#记录拍的img" class="headerlink" title="记录拍的img"></a>记录拍的img</h4><h5 id="img1"><a href="#img1" class="headerlink" title="img1"></a>img1</h5><p><img src="https://img.yiqiangshiyia.cn/blog/IMG_20220605_132218.jpg" alt="IMG_20220605_132218"></p><h5 id="img2"><a href="#img2" class="headerlink" title="img2"></a>img2</h5><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220605130944.jpg" alt="微信图片_20220605130944"></p><h5 id="img3"><a href="#img3" class="headerlink" title="img3"></a>img3</h5><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220605130954.jpg" alt="微信图片_20220605130954"></p><h5 id="img4"><a href="#img4" class="headerlink" title="img4"></a>img4</h5><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220605131004.jpg" alt="微信图片_20220605131004"></p><h5 id="img5"><a href="#img5" class="headerlink" title="img5"></a>img5</h5><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220605131009.jpg" alt="微信图片_20220605131009"></p><h5 id="img6"><a href="#img6" class="headerlink" title="img6"></a>img6</h5><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220605131014.jpg" alt="微信图片_20220605131014"></p><h5 id="img7"><a href="#img7" class="headerlink" title="img7"></a>img7</h5><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220605131020.jpg" alt="微信图片_20220605131020"></p><h5 id="img8"><a href="#img8" class="headerlink" title="img8"></a>img8</h5><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220605131025.jpg" alt="微信图片_20220605131025"></p><h5 id="img9"><a href="#img9" class="headerlink" title="img9"></a>img9</h5><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220605131029.jpg" alt="微信图片_20220605131029"></p><h5 id="img10"><a href="#img10" class="headerlink" title="img10"></a>img10</h5><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220605131035.jpg" alt="微信图片_20220605131035"></p><h5 id="img11"><a href="#img11" class="headerlink" title="img11"></a>img11</h5><p><img src="https://img.yiqiangshiyia.cn/blog/mmexport1654136095135.jpg" alt="mmexport1654136095135"></p><h5 id="img12"><a href="#img12" class="headerlink" title="img12"></a>img12</h5><p><img src="https://img.yiqiangshiyia.cn/blog/retouch_2022060216254659.jpg" alt="retouch_2022060216254659"></p><h5 id="img13"><a href="#img13" class="headerlink" title="img13"></a>img13</h5><p><img src="https://img.yiqiangshiyia.cn/blog/IMG20220602231707.jpg" alt="IMG20220602231707"></p><h5 id="img14"><a href="#img14" class="headerlink" title="img14"></a>img14</h5><p><img src="https://img.yiqiangshiyia.cn/blog/retouch_2022060303520899.jpg" alt="retouch_2022060303520899"></p><h5 id="img15"><a href="#img15" class="headerlink" title="img15"></a>img15</h5><p><img src="https://img.yiqiangshiyia.cn/blog/mmexport1654204294590.jpg" alt="mmexport1654204294590"></p><h5 id="img16"><a href="#img16" class="headerlink" title="img16"></a>img16</h5><p><img src="https://img.yiqiangshiyia.cn/blog/mmexport1654264153363.jpg" alt="mmexport1654264153363"></p><h5 id="img17"><a href="#img17" class="headerlink" title="img17"></a>img17</h5><p><img src="https://img.yiqiangshiyia.cn/blog/-36c002b63d3cc530.jpg" alt="-36c002b63d3cc530"></p><h5 id="img18"><a href="#img18" class="headerlink" title="img18"></a>img18</h5><p><img src="https://img.yiqiangshiyia.cn/blog/IMG_20220605_105703.jpg" alt="IMG_20220605_105703"></p><p>喜欢花，喜欢海，喜欢日出日落，浪漫的灵魂从不向平淡的日子妥协。</p>]]></content>
    
    
    <categories>
      
      <category>Vlog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 473.火柴拼正方形 回溯</title>
    <link href="/2022/06/01/LC%20473.%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2022/06/01/LC%20473.%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-473-火柴拼正方形"><a href="#LC-473-火柴拼正方形" class="headerlink" title="LC 473.火柴拼正方形"></a>LC 473.火柴拼正方形</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>LC刷了一百多道题第一次做回溯算法的题，当然要好好研究一下了🧐</p><p>从大到小sort排序函数：sort(matchsticks.rbegin(),matchsticks.rend());  //从大到小排序</p></blockquote><h4 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h4><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><p>bilibili回溯算法笔记总结</p><ul><li>回溯算法和递归算法相辅相成，有递归就会有回溯，一般递归下面就是回溯</li><li>回溯算法是一种纯暴力搜索算法，时间复杂度一般比较高，可以通过剪枝等优化算法</li><li>回溯算法虽然是一种纯暴力搜索算法，但是可以解决多层for循环嵌套无法解决的问题</li><li>回溯算法使用题目类型：组合问题、切割问题、子集问题、排列问题、棋盘问题（N皇后问题、解数独问题）</li><li>回溯都可以抽象成树形结构，递归都有终止条件</li><li>回溯一般参数比较多</li></ul><p>待续……</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。</p><p>如果你能使这个正方形，则返回 true ，否则返回 false 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：回溯法</strong></p><p>将正方形的四条边看做是四个高为1/4火柴总周长的桶，回溯的找出将火柴全部放入桶中，并且将四个桶都装满的方法就可以了，利用回溯搜索，递归的将所有火柴放入桶中</p><p>暴力回溯搜索法超时</p><p>需要对回溯搜索进行剪枝优化</p><p>算法优化 </p><ul><li>将火柴数量小于4 火柴总长度无法被4整除的情况排除掉</li><li>重要优化：将火柴按照从长到短的顺序排序</li></ul><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">makesquare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; matchsticks)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matchsticks.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">4</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            sum = sum+matchsticks[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">4</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">sort</span>(matchsticks.<span class="hljs-built_in">rbegin</span>(),matchsticks.<span class="hljs-built_in">rend</span>());  <span class="hljs-comment">//从大到小排序</span><br>        <span class="hljs-type">int</span> bucket[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//设置桶的数组</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">backtrack</span>(<span class="hljs-number">0</span>,matchsticks,sum/<span class="hljs-number">4</span>,bucket);  <span class="hljs-comment">//回溯的尝试火柴的放置</span><br>    &#125;<br>    <span class="hljs-comment">//i代表正在放置的火柴下标，nums存储火柴的长度</span><br>    <span class="hljs-comment">//edge为计算好的正方形边长，bucket存储四个桶的高度</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> i,vector&lt;<span class="hljs-type">int</span>&gt;&amp; matchsticks,<span class="hljs-type">int</span> edge,<span class="hljs-type">int</span> bucket[<span class="hljs-number">4</span>])</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= matchsticks.<span class="hljs-built_in">size</span>())&#123;  <span class="hljs-comment">//递归终止条件 全部的火柴都放到了桶中</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//成功的拼成了正方形 返回true</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">4</span>; j++)&#123;  <span class="hljs-comment">//遍历四个桶</span><br>            <span class="hljs-keyword">if</span>(bucket[j]+matchsticks[i] &gt; edge)&#123;  <span class="hljs-comment">//这根火柴无法放入第j个桶中</span><br>                <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//尝试下一个桶</span><br>            &#125;<br>            bucket[j] = bucket[j]+matchsticks[i];  <span class="hljs-comment">//nums[i]放入桶j</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(i+<span class="hljs-number">1</span>,matchsticks,edge,bucket))&#123;  <span class="hljs-comment">//递归的放置下一根火柴</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//下一根火柴放置成功则直接返回true</span><br>            &#125;<br>            bucket[j] = bucket[j]-matchsticks[i];  <span class="hljs-comment">//将nums[i]从桶j中拿出</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//nums[i]无法放入任何一个桶 函数返回false</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>bilibili视频讲解：<a href="https://www.bilibili.com/video/BV1D5411j7UE?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1D5411j7UE?spm_id_from=333.337.search-card.all.click</a></p><p><strong>方法2：状态压缩+动态规划</strong></p><p>好像很难的样子 应该不是我目前能理解的 先搞懂比较基础的回溯算法吧</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10分钟彻底搞懂动态规划算法</title>
    <link href="/2022/05/26/10%E5%88%86%E9%92%9F%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
    <url>/2022/05/26/10%E5%88%86%E9%92%9F%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>今天无意中在Bilibili上看到了一个up主讲动态规划算法的视频，动态规划的算法的题一般都比较难理解做的也比较少，所以就看了一下这个视频，看完之后讲的也太妙了吧！深入浅出了属于是，让我更好的理解了动态规划算法，我直接投币+三连好吧😂。视频中举了一个比较经典的动态规划问题，最长子序列问题，也就是LC上的第300题：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a>，LC难度为中等，学到了很多东西记录一下题解吧。</p></blockquote><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220526165818.png" alt="QQ截图20220526165818"></p><p>附上链接：<a href="https://www.bilibili.com/video/BV1AB4y1w7eT/?spm_id_from=333.788.recommend_more_video.1">https://www.bilibili.com/video/BV1AB4y1w7eT/?spm_id_from=333.788.recommend_more_video.1</a></p><h2 id="LeetCode-300：最长递增子序列"><a href="#LeetCode-300：最长递增子序列" class="headerlink" title="LeetCode 300：最长递增子序列"></a>LeetCode 300：最长递增子序列</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>动态规划正是通过避免了重复节点的计算，来加速整个计算的过程</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：穷举法/暴力搜索</strong></p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220526193003.png" alt="QQ截图20220526193003"></p><p>这个算法虽然可以算出答案，但是最大的问题在于时间复杂度，指数级别的算法，最慢的算法之一。之所以时间复杂度高代码超时是因为在递归的时候存在大量重复计算，因此时间复杂度特别高。</p><p>超时代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">L</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums,<span class="hljs-type">int</span> i)</span>  <span class="hljs-comment">//定义L函数，表示从nums的第i个数开始遍历的最长递增子序列</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i == nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>; j&lt;nums.<span class="hljs-built_in">size</span>(); j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &gt; nums[i])<br>            &#123;<br>                maxlen = <span class="hljs-built_in">max</span>(maxlen,<span class="hljs-built_in">L</span>(nums,j)+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxlen;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">L</span>(nums,i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：记忆化搜索/剪枝</strong></p><p>为了避免重复计算，我们可以在第一次计算的时候将结果保存下来，之后遍历到相同的节点就不再需要重复计算了，直接将之前的结果返回。</p><p>对暴力求解的代码进行改进，用哈希表保存计算过的节点，但是我也不知道为什么改进之后代码还是超时🤣</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">L</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums,<span class="hljs-type">int</span> i)</span>  <span class="hljs-comment">//定义L函数，表示从nums的第i个数开始遍历的最长递增子序列</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(i))<br>        &#123;<br>            <span class="hljs-keyword">return</span> mp[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>; j&lt;nums.<span class="hljs-built_in">size</span>(); j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &gt; nums[i])<br>            &#123;<br>                maxlen = <span class="hljs-built_in">max</span>(maxlen,<span class="hljs-built_in">L</span>(nums,j)+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        mp[i] = maxlen;<br>        <span class="hljs-keyword">return</span> maxlen;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">L</span>(nums,i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>动态规划正是通过避免了重复节点的计算，来加速整个计算的过程，由于用到了字典/哈希表保存了计算的中间结果，因此我们也称之为记忆化搜索，因此动态规划是空间换时间的一种算法，动态规划也可以叫带备忘录的递归或者递归树的剪枝。</p><p><strong>LC官方题解的递归算法</strong></p><p>待续……</p><p><strong>方法3：改写成迭代形式</strong></p><p>有了递归的算法还可以将其改写成非递归的算法或者迭代，改写成迭代可以更加直观的分析算法的时间复杂度并且避免了递归时的函数调用开销。</p><p><img src="https://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220526202358.png" alt="QQ截图20220526202358"></p><p>从公式中可以发现，我们只要从后往前依次计算就可以把答案推算出来，迭代的方法很像数学归纳法，根据列出的式子实现迭代算法。</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>; j&lt;n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &gt; nums[i])<br>                &#123;<br>                    ans[i] = <span class="hljs-built_in">max</span>(ans[i],ans[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> max_ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;ans.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            max_ans = <span class="hljs-built_in">max</span>(max_ans,ans[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 467.环绕字符串中唯一的子字符串</title>
    <link href="/2022/05/25/LC%20467.%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/05/25/LC%20467.%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-467-环绕字符串中唯一的子字符串"><a href="#LC-467-环绕字符串中唯一的子字符串" class="headerlink" title="LC 467.环绕字符串中唯一的子字符串"></a>LC 467.环绕字符串中唯一的子字符串</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>本题的关键是如何去重，但是由于1&lt;=p.length&lt;=10^5，所以去重的数量非常非常大，是一个巨额数字难以实现。以某个字符开头或结尾，采用动态规划的思路，定义一个大小为26的dp数组，这样可以有效的去重。</p><p>问题本质：以某一字符串开头或结尾，它的最长的序列长度。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/">https://leetcode.cn/problems/unique-substrings-in-wraparound-string/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：动态规划</strong></p><blockquote><p>由于 s 是周期字符串，对于在 s 中的子串，只要知道子串的第一个字符（或最后一个字符）和子串长度，就能确定这个子串。例如子串以 ‘d’ 结尾，长度为 3，那么该子串为 “bcd”。</p><p>题目要求不同的子串个数，那么对于两个以同一个字符结尾的子串，长的那个子串必然包含短的那个。例如 “abcd” 和 “bcd” 均以 ‘d’ 结尾，”bcd” 是 “abcd” 的子串。</p><p>据此，我们可以定义 dp[α] 表示 p 中以字符 α 结尾且在 s 中的子串的最长长度，知道了最长长度，也就知道了不同的子串的个数。</p><p>如何计算 dp[α] 呢？我们可以在遍历 p 时，维护连续递增的子串长度 k。具体来说，遍历到 p[i] 时，如果 p[i] 是 p[i-1] 在字母表中的下一个字母，则将 k 加一，否则将 k 置为 1，表示重新开始计算连续递增的子串长度。然后，用 k 更新 dp[p[i]] 的最大值。</p><p>遍历结束后，p 中以字符 c 结尾且在 s 中的子串有 dp[c] 个。例如 dp[‘d’]=3 表示子串”bcd” “cd” “d”</p><p>最后答案为：sum(dp[α])</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNext</span><span class="hljs-params">(<span class="hljs-type">char</span> a,<span class="hljs-type">char</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> (a == <span class="hljs-string">&#x27;z&#x27;</span> &amp;&amp; b == <span class="hljs-string">&#x27;a&#x27;</span>) || b==a+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findSubstringInWraproundString</span><span class="hljs-params">(string p)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;p.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isNext</span>(p[i<span class="hljs-number">-1</span>],p[i]))<br>                &#123;<br>                    cnt++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    cnt = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            dp[p[i]-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-built_in">max</span>(dp[p[i]-<span class="hljs-string">&#x27;a&#x27;</span>],cnt);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dp.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            ans = ans+dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Bilibili学习链接：<a href="https://www.bilibili.com/video/BV1cB4y1X7cQ?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1cB4y1X7cQ?spm_id_from=333.337.search-card.all.click</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 链表归纳总结</title>
    <link href="/2022/05/22/LC%20%E9%93%BE%E8%A1%A8%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/22/LC%20%E9%93%BE%E8%A1%A8%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h4><p> 链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p><p><img src="https://img.yiqiangshiyia.cn/blog/1774269-20191111002101989-1257105196.jpg" alt="img"></p><h4 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h4><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p><p>链表是一种插入和删除都比较快的数据结构，缺点是查找比较慢。除非需要频繁的通过下标来随机访问数据，否则在很多使用数组的地方都可以用链表代替。</p><h2 id="LC-206-反转链表"><a href="#LC-206-反转链表" class="headerlink" title="LC 206.反转链表"></a>LC 206.反转链表</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">//定义一个当前节点的前一个节点 初始化为空</span><br>        ListNode* cur = head;  <span class="hljs-comment">//定义一个当前节点 初始化为头结点</span><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//当前节点不为空</span><br>        &#123;<br>            ListNode* tmp = cur-&gt;next;  <span class="hljs-comment">//定义一个tmp结点 用于保存当前节点的后序节点</span><br>            cur-&gt;next = pre;  <span class="hljs-comment">//反转链表 让cur节点指向pre节点</span><br>            pre = cur;  <span class="hljs-comment">//前序节点后移一位</span><br>            cur = tmp;  <span class="hljs-comment">//当前节点后移一位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;  <span class="hljs-comment">//返回新链表指向的头结点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>B站反转链表讲解：<a href="https://www.bilibili.com/video/BV1KZ4y157Up/?spm_id_from=333.788">https://www.bilibili.com/video/BV1KZ4y157Up/?spm_id_from=333.788</a></p><p> </p><h2 id="LC-21-合并两个有序链表"><a href="#LC-21-合并两个有序链表" class="headerlink" title="LC 21.合并两个有序链表"></a>LC 21.合并两个有序链表</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>只会迭代法 递归法有点复杂  </p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* preHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);  <span class="hljs-comment">//定义哨兵节点preHead</span><br>        ListNode* prev = preHead;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>                prev-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            prev = prev-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br>        prev-&gt;next = l1 == <span class="hljs-literal">nullptr</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> preHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>LeetCode题解合并两个有序链表动画演示非常nice！ </p><p>LeetCode题解：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</a>  </p><h2 id="LC-203-移除链表元素"><a href="#LC-203-移除链表元素" class="headerlink" title="LC 203.移除链表元素"></a>LC 203.移除链表元素</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val  的节点,并返回新的头结点。  </p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：迭代法</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//由于链表头结点Head可能需要被删除 创建哑结点preHead 令pre-&gt;next = head</span><br>        ListNode* preHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        ListNode* tmp = preHead;  <span class="hljs-comment">//定义当前节点 初始化为preHead</span><br>        <span class="hljs-keyword">while</span>(tmp-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmp-&gt;next-&gt;val == val)<br>            &#123;<br>                tmp-&gt;next = tmp-&gt;next-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tmp = tmp-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> preHead-&gt;next;  <span class="hljs-comment">//返回删除操作后的头结点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-82-删除排序链表中的重复元素-II"><a href="#LC-82-删除排序链表中的重复元素-II" class="headerlink" title="LC 82.删除排序链表中的重复元素 II"></a>LC 82.删除排序链表中的重复元素 II</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>经典面试题，力扣难度：中等</p><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);  <span class="hljs-comment">//定义哑结点，因为头结点可能会被删除</span><br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123;<br>                <span class="hljs-type">int</span> x = cur-&gt;next-&gt;val;<br>                <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == x)&#123;<br>                    cur-&gt;next = cur-&gt;next-&gt;next;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-2-两数相加"><a href="#LC-2-两数相加" class="headerlink" title="LC 2.两数相加"></a>LC 2.两数相加</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><img src="https://img.yiqiangshiyia.cn/blog/addtwonumber1.jpg" alt="img"></p><blockquote><p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.</p></blockquote><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>力扣难度：中等 题目大致思路：模拟链表 注意进位即可</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);  <span class="hljs-comment">//定义链表头结点</span><br>        ListNode* cur = head;  <span class="hljs-comment">//定义节点cur指向链表头结点head</span><br>        <span class="hljs-type">int</span> add = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">nullptr</span> || l2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> n1 = l1 ? l1-&gt;val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> n2 = l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> sum = n1+n2+add;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum%<span class="hljs-number">10</span>);<br>            cur = cur-&gt;next;<br>            add = sum/<span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(l1)  l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span>(l2)  l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(add &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(add);<br>        &#125;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-142-环形链表"><a href="#LC-142-环形链表" class="headerlink" title="LC 142.环形链表"></a>LC 142.环形链表</h2><h3 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h3><p>解决环形链表问题的两种方法：</p><ul><li>哈希表</li><li>快慢指针</li></ul><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：哈希表</strong></p><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_set&lt;ListNode*&gt; seen;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(seen.<span class="hljs-built_in">count</span>(head))<br>            &#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            seen.<span class="hljs-built_in">insert</span>(head);<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：快慢指针</strong></p><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/">https://leetcode.cn/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/</a></p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *slow = head, *fast = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>) &#123;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span> (fast-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                ListNode *ptr = head;<br>                <span class="hljs-keyword">while</span> (ptr != slow) &#123;<br>                    ptr = ptr-&gt;next;<br>                    slow = slow-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ptr;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树问题有关的深度优先搜索</title>
    <link href="/2022/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E6%9C%89%E5%85%B3%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E6%9C%89%E5%85%B3%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树问题有关的深度优先搜索"><a href="#二叉树问题有关的深度优先搜索" class="headerlink" title="二叉树问题有关的深度优先搜索"></a>二叉树问题有关的深度优先搜索</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>跟着Bilibili上别人总结的一些算法刷题模板和思路总结来刷题效率要高很多！Bilibili上有很多优质的算法视频同一类型的题目都放在一起讲，总结的也非常nice！🧐</p><h3 id="算法应用场景"><a href="#算法应用场景" class="headerlink" title="算法应用场景"></a>算法应用场景</h3><blockquote><p>深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次.</p></blockquote><ul><li>二叉树有关的问题</li><li>需要从根节点遍历到末尾叶子节点</li></ul><p>常见题型</p><p>满足（最大，最小，某种要求）的深度、路径、节点和……</p><h3 id="DFS思路"><a href="#DFS思路" class="headerlink" title="DFS思路"></a>DFS思路</h3><ol><li><p><strong>创建结果存储变量，初始化当前结果</strong></p></li><li><p><strong>设计递归函数</strong></p><p>函数执行过程：</p><ul><li>若到达结尾，则返回</li><li>若未到达结尾，则更新当前结果</li><li>若到达末尾叶子节点，进行最优结果更新</li><li>分别对当前节点的左/右叶子节点调用递归函数</li></ul></li><li><p><strong>开始调用递归函数</strong></p></li></ol><p>DFS代码模板（JS版）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dfsTemplate</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-comment">//存储最终结果</span><br>    <span class="hljs-keyword">let</span> res;<br>    <span class="hljs-comment">//初始化当前结果</span><br>    <span class="hljs-keyword">let</span> start;<br>    <span class="hljs-comment">//构造递归函数dfs,通常参数为当前节点和当前结果</span><br>    <span class="hljs-keyword">let</span> dfs = <span class="hljs-keyword">function</span> (<span class="hljs-params">node, currentResult</span>) &#123;<br>        <span class="hljs-comment">//终止条件返回判断</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//更新当前结果currentResult</span><br><br>        <span class="hljs-comment">//若到达末尾叶子结点，进行最优结果更新</span><br>        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//update res</span><br>        &#125;<br>        <span class="hljs-comment">//左右子树递归</span><br>        <span class="hljs-title function_">dfs</span>(node.<span class="hljs-property">left</span>, currentResult);<br>        <span class="hljs-title function_">dfs</span>(node.<span class="hljs-property">right</span>, currentResult);<br>    &#125;<br>    <span class="hljs-title function_">dfs</span>(root, start);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>相关题目：</p><ul><li>LeetCode 104：二叉树的最大深度</li><li>LeetCode 111：二叉树的最小深度</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 5.最长回文子串 动态规划</title>
    <link href="/2022/05/18/LC%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E5%AD%90%E6%96%87%E4%B8%B2/"/>
    <url>/2022/05/18/LC%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E5%AD%90%E6%96%87%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-5-最长回子文串"><a href="#LC-5-最长回子文串" class="headerlink" title="LC 5.最长回子文串"></a>LC 5.最长回子文串</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>动态规划的题目很少做，最近刷几道滑动窗口的题之后就去练动态规划的题目。</p><p>动态规划类的题目重点就是动态转移方程和边界条件。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：中心扩散法</strong></p><p><strong>方法2：动态规划</strong></p><p>定义二维数组dp[length][length]，如果dp[left][right]为true，则表示字符串从left到right是回文子串，如果dp[left][right]为false，则表示字符串从left到right不是回文子串。</p><p>如果dp[left+1][right-1]为true，我们判断s.[left]和s.[right]是否相等，如果相等，那么dp[left][right]肯定也是回文子串，否则dp[left][right]一定不是回文子串。</p><p>所以我们可以找出递推公式</p><p> dp[left][right]=s.[left]==s.[right]&amp;&amp;dp[left+1][right-1]</p><p>有了递推公式，还要确定边界条件：</p><p>如果s.[left]!=s.[right]，那么字符串从left到right是不可能构成子串的，直接跳过即可。</p><p>如果s.[left]==s.[right]，字符串从left到right能不能构成回文子串还需要进一步判断</p><ul><li>如果left==right，也就是说只有一个字符，我们认为他是回文子串。即dp[left][right]=true（left==right）</li><li>如果right-left&lt;=2，类似于”aa”，或者”aba”，我们认为他是回文子串。即dp[left][right]=true（right-left&lt;=2）</li><li>如果right-left&gt;2，我们只需要判断dp[left+1][right-1]是否是回文子串，才能确定dp[left][right]是否为true还是false。即dp[left][right]=dp[left+1][right-1]</li></ul><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//边界条件判断</span><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)  <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;  <span class="hljs-comment">//最长回文串开始的位置</span><br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">1</span>; <span class="hljs-comment">//最长回文串的长度</span><br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(len));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=<span class="hljs-number">1</span>; right&lt;len; right++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left=<span class="hljs-number">0</span>; left&lt;right; left++)<br>            &#123;<br>                <span class="hljs-comment">//如果两种字符不相同，肯定不能构成回文子串</span><br>                <span class="hljs-keyword">if</span>(s[left] != s[right])  <span class="hljs-keyword">continue</span>;<br>                <br>                <span class="hljs-keyword">if</span>(left == right)&#123;<br>                    dp[left][right] = <span class="hljs-literal">true</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(right-left &lt;= <span class="hljs-number">2</span>)&#123;<br>                    dp[left][right] = <span class="hljs-literal">true</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[left+<span class="hljs-number">1</span>][right<span class="hljs-number">-1</span>])&#123;<br>                    dp[left][right] = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[left][right] &amp;&amp; right-left+<span class="hljs-number">1</span> &gt; maxlen)<br>                &#123;<br>                    start = left;<br>                    maxlen = right-left+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//截取最长的回文子串</span><br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start,maxlen);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-JDBC</title>
    <link href="/2022/05/16/Java-JDBC/"/>
    <url>/2022/05/16/Java-JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC与MySQL数据库"><a href="#JDBC与MySQL数据库" class="headerlink" title="JDBC与MySQL数据库"></a>JDBC与MySQL数据库</h1><h2 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1 | JDBC"></a>1 | JDBC</h2><h3 id="JDBC（Java-DataBase-Connectivity）"><a href="#JDBC（Java-DataBase-Connectivity）" class="headerlink" title="JDBC（Java DataBase Connectivity）"></a>JDBC（Java DataBase Connectivity）</h3><ul><li>是用于执行SQL语句的Java应用程序接口，由一组用Java语言编写的类与接口 组成，是一种底层API</li><li>使开发人员可以用纯Java语言编写完整的数据库应用程序</li><li>用JDBC写的程序能够自动地将SQL语句传送给几乎任何一种数据库管理系统 （DBMS）</li><li>是一种规范，它让各数据库厂商为Java程序员提供标准的数据库访问类和接口 ，这样就使得独立于DBMS的Java应用开发工具和产品成为可能</li><li>隔离了Java与不同数据库之间的对话，使得程序员只须写一遍程序就可让它在任何数据库管理系统平台上运</li><li>使用已有的SQL标准，并支持其它数据库连接标准，如与ODBC之间的桥接</li></ul><p><strong>使用 JDBC可以进行如下的操作</strong> </p><ul><li>与一个数据库建立连接</li><li>向已连接的数据库发送SQL语句 </li><li>处理SQL语句返回的结果值</li></ul><h3 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h3><ul><li>是一组由Java语言编写的类和接口，包含在java.sql和javax.sql两个包中<ul><li>java.sql为核心包，这个包包含于J2SE中</li><li>javax.sql包扩展了JDBC API的功能，成为了J2EE的一个基本组成部分</li></ul></li><li>可分为两个层次<ul><li>面向底层的JDBC Driver API：主要是针对数据库厂商开发数据库底层驱动程序使用</li><li>面向程序员的JDBC API</li></ul></li></ul><p><img src="http://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220517130904.png" alt="应用程序通过JDBC API和底层的JDBC Driver API打交道"></p><h3 id="ODBC（-Open-Database-Connectivity-）"><a href="#ODBC（-Open-Database-Connectivity-）" class="headerlink" title="ODBC（ Open Database Connectivity ）"></a>ODBC（ Open Database Connectivity ）</h3><ul><li>由微软公司提出，用于在数据库管理系统(DBMS)中存取数据</li><li>是一套用C语言实现的访问数据库的API</li><li>通过ODBC API，应用程序可以存取保存在多种不同数据库管理系统（DBMS） 中的数据，而不论每个DBMS使用了何种数据存储格式和编程接口</li><li>对于没有提供JDBC驱动的数据库，从Java程序调用本地的C程序访问数据库会 带来一系列安全性、完整性、健壮性等方面的问题，因而通过JDBC-ODBC桥 来访问没有提供JDBC接口的数据库是一个常用的方案</li></ul><h2 id="2-JDBC-API中重要的接口和类"><a href="#2-JDBC-API中重要的接口和类" class="headerlink" title="2 | JDBC API中重要的接口和类"></a>2 | JDBC API中重要的接口和类</h2><table><thead><tr><th align="left">名称</th><th align="center">功能</th></tr></thead><tbody><tr><td align="left">DriverManager</td><td align="center">调入驱动程序</td></tr><tr><td align="left">Connection</td><td align="center">代表了对特定数据库的连接</td></tr><tr><td align="left">Statement</td><td align="center">基于Connection执行SQL语句</td></tr><tr><td align="left">PreparedStatement</td><td align="center">基于Connection执行带参数的SQL语句</td></tr><tr><td align="left">ResultSet</td><td align="center">保存查询语句得到的结果集</td></tr></tbody></table><h2 id="3-使用JDBC访问数据库的步骤"><a href="#3-使用JDBC访问数据库的步骤" class="headerlink" title="3 | 使用JDBC访问数据库的步骤"></a>3 | 使用JDBC访问数据库的步骤</h2><ul><li>设置环境，引入相应的JDBC类</li><li>选择合适的JDBC驱动程序并加载</li><li>分配一个Connection对象</li><li>分配一个Statement对象</li><li>用该Statement对象进行查询等操作</li><li>若查询则从返回的ResultSet对象中获取数据</li><li>关闭连接</li></ul><h2 id="4-通过JDBC-ODBC访问数据库"><a href="#4-通过JDBC-ODBC访问数据库" class="headerlink" title="4 | 通过JDBC-ODBC访问数据库"></a>4 | 通过JDBC-ODBC访问数据库</h2><ol><li><h3 id="设置环境，引入相应的JDBC类"><a href="#设置环境，引入相应的JDBC类" class="headerlink" title="设置环境，引入相应的JDBC类"></a><strong>设置环境，引入相应的JDBC类</strong></h3><p>在Java程序中引入相应的类和包。访问数据库使用的JDBC API在 java.sql包中，因此需要将该包引入程序。 import java.sql.*;</p></li><li><h3 id="选择DBMS驱动程序"><a href="#选择DBMS驱动程序" class="headerlink" title="选择DBMS驱动程序"></a><strong>选择DBMS驱动程序</strong></h3><ul><li><p>用Class.forName方法显式装载驱动程序</p><p>Class.forName(“com.mysql.cj.jdbc.Driver”);</p></li><li><p>执行后自动创建一个驱动器类的实例，并自动调用驱动器管理器DriverManager类中的RegisterDriver方法来注册它</p></li><li><p>需要注意的是，如果驱动器类有可能不存在，使用此方法就可能会抛出 ClassNotFoundException异常，因此需要捕获这个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><h3 id="创建一个Connection对象连接到数据库"><a href="#创建一个Connection对象连接到数据库" class="headerlink" title="创建一个Connection对象连接到数据库"></a>创建一个Connection对象连接到数据库</h3><ul><li><p>Connection对象代表了与指定数据库的连接，可以调用 DriverManager.getConnection()方法创建，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,username,password);<br></code></pre></td></tr></table></figure></li><li><p>DriverManager类位于JDBC的管理层，作用于用户和驱动程序之间。它负责跟 踪在一个系统中所有可用的JDBC驱动程序，并在数据库和相应驱动程序之间 建立连接</p></li></ul></li><li><h3 id="创建一个Statement对象执行SQL语句"><a href="#创建一个Statement对象执行SQL语句" class="headerlink" title="创建一个Statement对象执行SQL语句"></a>创建一个Statement对象执行SQL语句</h3><p>建立数据库的连接后，就可以对数据库进行操作了，一般包括三个步骤：</p><ul><li>使用Connection对象创建Statement对象</li><li>使用Statement对象执行SQL命令</li><li>从上一步骤返回的ResultSet对象中提取执行结果</li></ul><p><strong>Connection类有3个方法可用来创建向数据库发送SQL语句的 Statement对象：</strong></p><ul><li>createStatement：创建向数据库发送SQL语句的Statement对象，用于简单的SQL语句 Statement stmt = conn.createStatement();</li><li>prepareStatement：创建向数据库发送SQL语句的PreparedStatement对象，用于带有一个或多个参数的SQL 语句。在SQL语句执行前，这些参数将被赋值</li><li>prepareCall：创建向数据库发送SQL语句的CallableStatement对象，用于调用数据库中的存储过程</li></ul></li><li><h3 id="使用Statement对象执行语句"><a href="#使用Statement对象执行语句" class="headerlink" title="使用Statement对象执行语句"></a>使用Statement对象执行语句</h3><p><strong>Statement 对象提供了三种执行 SQL 语句的方法，使用哪一个方法由 SQL 语 句所产生的内容决定</strong></p><ul><li><p>executeQuery：用于产生单个结果集的语句，例如 SELECT 语句 ResultSet rs = stmt.executeQuery(“select * from user”);</p></li><li><p>executeUpdate：用于执行 INSERT、UPDATE 或 DELETE 语句，以及 CREATE TABLE stmt.executeUpdate(“DELETE FROM Person WHERE Name=’李四’”);</p><p>返回值是一个整数，表示受影响的行数（即更新计数），比如修改了多少行、删除了多少行等。对 于 CREATE TABLE 等语句，因不涉及到行的操作，所以executeUpdate的返回值总为零</p></li><li><p>Execute：用于执行返回多个结果集（ResultSet 对象）、多个更新计数或二者组合的语句。例如执行某个已存 储过程或动态执行SQL，这时有可能出现多个结果的情</p></li></ul></li><li><h3 id="从返回的ResultSet对象中获取相应的数据"><a href="#从返回的ResultSet对象中获取相应的数据" class="headerlink" title="从返回的ResultSet对象中获取相应的数据"></a>从返回的ResultSet对象中获取相应的数据</h3><p>ResultSet中的内容类似二维表格，是以“流”的方式按行访问的</p><ul><li><p>使用next()方法访问行：ResultSet中有一个游标，指向当前访问的 行；方法next的功能是将游标下移一行。即：每次调用next方法后， 游标会自动下移一行。</p></li><li><p>使用get类型()方法访问列：使用相应类型的getXXX()方法可以从当 前行指定列中提取不同类型的数据。例如：提取文本类型数据时就 要用getString方法</p></li><li><p>允许使用列名或列序号作为方法的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> rs.getString(“name”);<span class="hljs-comment">//提取name列</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-number">2</span>); <span class="hljs-comment">//提取第2列</span><br></code></pre></td></tr></table></figure></li></ul></li><li><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a><strong>关闭连接</strong></h3><p>数据库连接资源是宝贵的，应当在操作数据库后及时释放。</p><ul><li>stat.close(); //关闭语句</li><li>conn.close(); //关闭连接</li></ul></li></ol><p>通过JDBC-ODBC访问数据库实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*; <span class="hljs-comment">//①引入JDBC类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException,SQLException &#123;<br><span class="hljs-comment">//②加载驱动</span><br>Class.forName(<span class="hljs-string">&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;</span>); <br><span class="hljs-comment">//③创建连接</span><br>Connection conn=DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:odbc:StudentDB&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>); <br><span class="hljs-comment">//④创建Statment对象</span><br><span class="hljs-type">Statement</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> conn.createStatement(); <br><span class="hljs-comment">//⑤执行SQL语句</span><br>stat.executeUpdate(<span class="hljs-string">&quot;insert into Students(id,name,age) values (&#x27;1&#x27;,&#x27;张三&#x27;,&#x27;16&#x27;)&quot;</span>);<br>stat.executeUpdate(<span class="hljs-string">&quot;insert into Students(id,name,age) values (&#x27;2&#x27;,&#x27;李四&#x27;,&#x27;16&#x27;)&quot;</span>);<br>stat.executeUpdate(<span class="hljs-string">&quot;insert into Students(id,name,age) values (&#x27;3&#x27;,&#x27;王五&#x27;,&#x27;16&#x27;)&quot;</span>);<br>stat.executeUpdate(<span class="hljs-string">&quot;DELETE FROM students WHERE name=&#x27;李四&#x27;&quot;</span>);<br>stat.executeUpdate(<span class="hljs-string">&quot;update students set age=&#x27;20&#x27; WHERE name=&#x27;王五&#x27;&quot;</span>);<br><span class="hljs-comment">//⑥SQL查询</span><br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stat.executeQuery(<span class="hljs-string">&quot;select id,name from students order by id&quot;</span>);<br><span class="hljs-comment">//遍历ResultSet</span><br><span class="hljs-keyword">while</span> (rs.next())<br>&#123;<br>System.out.println(rs.getInt(<span class="hljs-string">&quot;id&quot;</span>)+ <span class="hljs-string">&quot; &quot;</span> + rs.getString(<span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-comment">//⑦关闭连接</span><br>stat.close();<br>conn.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-用纯JDBC驱动程序访问数据库"><a href="#5-用纯JDBC驱动程序访问数据库" class="headerlink" title="5 | 用纯JDBC驱动程序访问数据库"></a>5 | 用纯JDBC驱动程序访问数据库</h2><ol><li><h3 id="引入JDBC类"><a href="#引入JDBC类" class="headerlink" title="引入JDBC类"></a>引入JDBC类</h3><p>在Java程序中引入相应的类和包。访问数据库使用的JDBC API在 java.sql包中，因此需要将该包引入程序。 import java.sql.*;</p></li><li><h3 id="加载DBMS驱动程序"><a href="#加载DBMS驱动程序" class="headerlink" title="加载DBMS驱动程序"></a>加载DBMS驱动程序</h3><ul><li><p>到数据库官网下载对应版本的数据库驱动程序包。</p></li><li><p>用Class.forName方法显式装载驱动程序</p><p>比如，Class.forName(“com.mysql.cj.jdbc.Driver”); </p><p>Class.forName(“oracle.jdbc.driver.OracleDriver”);</p></li></ul></li><li><h3 id="创建一个Connection对象连接到数据库-1"><a href="#创建一个Connection对象连接到数据库-1" class="headerlink" title="创建一个Connection对象连接到数据库"></a>创建一个Connection对象连接到数据库</h3><p>调用DriverManager.getConnection()方法创建Connection对象</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(“jdbc:mysql:<span class="hljs-comment">//localhost:3306/</span><br>mydata?user=root&amp;password=<span class="hljs-number">123</span>&amp;useSSL=<span class="hljs-literal">false</span>&amp;serverTimezone=UTC”);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection<br>(<span class="hljs-string">&quot;jdbc:oracle:thin:@192.168.1.102:1521:orcl&quot;</span>, <span class="hljs-string">&quot;spring&quot;</span>, <span class="hljs-string">&quot;spring&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><h3 id="创建一个Statement对象执行SQL语句-1"><a href="#创建一个Statement对象执行SQL语句-1" class="headerlink" title="创建一个Statement对象执行SQL语句"></a>创建一个Statement对象执行SQL语句</h3><p>建立数据库的连接后，就可以对数据库进行操作了，一般包括三个步骤：</p><ul><li>使用Connection对象创建Statement对象</li><li>使用Statement对象执行SQL命令</li><li>从上一步骤返回的ResultSet对象中提取执行结果</li></ul><p><strong>Connection类有3个方法可用来创建向数据库发送SQL语句的 Statement对象：</strong></p><ul><li>createStatement：创建向数据库发送SQL语句的Statement对象，用于简单的SQL语句 Statement stmt = conn.createStatement();</li><li>prepareStatement：创建向数据库发送SQL语句的PreparedStatement对象，用于带有一个或多个参数的SQL 语句。在SQL语句执行前，这些参数将被赋值</li><li>prepareCall：创建向数据库发送SQL语句的CallableStatement对象，用于调用数据库中的存储过程</li></ul></li><li><h3 id="使用Statement对象执行语句-1"><a href="#使用Statement对象执行语句-1" class="headerlink" title="使用Statement对象执行语句"></a>使用Statement对象执行语句</h3><p><strong>Statement 对象提供了三种执行 SQL 语句的方法，使用哪一个方法由 SQL 语 句所产生的内容决定</strong></p><ul><li><p>executeQuery：用于产生单个结果集的语句，例如 SELECT 语句 ResultSet rs = stmt.executeQuery(“select * from user”);</p></li><li><p>executeUpdate：用于执行 INSERT、UPDATE 或 DELETE 语句，以及 CREATE TABLE stmt.executeUpdate(“DELETE FROM Person WHERE Name=’李四’”);</p><p>返回值是一个整数，表示受影响的行数（即更新计数），比如修改了多少行、删除了多少行等。对 于 CREATE TABLE 等语句，因不涉及到行的操作，所以executeUpdate的返回值总为零</p></li><li><p>Execute：用于执行返回多个结果集（ResultSet 对象）、多个更新计数或二者组合的语句。例如执行某个已存 储过程或动态执行SQL，这时有可能出现多个结果的情</p></li></ul></li><li><h3 id="关闭连接-1"><a href="#关闭连接-1" class="headerlink" title="关闭连接"></a><strong>关闭连接</strong></h3><p>数据库连接资源是宝贵的，应当在操作数据库后及时释放。</p><ul><li>conn.close(); //关闭连接</li></ul></li></ol><p>用纯JDBC驱动程序访问MySQL8.0数据库实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseAccess</span> &#123;<br><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConn</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydata?</span><br><span class="hljs-string">user=root&amp;password=123&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;          <br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>conn = DriverManager.getConnection(url);<br>&#125; <br><span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">return</span> conn;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getStudentInfo</span><span class="hljs-params">(String sno)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> “select * from student where sno=?<span class="hljs-string">&quot;;</span><br><span class="hljs-string">try &#123;</span><br><span class="hljs-string">Connection conn = new DatabaseAccess().getConn();</span><br><span class="hljs-string">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="hljs-string">ps.setString(1, sno);</span><br><span class="hljs-string">ResultSet rs = ps.executeQuery();</span><br><span class="hljs-string">while( rs.next())</span><br><span class="hljs-string">System.out.println(rs.getString(“sno”) +rs.getString(“sname”);</span><br><span class="hljs-string">conn.close();</span><br><span class="hljs-string">&#125; </span><br><span class="hljs-string">catch (Exception e) &#123; </span><br><span class="hljs-string">e.printStackTrace(); </span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="6-使用预处理语句"><a href="#6-使用预处理语句" class="headerlink" title="6 | 使用预处理语句"></a>6 | 使用预处理语句</h2><ul><li>使用PreparedStatement类对象的prepareStatement(String sql)方 法对SQL语句进行预编译处理，生成该数据库底层的内部命令。</li><li>该用法支持带参数的SQL语句的执行，这给SQL语句的执行带来很大 的灵活性。</li><li>使用通配符?(英文的问号)，代替数据表字段的值。需要在SQL执行之 前设置通配符代表的具体值。</li><li>设置通配符?的值的常用方法：<ul><li>void setDate(int parameterIndex, Date x);</li><li>void setDouble(int parameterIndex, double x);</li><li>void setFloat(int parameterIndex, float x);</li><li>void setInt(int parameterIndex, int x);</li><li>void setLong(int parameterIndex, long x);</li><li>void setString(int parameterIndex, String x);</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ex7_9</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>String DBDriver=<span class="hljs-string">&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;</span>;<br>String connectionStr=<span class="hljs-string">&quot;jdbc:odbc:studentDB&quot;</span>;<br>Class.forName(DBDriver);<br>Connection con=DriverManager.getConnection(connectionStr,“admin<span class="hljs-string">&quot;,“admin&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; UPDATE person SET salary=? WHERE name=? &quot;</span>; <span class="hljs-comment">//设置了2个参数</span><br>PreparedStatement pstmt=con. prepareStatement(sql) ;<br>pstmt.setInt(<span class="hljs-number">1</span>,<span class="hljs-number">5000</span>); <span class="hljs-comment">//为第1个参数赋值，根据参数类型的不同调用不同方法</span><br>pstmt.setString(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;张三&quot;</span>) ; <span class="hljs-comment">//为第2个参数赋值</span><br>pstmt.executeUpdate() ; <span class="hljs-comment">//执行SQL语句</span><br>con.close(); <span class="hljs-comment">//关闭连接</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-事物"><a href="#7-事物" class="headerlink" title="7 | 事物"></a>7 | 事物</h2><ul><li><p>事务由一组SQL语句组成。事务处理指应用程序保证事务中的SQL语 句要么全部执行，要么一个都不执行。</p></li><li><p>JDBC事务处理步骤：</p><ul><li>用setAutoCommit(boolean b)方法关闭自动提交模式</li><li>用commit()方法处理事务</li><li>用rollback()方法处理事务回滚</li></ul></li><li><p>setAutoCommit(boolean b) 方法：</p><p>用Connection的对象调用该方法设置提交模式</p><ul><li>先关闭自动提交模式 ： conn.setAutoCommit(false);</li><li>然后获取Statement对象st： st=conn.createStatement();</li></ul></li><li><p>commit()方法处理事务</p><p>用Connection的对象调用该方法让事务中的全部SQL语句生效 </p><ul><li>conn.commit();</li></ul></li><li><p>rollback()方法进行事务回滚</p><p>用Connection的对象调用该方法撤销事务中已经成功执行的对数据库进行更新 操作的SQL语句，将数据恢复到commit()方法执行之前的状态。</p><ul><li>conn.rollback();</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Eclipse连接MySQL数据库</title>
    <link href="/2022/05/16/%E4%BD%BF%E7%94%A8Eclipse%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/05/16/%E4%BD%BF%E7%94%A8Eclipse%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="使用Eclipse连接MySQL数据库"><a href="#使用Eclipse连接MySQL数据库" class="headerlink" title="使用Eclipse连接MySQL数据库"></a>使用Eclipse连接MySQL数据库</h2><h3 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h3><h3 id="Eclipse项目-gt-构建路径-gt-库-gt-添加外部JAR"><a href="#Eclipse项目-gt-构建路径-gt-库-gt-添加外部JAR" class="headerlink" title="Eclipse项目 -&gt; 构建路径 -&gt; 库 -&gt; 添加外部JAR"></a>Eclipse项目 -&gt; 构建路径 -&gt; 库 -&gt; 添加外部JAR</h3><blockquote><p>外部JAR为刚刚下载驱动mysql-connector-java-8.0.27中的mysql-connector-java-8.0.27.jar文件</p></blockquote><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/QQ%E6%88%AA%E5%9B%BE20220516103228.png?raw=true" alt="QQ截图20220516103228.png"></p><h3 id="新建数据库-gt-新建表"><a href="#新建数据库-gt-新建表" class="headerlink" title="新建数据库-&gt;新建表"></a>新建数据库-&gt;新建表</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">测试Eclipse与MySQL数据库的连接</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> student;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testMysqlConnection</span> &#123;<br><span class="hljs-comment">//url中localhost:3306后面要加的是自己所要连接的数据库名</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/student_manage?serverTimezone=GMT&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,username,password);<br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> connect.createStatement();<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(<span class="hljs-string">&quot;select * from user&quot;</span>);<br><span class="hljs-keyword">while</span>(rs.next()) &#123;<br>System.out.print(<span class="hljs-string">&quot;id:&quot;</span>+rs.getString(<span class="hljs-string">&quot;id&quot;</span>)+<span class="hljs-string">&quot; &quot;</span>);<br>System.out.print(<span class="hljs-string">&quot;name:&quot;</span>+rs.getString(<span class="hljs-string">&quot;name&quot;</span>)+<span class="hljs-string">&quot; &quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;pwd:&quot;</span>+rs.getString(<span class="hljs-string">&quot;pwd&quot;</span>)+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试成功：输出数据库中的内容</p><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/QQ%E6%88%AA%E5%9B%BE20220516103834.png?raw=true" alt="QQ截图20220516103834.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Java实现简单的区块链</title>
    <link href="/2022/05/14/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <url>/2022/05/14/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。所谓共识机制是区块链系统中实现不同节点之间建立信任、获取权益的数学算法 。</p></blockquote><h2 id="用Java创建区块链"><a href="#用Java创建区块链" class="headerlink" title="用Java创建区块链"></a>用Java创建区块链</h2><p>实现功能</p><ul><li>有很多区块组成用来存储数据</li><li>有数字签名让你的区块链链接在一起</li><li>需要挖矿的工作量证明新的区块</li><li>可以用来检查数据是否是有效的同时是未经篡改的</li></ul><h3 id="创建区块链"><a href="#创建区块链" class="headerlink" title="创建区块链"></a>创建区块链</h3><p>区块链就是一串或者是一系列区块的集合，类似于链表的概念，每个区块都指向于后面一个区块，然后顺序的连接在一起。在区块链中的每一个区块都存放了很多很有价值的信息，区块中内容主要包括三个部分：自己的数字签名，上一个区块的数字签名，还有一切需要加密的数据（这些数据在比特币中就相当于是交易的信息，它是加密货币的本质）。每个数字签名不但证明了自己是特有的一个区块，而且指向了前一个区块的来源，让所有的区块在链条中可以串起来，而数据就是一些特定的信息，可以按照业务逻辑来保存业务数据。</p><p><img src="https://raw.githubusercontent.com/longfeizheng/longfeizheng.github.io/master/images/qukuai/qukuai01.png" alt="区块链示意图"></p><p>这里的hash指的就是数字签名</p><p>所以每一个区块不仅包含前一个区块的hash值，同时包含自身的一个hash值，自身的hash值是通过之前的hash值和数据data通过hash计算出来的。如果前一个区块的数据一旦被篡改了，那么前一个区块的hash值也会同样发生变化（因为数据也被计算在内），这样也就导致了所有后续的区块中的hash值。所以计算和比对hash值会让我们检查到当前的区块链是否是有效的，也就避免了数据被恶意篡改的可能性，因为篡改数据就会改变hash值并破坏整个区块链。</p><p><strong>定义区块链的类快</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Block</span> &#123;<br><span class="hljs-keyword">public</span> String hash;  <span class="hljs-comment">//当前区块的hash</span><br><span class="hljs-keyword">public</span> String previousHash;  <span class="hljs-comment">//前一个区块的hash</span><br><span class="hljs-keyword">private</span> String data; <span class="hljs-comment">//当前区块的数据</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeStamp; <br><span class="hljs-comment">//区块构造</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Block</span><span class="hljs-params">(String data,String previousHash )</span> &#123;<br><span class="hljs-built_in">this</span>.data = data;<br><span class="hljs-built_in">this</span>.previousHash = previousHash;<br><span class="hljs-built_in">this</span>.timeStamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getTime();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本块包含String hash，它将保存我们的数字签名。变量previoushash保存前一个块的hash和String data来保存我们的块数据</p><h3 id="创建数字签名"><a href="#创建数字签名" class="headerlink" title="创建数字签名"></a>创建数字签名</h3><p>区块链存储数据的优点在于数据的加密性，Java方式可以实现的加密方式有很多，如BASE、MD、RSA、SHA等等。选用了SHA256这种加密方式，SHA（Secure Hash Algorithm）安全散列算法，因为这种算法的特点是数据的少量更改会在Hash值中产生不可预知的大量更改，hash值用作表示大量数据的固定大小的唯一值，而SHA256算法的hash值大小为256位。之所以选用SHA256是因为它的大小正合适，一方面产生重复hash值的可能性很小，另一方面在区块链实际应用过程中，有可能会产生大量的区块，而使得信息量很大，那么256位的大小就比较恰当了。</p><p>创建一个StringUtil方法来方便调用SHA256算法</p><blockquote><p>所有的输入调用此方法后均会生成一个独一无二的hash值（数字签名），而这个hash值在区块链中是非常重要的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtil</span> &#123;<br><span class="hljs-comment">//将Sha256应用于字符串并返回结果</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">applySha256</span><span class="hljs-params">(String input)</span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">MessageDigest</span> <span class="hljs-variable">digest</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;SHA-256&quot;</span>);        <br><span class="hljs-comment">//将sha256应用到我们的输入</span><br><span class="hljs-type">byte</span>[] hash = digest.digest(input.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));        <br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">hexString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(); <span class="hljs-comment">// 这将包含哈希十六进制</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; hash.length; i++) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">hex</span> <span class="hljs-operator">=</span> Integer.toHexString(<span class="hljs-number">0xff</span> &amp; hash[i]);<br><span class="hljs-keyword">if</span>(hex.length() == <span class="hljs-number">1</span>) hexString.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>hexString.append(hex);<br>&#125;<br><span class="hljs-keyword">return</span> hexString.toString();<br>&#125;<br><span class="hljs-keyword">catch</span>(Exception e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Block类中应用 方法 applySha256 方法，其主要的目的就是计算hash值，我们计算的hash值应该包括区块中所有我们不希望被恶意篡改的数据，在我们上面所列的Block类中就一定包括previousHash，data和timeStamp。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">calculateHash</span><span class="hljs-params">()</span> </span>&#123;<br>String calculatedhash = StringUtil.<span class="hljs-built_in">applySha256</span>( <br>previousHash +<br>Long.<span class="hljs-built_in">toString</span>(timeStamp) +<br>data <br>);<br><span class="hljs-keyword">return</span> calculatedhash;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后把这个方法加入到Block的构造函数中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Block</span><span class="hljs-params">(String data,String previousHash )</span> &#123;<br><span class="hljs-built_in">this</span>.data = data;<br><span class="hljs-built_in">this</span>.previousHash = previousHash;<br><span class="hljs-built_in">this</span>.timeStamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getTime();<br><span class="hljs-built_in">this</span>.hash = calculateHash(); <span class="hljs-comment">//确保我们在设置其他值之后执行此操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在主方法中让我们创建一些区块，并把其hash值打印出来。</p><p>第一个块称为创世纪区块，因为它是头区块，所以我们只需输入“0”作为前一个块的previous hash。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockChainTest</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-type">Block</span> <span class="hljs-variable">genesisBlock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Block</span>(<span class="hljs-string">&quot;Hi im the first block&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Hash for block 1 : &quot;</span> + genesisBlock.hash);<br><br><span class="hljs-type">Block</span> <span class="hljs-variable">secondBlock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Block</span>(<span class="hljs-string">&quot;Yo im the second block&quot;</span>,genesisBlock.hash);<br>System.out.println(<span class="hljs-string">&quot;Hash for block 2 : &quot;</span> + secondBlock.hash);<br><br><span class="hljs-type">Block</span> <span class="hljs-variable">thirdBlock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Block</span>(<span class="hljs-string">&quot;Hey im the third block&quot;</span>,secondBlock.hash);<br>System.out.println(<span class="hljs-string">&quot;Hash for block 3 : &quot;</span> + thirdBlock.hash);<br><br>&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印结果值：</span><br><span class="hljs-comment">Hash for block 1: 3d7404e05d96d8060feac1c554db5e06fcf7de65d6926698172f8e63e1c349c0</span><br><span class="hljs-comment">Hash for block 2: afbab7ab1e6c643581378312a4f83a021d0c2a9aa278e9bab83ce8e6eab5c220</span><br><span class="hljs-comment">Hash for block 3: 236206ef1a6534d8e53daaa33b9b6895cdbfbbc3b31fa2a52920207840f44984</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>每一个区块都必须要有自己的数据签名即hash值，这个hash值依赖于自身的信息（data）和上一个区块的数字签名（previousHash），但这个还不是区块链，下面存储区块到数组中，引入gson包，目的是可以用json方式查看整个一条区块链结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> com.google.gson.GsonBuilder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoobChain</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Block&gt; blockchain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Block&gt;(); <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//add our blocks to the blockchain ArrayList:</span><br>blockchain.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Block</span>(<span class="hljs-string">&quot;Hi im the first block&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>));<br>blockchain.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Block</span>(<span class="hljs-string">&quot;Yo im the second block&quot;</span>,blockchain.get(blockchain.size()-<span class="hljs-number">1</span>).hash)); <br>blockchain.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Block</span>(<span class="hljs-string">&quot;Hey im the third block&quot;</span>,blockchain.get(blockchain.size()-<span class="hljs-number">1</span>).hash));<br><br><span class="hljs-type">String</span> <span class="hljs-variable">blockchainJson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonBuilder</span>().setPrettyPrinting().create().toJson(blockchain);<br>System.out.println(blockchainJson);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样的输出结构就是我们想要的区块链了</p><h3 id="检查区块链的完整性"><a href="#检查区块链的完整性" class="headerlink" title="检查区块链的完整性"></a>检查区块链的完整性</h3><p><strong>检测原因</strong></p><p>我们就在一个主函数中创建区块链中的区块，所以不存在被修改的可能性，但是区块链中的一个核心概念就是去中心化，每一个区块可能是在网络中的某一个节点中产生的，所以很有可能某个节点把自己节点中的数据修改了，那么根据上述的理论数据改变会导致整个区块链的破裂，也就是区块链就无效了。</p><p><strong>检测方法</strong></p><p>在主方法中增加一个isChainValid()方法，目的是循环区块链中的所有区块并且比较hash值，这个方法用来检查hash值是否是于计算出来的hash值相等，同时previousHash值是否和前一个区块的hash值相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">isChainValid</span><span class="hljs-params">()</span> &#123;<br>Block currentBlock; <br>Block previousBlock;<br><br><span class="hljs-comment">//通过区块链循环检查哈希值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt; blockchain.size(); i++) &#123;<br>currentBlock = blockchain.get(i);<br>previousBlock = blockchain.get(i-<span class="hljs-number">1</span>);<br><span class="hljs-comment">//比较注册哈希和计算哈希</span><br><span class="hljs-keyword">if</span>(!currentBlock.hash.equals(currentBlock.calculateHash()) )&#123;<br>System.out.println(<span class="hljs-string">&quot;Current Hashes not equal&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//比较以前的散列和已注册的以前的散列</span><br><span class="hljs-keyword">if</span>(!previousBlock.hash.equals(currentBlock.previousHash) ) &#123;<br>System.out.println(<span class="hljs-string">&quot;Previous Hashes not equal&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>任何区块链中区块的改变都会导致这个函数返回false，也就证明了区块链无效了。</p><h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><p>这里我们要求挖矿者做工作量证明，具体的方式是在区块中尝试不同的参数值直到它的hash值是从一系列的0开始的。让我们添加一个名为nonce的int类型以包含在我们的calculatehash（）方法中，以及需要的mineblock（）方法。</p><p><strong>挖矿结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">Trying to Mine block <span class="hljs-number">1.</span>.. <br>Block Mined!!! : 00000dc50c2b12ab2a8e73b61289098d9c360292920b66f80989fa8b9d1d0521<br>Trying to Mine block <span class="hljs-number">2.</span>.. <br>Block Mined!!! : 0000093a60840937825f338ff864c8b15106bdb8ea238b41aed80d75b2b51aa1<br>Trying to Mine block <span class="hljs-number">3.</span>.. <br>Block Mined!!! : 0000000b531c080dcdced198df76b9830dcf77cac4e237346f336f0383e0713a<br><br>Blockchain is Valid: <span class="hljs-literal">true</span><br>[<br>  &#123;<br>    <span class="hljs-string">&quot;hash&quot;</span>: <span class="hljs-string">&quot;00000dc50c2b12ab2a8e73b61289098d9c360292920b66f80989fa8b9d1d0521&quot;</span>,<br>    <span class="hljs-string">&quot;previousHash&quot;</span>: <span class="hljs-string">&quot;0&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: <span class="hljs-string">&quot;first&quot;</span>,<br>    <span class="hljs-string">&quot;timeStamp&quot;</span>: <span class="hljs-number">1652526937377</span>,<br>    <span class="hljs-string">&quot;nonce&quot;</span>: <span class="hljs-number">824286</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;hash&quot;</span>: <span class="hljs-string">&quot;0000093a60840937825f338ff864c8b15106bdb8ea238b41aed80d75b2b51aa1&quot;</span>,<br>    <span class="hljs-string">&quot;previousHash&quot;</span>: <span class="hljs-string">&quot;00000dc50c2b12ab2a8e73b61289098d9c360292920b66f80989fa8b9d1d0521&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: <span class="hljs-string">&quot;second&quot;</span>,<br>    <span class="hljs-string">&quot;timeStamp&quot;</span>: <span class="hljs-number">1652526938380</span>,<br>    <span class="hljs-string">&quot;nonce&quot;</span>: <span class="hljs-number">1073541</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;hash&quot;</span>: <span class="hljs-string">&quot;0000000b531c080dcdced198df76b9830dcf77cac4e237346f336f0383e0713a&quot;</span>,<br>    <span class="hljs-string">&quot;previousHash&quot;</span>: <span class="hljs-string">&quot;0000093a60840937825f338ff864c8b15106bdb8ea238b41aed80d75b2b51aa1&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: <span class="hljs-string">&quot;third&quot;</span>,<br>    <span class="hljs-string">&quot;timeStamp&quot;</span>: <span class="hljs-number">1652526939678</span>,<br>    <span class="hljs-string">&quot;nonce&quot;</span>: <span class="hljs-number">1844033</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h2 id="用Java创建可交易的区块链"><a href="#用Java创建可交易的区块链" class="headerlink" title="用Java创建可交易的区块链"></a>用Java创建可交易的区块链</h2><p>实现功能</p><ul><li>创建一个简单的钱包</li><li>使用我们的区块链发送带签名的交易</li></ul><blockquote><p>创建一个基本的区块链后，但在区块链中存放的是一些无用的信息。用交易取代这些信息（我们的区块将能够保存多个交易），创建一个非常简单的加密货币,货币名字NoobCoin。</p><ul><li>导入 bounceycastle和GSON</li></ul></blockquote><h3 id="准备一个钱包"><a href="#准备一个钱包" class="headerlink" title="准备一个钱包"></a>准备一个钱包</h3><p>在加密货币中，在区块链作为交易时，货币所有权可以进行转移，每个参与者都有一个自己私有的地址来发送或者是收取货币。钱包可以存储这些地址。因此钱包就是可以在区块链上进行新交易的软件。类似于微信支付。</p><p><img src="https://raw.githubusercontent.com/longfeizheng/longfeizheng.github.io/master/images/qukuai/qukuai02.png"></p><p>创建一个钱包类来保存公钥和私钥：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">package noobchain;<br><span class="hljs-keyword">import</span> java.security.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wallet</span> &#123;<br><span class="hljs-keyword">public</span> PrivateKey privateKey;<br><span class="hljs-keyword">public</span> PublicKey publicKey;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>公钥和私钥究竟是起到什么作用呢，其实公钥的作用就是地址，你可以分享你的公钥给别人以此来获取付款，而你的私钥的作用是为了对交易进行签名，这样其他人就不可以花费你的金额除非它拥有你的私钥，所以对于每个人而言我们必须保护好我们的私钥，不能透露我们的私钥信息给其他人。同时在我们进行交易的时候我们也会同时发送我们的公钥由此来验证我们的签名是有效的而且没有数据被篡改。（可以理解为收款码和付款码）</p></blockquote><p>我们在密钥对KeyPair生成私有和公钥。我们将使用椭圆曲线加密来生成我们的密钥对KeyPair。让我们将generateKeyPair()方法添加到我们的钱包类中，并在构造函数中调用它:</p><blockquote><p>私钥用于签署我们不想被篡改的数据。公钥用于验证签名。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> noobchain;<br><span class="hljs-keyword">import</span> java.security.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wallet</span> &#123;<br><br><span class="hljs-keyword">public</span> PrivateKey privateKey;<br><span class="hljs-keyword">public</span> PublicKey publicKey;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Wallet</span><span class="hljs-params">()</span>&#123;<br>generateKeyPair();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateKeyPair</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">KeyPairGenerator</span> <span class="hljs-variable">keyGen</span> <span class="hljs-operator">=</span> KeyPairGenerator.getInstance(<span class="hljs-string">&quot;ECDSA&quot;</span>,<span class="hljs-string">&quot;BC&quot;</span>);<br><span class="hljs-type">SecureRandom</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> SecureRandom.getInstance(<span class="hljs-string">&quot;SHA1PRNG&quot;</span>);<br><span class="hljs-type">ECGenParameterSpec</span> <span class="hljs-variable">ecSpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ECGenParameterSpec</span>(<span class="hljs-string">&quot;prime192v1&quot;</span>);<br><span class="hljs-comment">// 初始化密钥生成器并生成KeyPair</span><br>keyGen.initialize(ecSpec, random);   <span class="hljs-comment">//256字节提供了可接受的安全级别</span><br>        <span class="hljs-type">KeyPair</span> <span class="hljs-variable">keyPair</span> <span class="hljs-operator">=</span> keyGen.generateKeyPair();<br>        <span class="hljs-comment">// 从keyPair设置公钥和私钥</span><br>        privateKey = keyPair.getPrivate();<br>        publicKey = keyPair.getPublic();<br>&#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="交易和数字签名"><a href="#交易和数字签名" class="headerlink" title="交易和数字签名"></a>交易和数字签名</h3><p>每笔交易将携带一定以下信息：</p><ol><li>资金付款人的公匙信息。</li><li>资金收款人的公匙信息。</li><li>被转移资金的金额。</li><li>输入，它是对以前的交易的引用，证明发送者有资金发送。</li><li>输出，显示交易中收款方相关地址数量。(这些输出被引用为新交易的输入)</li><li>一个加密签名，证明该交易是由地址的发送者是发送的，并且数据没有被更改。(阻止第三方机构更改发送的数量)</li></ol><p>创建这个新的交易类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.*;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br><br><span class="hljs-keyword">public</span> String transactionId; <span class="hljs-comment">// 包含事物的哈希</span><br><span class="hljs-keyword">public</span> PublicKey sender; <span class="hljs-comment">// 付款人地址/公钥</span><br><span class="hljs-keyword">public</span> PublicKey reciepient; <span class="hljs-comment">// 收款人地址/公钥</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">float</span> value;<br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] signature; <span class="hljs-comment">// 防止其他人花我们钱包里的钱</span><br><br><span class="hljs-keyword">public</span> ArrayList&lt;TransactionInput&gt; inputs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;TransactionInput&gt;();<br><span class="hljs-keyword">public</span> ArrayList&lt;TransactionOutput&gt; outputs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;TransactionOutput&gt;();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">sequence</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 生成了多少事务的粗略统计</span><br><br><span class="hljs-comment">// 构造: </span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Transaction</span><span class="hljs-params">(PublicKey from, PublicKey to, <span class="hljs-type">float</span> value,  ArrayList&lt;TransactionInput&gt; inputs)</span> &#123;<br><span class="hljs-built_in">this</span>.sender = from;<br><span class="hljs-built_in">this</span>.reciepient = to;<br><span class="hljs-built_in">this</span>.value = value;<br><span class="hljs-built_in">this</span>.inputs = inputs;<br>&#125;<br><br><span class="hljs-comment">// 计算事务散列(将用作其Id)</span><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">calulateHash</span><span class="hljs-params">()</span> &#123;<br>sequence++; <span class="hljs-comment">//增加序列以避免两个相同的事务具有相同的散列</span><br><span class="hljs-keyword">return</span> StringUtil.applySha256(<br>StringUtil.getStringFromKey(sender) +<br>StringUtil.getStringFromKey(reciepient) +<br>Float.toString(value) + sequence<br>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试钱包和签名"><a href="#测试钱包和签名" class="headerlink" title="测试钱包和签名"></a>测试钱包和签名</h3><p>简单的进行一些测试，在主方法中增加了一些新的变量也替换了之前在主方法中的一些内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.Security;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><span class="hljs-keyword">import</span> com.google.gson.GsonBuilder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoobChain</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Block&gt; blockchain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Block&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">difficulty</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Wallet walletA;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Wallet walletB;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//将block添加到区块链数组列表中</span><br>Security.addProvider(<span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.bouncycastle.jce.provider.BouncyCastleProvider()); <br><span class="hljs-comment">//创建钱包A和B</span><br>walletA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wallet</span>();<br>walletB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wallet</span>();<br><span class="hljs-comment">//测试公钥和私钥</span><br>System.out.println(<span class="hljs-string">&quot;Private and public keys:&quot;</span>);<br>System.out.println(StringUtil.getStringFromKey(walletA.privateKey));<br>System.out.println(StringUtil.getStringFromKey(walletA.publicKey));<br><span class="hljs-comment">//创建一个从A钱包到B钱包交易的测试</span><br><span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transaction</span>(walletA.publicKey, walletB.publicKey, <span class="hljs-number">5</span>, <span class="hljs-literal">null</span>);<br>transaction.generateSignature(walletA.privateKey);<br><span class="hljs-comment">//验证签名工作，并从公钥验证它</span><br>System.out.println(<span class="hljs-string">&quot;Is signature verified&quot;</span>);<br>System.out.println(transaction.verifiySignature());<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们将创建并验证输入和输出，并把交易保存到区块链中去。</p><h3 id="输入和输出1：如何验证货币是你的"><a href="#输入和输出1：如何验证货币是你的" class="headerlink" title="输入和输出1：如何验证货币是你的"></a>输入和输出1：如何验证货币是你的</h3><p>如果你拥有1比特币，你必须前面就得接收1比特币。比特币的账本不会在你的账户中增加一个比特币也不会从发送者那里减去一个比特币，发送者只能指向他/她之前收到过一个比特币，所以一个交易输出被创建用来显示一个比特币发送给你的地址（交易的输入指向前一个交易的输出）。</p><p><strong>你的钱包余额是所有未使用的交易输出的总和</strong></p><p>创建TransactionInput 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionInput</span> &#123;<br><span class="hljs-keyword">public</span> String transactionOutputId; <span class="hljs-comment">//Reference to TransactionOutputs -&gt; transactionId</span><br><span class="hljs-keyword">public</span> TransactionOutput UTXO; <span class="hljs-comment">//Contains the Unspent transaction output</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TransactionInput</span><span class="hljs-params">(String transactionOutputId)</span> &#123;<br><span class="hljs-built_in">this</span>.transactionOutputId = transactionOutputId;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个类将用于引用尚未使用的transactionoutput。transactionOutputId将用于查找相关的TransactionOutput，允许矿工检查您的所有权。</p></blockquote><p>创建TransactionOutputs类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.PublicKey;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionOutput</span> &#123;<br><span class="hljs-keyword">public</span> String id;<br><span class="hljs-keyword">public</span> PublicKey reciepient; <span class="hljs-comment">//钱的接收者</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">float</span> value; <span class="hljs-comment">//拥有钱的数量</span><br><span class="hljs-keyword">public</span> String parentTransactionId; <span class="hljs-comment">//创建此输出的事务的id</span><br><span class="hljs-comment">//构造</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TransactionOutput</span><span class="hljs-params">(PublicKey reciepient, <span class="hljs-type">float</span> value, String parentTransactionId)</span> &#123;<br><span class="hljs-built_in">this</span>.reciepient = reciepient;<br><span class="hljs-built_in">this</span>.value = value;<br><span class="hljs-built_in">this</span>.parentTransactionId = parentTransactionId;<br><span class="hljs-built_in">this</span>.id = StringUtil.applySha256(StringUtil.getStringFromKey(reciepient)+Float.toString(value)+parentTransactionId);<br>&#125;<br><br><span class="hljs-comment">//检查钱是否属于你</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMine</span><span class="hljs-params">(PublicKey publicKey)</span> &#123;<br><span class="hljs-keyword">return</span> (publicKey == reciepient);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>交易输出类将显示从交易中发送给每一方的最终金额。这些作为新交易中的输入参考，作为证明你可以发送的金额数量。</p><h3 id="输入和输出2：处理交易"><a href="#输入和输出2：处理交易" class="headerlink" title="输入和输出2：处理交易"></a>输入和输出2：处理交易</h3><p>区块链可能会收到很多交易，而区块链可能会非常长，因为必须查找并检查其输入，所以可能需要非常长的时间来处理新的交易。为了解决这个问题，我们保存了一个额外的集合称之为为使用的交易作为可用的输入,所以在主函数中增加一个集合称为UTXO。</p><p>在交易类中增加一个processTransaction方法，这个方法是把一切放在一起用来处理交易。</p><p>通过这种方法，我们执行一些检查以确保交易有效，然后收集输入并生成输出。最重要的是，最后，我们抛弃了输入在我们的UTXO列表，这就意味着一个可以使用的交易输出必须之前一定是输入，所以输入的值必须被完全使用，所以付款人必须改变它们自身的金额状态。</p><h3 id="添加交易到区块中"><a href="#添加交易到区块中" class="headerlink" title="添加交易到区块中"></a>添加交易到区块中</h3><p>现在已经有了一个有效的交易系统，需要把交易加入到我们的区块链中。把交易列表替换我们块中无用的数据，但是在一个单一的区块中可能存放了1000个交易，这就会导致大量的hash计算，在这里我们使用了交易的merkle root，增加一个帮助方法来创建merkle root在StringUtils类中。</p><p>在StringUtils类中创建getMerkleRoot方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getMerkleRoot</span><span class="hljs-params">(ArrayList&lt;Transaction&gt; transactions)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> transactions.size();<br>ArrayList&lt;String&gt; previousTreeLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-keyword">for</span>(Transaction transaction : transactions) &#123;<br>previousTreeLayer.add(transaction.transactionId);<br>&#125;<br>ArrayList&lt;String&gt; treeLayer = previousTreeLayer;<br><span class="hljs-keyword">while</span>(count &gt; <span class="hljs-number">1</span>) &#123;<br>treeLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt; previousTreeLayer.size(); i++) &#123;<br>treeLayer.add(applySha256(previousTreeLayer.get(i-<span class="hljs-number">1</span>) + previousTreeLayer.get(i)));<br>&#125;<br>count = treeLayer.size();<br>previousTreeLayer = treeLayer;<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">merkleRoot</span> <span class="hljs-operator">=</span> (treeLayer.size() == <span class="hljs-number">1</span>) ? treeLayer.get(<span class="hljs-number">0</span>) : <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">return</span> merkleRoot;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改Block类，需要注意的是还更新了Block构造函数，因为我们不再需要传递字符串数据，并将merkle root包含在计算哈希方法中。addTransaction方法用来增加交易，只有满足条件下才可以成功的在区块中增加交易。</p><p>实现了一个可交易的区块链。</p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>应该测试从钱包发送货币，更新区块链并进行有效性检查。但首先需要一种将新硬币引入混合的方法。有很多方法来创建新的硬币。在比特币区块链上，有很多方法可以创造新的比特币:矿工可以将交易包括在内，作为对每个矿工挖矿的奖励。但在这里我们只希望在创世纪区块中释放货币。就像比特币中一下，所以我们修改我们的主函数以达到下面的目的。</p><ol><li>创世纪区块发布100个货币给walletA</li><li>一个更新的链有效性检查，考虑到交易。</li><li>测试交易看是否一切正常。</li></ol><p>交易结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">Creating and Mining Genesis block... <br>Transaction Successfully added to Block<br>Block Mined!!! : 0002eb314ecaaeeb77ffd7f83d90ce7dc197dadd2ca5484bebd225bf6b81d3fc<br><br>WalletA<span class="hljs-string">&#x27;s balance is: 100.0</span><br><span class="hljs-string"></span><br><span class="hljs-string">WalletA is Attempting to send funds (40) to WalletB...</span><br><span class="hljs-string">Transaction Successfully added to Block</span><br><span class="hljs-string">Block Mined!!! : 000a29ee3221960020a4f382e728b08b02f1dcf6707bcc8a1499e29c3c03adf8</span><br><span class="hljs-string"></span><br><span class="hljs-string">WalletA&#x27;</span>s balance is: <span class="hljs-number">60.0</span><br>WalletB<span class="hljs-string">&#x27;s balance is: 40.0</span><br><span class="hljs-string"></span><br><span class="hljs-string">WalletA Attempting to send more funds (1000) than it has...</span><br><span class="hljs-string">#Not Enough funds to send transaction. Transaction Discarded.</span><br><span class="hljs-string">Block Mined!!! : 0008917b5fc51ea7eb74dd6295c20b744cd8d4f90db2fb4fd627c6c47eb7583a</span><br><span class="hljs-string"></span><br><span class="hljs-string">WalletA&#x27;</span>s balance is: <span class="hljs-number">60.0</span><br>WalletB<span class="hljs-string">&#x27;s balance is: 40.0</span><br><span class="hljs-string"></span><br><span class="hljs-string">WalletB is Attempting to send funds (20) to WalletA...</span><br><span class="hljs-string">Transaction Successfully added to Block</span><br><span class="hljs-string"></span><br><span class="hljs-string">WalletA&#x27;</span>s balance is: <span class="hljs-number">80.0</span><br>WalletB<span class="hljs-string">&#x27;s balance is: 20.0</span><br><span class="hljs-string">Blockchain is valid</span><br></code></pre></td></tr></table></figure><p>现在钱包能够安全地在您的区块链上发送金额，只要他们有金额发送。这意味着你有你自己的本地加密货币.</p><h3 id="完整的可以进行交易的区块链"><a href="#完整的可以进行交易的区块链" class="headerlink" title="完整的可以进行交易的区块链"></a>完整的可以进行交易的区块链</h3><p>成功地创建了自己的加密货币。完整的可以进行交易的区块链功能实现：</p><ul><li>允许用户创建钱包</li><li>使用椭圆曲线加密方式为钱包提供公钥和私钥</li><li>通过使用数字签名算法证明所有权，确保资金转移</li><li>允许用户在区块链上进行交易</li></ul><p>参考博客：</p><ul><li><a href="https://niocoder.com/2018/03/10/%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE-part1/">https://niocoder.com/2018/03/10/%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE-part1/</a></li><li><a href="https://niocoder.com/2018/03/11/%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE-part2/">https://niocoder.com/2018/03/11/%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE-part2/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2022/05/12/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/05/12/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>滑动窗口是一种基于双指针的一种思想，两个指针指向的元素之间形成一个窗口。</p><p><strong>分类：</strong>窗口有两类，一种是固定大小类的窗口，一类是大小动态变化的窗口。</p><p><strong>应用：</strong>什么情况可以用滑动窗口来解决实际问题呢？</p><ul><li>一般给出的数据结构是数组或者字符串</li><li>求取某个子串或者子序列最长最短等最值问题或者求某个目标值时</li><li>该问题本身可以通过暴力求解</li></ul><h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><p><strong>窗口的形成</strong></p><p>在具体使用之前，我们知道窗口实际是两个指针之间形成的区域，那关键就是这两个指针是如何移动的。</p><ol><li>初始时，左右指针left,right都指向第0个元素，窗口为[left,right)，注意这里是左闭右开，因此初始窗口[0,0)区间没有元素，符合我们的初始定义</li><li>开始循环遍历整个数组元素，判断当前right指针是否超过整个数组的长度，是退出循环，否则执行第3步</li><li>然后right指针开始向右移动一个长度，并更新窗口内的区间数据</li><li>当窗口区间的数据满足我们的要求时，右指针right就保持不变，左指针left开始移动，直到移动到一个不再满足要求的区间时，left不再移动位置</li><li>执行第2步</li></ol><p>这中间，窗口的更新与维护是很重要的一环，新元素加入窗口，旧元素移出窗口，都需要及时地更新与这个窗口范围相关的数据。</p><p>上述说明主要是两个while循环，可以简单抽象成一个模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right =<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(right指针未越界)&#123;<br>  <span class="hljs-type">char</span> ch = arr[right++];<br>  <span class="hljs-comment">//右指针移动，更新窗口</span><br>  ...<br>  <br>  <span class="hljs-comment">//窗口数据满足条件 对于固定窗口而言，就是窗口的大小&gt;=固定值；对于动态窗口，就是从left出发，窗口不断扩充，第一次满足题意的位置</span><br>  <span class="hljs-keyword">while</span>(窗口数据满足条件)&#123;<br>   <span class="hljs-comment">//记录或者更新全局数据</span><br>   ...<br>   <br>   <span class="hljs-comment">//右指针不动，左指针开始移动一位</span><br>   <span class="hljs-type">char</span> tmp = arr[left++];<br>   <br>   <span class="hljs-comment">//左指针移动，窗口缩小，更新窗口数据</span><br>   ...<br>  &#125;<br>  <span class="hljs-comment">//返回结果</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/422908736">https://zhuanlan.zhihu.com/p/422908736</a></li><li><a href="https://zhuanlan.zhihu.com/p/63239291">https://zhuanlan.zhihu.com/p/63239291</a></li><li><a href="https://zhuanlan.zhihu.com/p/110241099">https://zhuanlan.zhihu.com/p/110241099</a></li></ul><p>相关题目：</p><ul><li>LeetCode 3：无重复字符的最长子串（难度：中等 已做）</li><li>LeetCode 209：长度最小的子数组（难度：中等 已做）</li></ul><h2 id="Bilibili滑动窗口学习笔记"><a href="#Bilibili滑动窗口学习笔记" class="headerlink" title="Bilibili滑动窗口学习笔记"></a>Bilibili滑动窗口学习笔记</h2><h4 id="算法应用场景："><a href="#算法应用场景：" class="headerlink" title="算法应用场景："></a>算法应用场景：</h4><p>关键字：</p><p>满足XXX条件（计算结果，出现次数，同时包含）</p><p>最长/最短</p><p>子串/子数组/子序列</p><p>例如：长度最小的子数组</p><h4 id="滑动窗口使用思路（寻找最长）"><a href="#滑动窗口使用思路（寻找最长）" class="headerlink" title="滑动窗口使用思路（寻找最长）"></a>滑动窗口使用思路（寻找最长）</h4><p>核心：左右双指针（L，R）在起始点，R向右逐位滑动循环</p><p>每次滑动过程中</p><ul><li>如果窗内元素满足条件，R向右扩大窗口，并更新最优结果</li><li>如果窗内元素不满足条件，L向右缩小窗口</li></ul><p>直至R到达结尾</p><p>代码模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//最长模板</span><br><span class="hljs-comment">//初始化left right result bestResult</span><br><span class="hljs-keyword">while</span>(右指针没有到达结尾)<br>&#123;<br>    窗口扩大，加入right对应元素，更新当前<span class="hljs-function">result</span><br><span class="hljs-function">    <span class="hljs-title">while</span><span class="hljs-params">(result不满足要求)</span></span><br><span class="hljs-function">    </span>&#123;<br>        窗口缩小，移除left对应元素，left右移<br>    &#125;<br>    更新最优结果bestResult<br>    right++;<br>&#125;<br>返回bestResult;<br></code></pre></td></tr></table></figure><h4 id="滑动窗口使用思路（寻找最短）"><a href="#滑动窗口使用思路（寻找最短）" class="headerlink" title="滑动窗口使用思路（寻找最短）"></a>滑动窗口使用思路（寻找最短）</h4><p>核心：左右双指针（L，R）在起始点，R向右逐位滑动循环</p><p>每次滑动过程中</p><ul><li>如果窗内元素满足条件，L向右缩小窗口 ，并更新最优结果</li><li>如果窗内元素不满足条件，R向右扩大窗口</li></ul><p>直至R到达结尾</p><p>代码模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//最短模板</span><br><span class="hljs-comment">//初始化left right result bestResult</span><br><span class="hljs-keyword">while</span>(右指针没有到达结尾)<br>&#123;<br>    窗口扩大，加入right对应元素，更新当前<span class="hljs-function">result</span><br><span class="hljs-function">    <span class="hljs-title">while</span><span class="hljs-params">(result满足要求)</span></span><br><span class="hljs-function">    </span>&#123;<br>        更新最优结果bestResult<br>        窗口缩小，移除left对应元素，left右移<br>    &#125;<br>    right++;<br>&#125;<br>返回bestResult;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-713：乘积小于-K-的子数组"><a href="#LeetCode-713：乘积小于-K-的子数组" class="headerlink" title="LeetCode 713：乘积小于 K 的子数组"></a>LeetCode 713：乘积小于 K 的子数组</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>这道题是一道典型的滑动窗口问题。</p><blockquote><p>溢出问题：</p><p>double与int类型的存储机制不同，long int的8个字节全部都是数据位，⽽double是以尾数，底数，指数的形式表⽰的，类似科学计数法，<br>因此double⽐int能表⽰的数据范围更⼴。double的范围也是要大于long long int的范围的。</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。</p><blockquote><p>输入：nums = [10,5,2,6], k = 100<br>输出：8<br>解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。<br>需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSubarrayProductLessThanK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;=r &amp;&amp; r&lt;nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            cur = cur*nums[r];<br>            <span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; cur &gt;= k)<br>            &#123;<br>                cur = cur/nums[l];<br>                l++;<br>            &#125;<br>            ans = ans+(r-l+<span class="hljs-number">1</span>);<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[10]</span><br><span class="hljs-comment">[10,5] [5]</span><br><span class="hljs-comment">[5,2] [2]</span><br><span class="hljs-comment">[5,2,6] [2,6] [6]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>待续……..</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 449.序列化和反序列化二叉搜索树</title>
    <link href="/2022/05/11/LC%20449.%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/05/11/LC%20449.%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-449-序列化和反序列化二叉搜索树"><a href="#LC-449-序列化和反序列化二叉搜索树" class="headerlink" title="LC 449.序列化和反序列化二叉搜索树"></a>LC 449.序列化和反序列化二叉搜索树</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>差点AC代码（62个测试样例过了61个 最后一个测试样例超时了🤣）</p><p>改了好久都不理解为什么代码最后一个测试样例会超时（代码的复杂度也不高啊！！！题目给的数据也不大诶）</p><p>算算了 代码不重要 重要的是理解这题的思路和解法</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p>示例1：</p><blockquote><p>输入：root = [2,1,3]<br>输出：[2,1,3]</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题就是二叉搜索树转换来转换去最后又转换回二叉搜索树，大致过程如下：</p><ol><li>二叉搜索树利用队列转化成字符串string</li><li>string转换成vector容器</li><li>vector容器利用队列重新建成二叉搜索树</li></ol><p>差点AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)  <span class="hljs-keyword">return</span> ans;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                ans = ans+<span class="hljs-string">&quot;null,&quot;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans = ans+<span class="hljs-built_in">to_string</span>(node-&gt;val)+<span class="hljs-string">&quot;,&quot;</span>;<br>                q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data == <span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        vector&lt;string&gt; temp = <span class="hljs-built_in">split</span>(data);<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(temp[<span class="hljs-number">0</span>]));  <span class="hljs-comment">//TreeNode(int)</span><br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(temp[index] != <span class="hljs-string">&quot;null&quot;</span>)<br>            &#123;<br>                node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(temp[index]));<br>                q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            index++;<br>            <span class="hljs-keyword">if</span>(temp[index] != <span class="hljs-string">&quot;null&quot;</span>)<br>            &#123;<br>                node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(temp[index]));<br>                q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string data)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-type">int</span> from = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;data.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(data[i] == <span class="hljs-string">&#x27;,&#x27;</span>)<br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(data.<span class="hljs-built_in">substr</span>(from,i-from));  <span class="hljs-comment">//Note:第二个参数为复制长度而不是字符串结束位置</span><br>                from = i+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 937.重新排列日志文件</title>
    <link href="/2022/05/10/LC%20937.%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
    <url>/2022/05/10/LC%20937.%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-937-重新排列日志文件"><a href="#LC-937-重新排列日志文件" class="headerlink" title="LC 937.重新排列日志文件"></a>LC 937.重新排列日志文件</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>力扣难度：简单 写简单题题解是因为通过这道题补了很多知识。C++匿名函数，C++稳定排序，自定义排序函数。</p></blockquote><h4 id="C-匿名函数"><a href="#C-匿名函数" class="headerlink" title="C++匿名函数"></a>C++匿名函数</h4><p><strong>匿名函数</strong></p><p>C++中的匿名函数，类似于python的lambda函数，也就是在句中定义和声明的一个临时函数，仅在调用时才会创建函数对象，无需在头文件中声明。</p><p><strong>函数形式</strong></p><p>[capture](parameters)-&gt;return-type{body} </p><p>捕获列表-&gt;返回类型-{函数主体}</p><p>capture：捕获列表</p><ul><li>[]    //捕获列表为空。在函数内无法使用外部变量。</li><li>[a]   //捕获列表为按值传递形式。在函数内仅能使用传递的变量值，无法改变变量。值在匿名函数生成时便已经确定，后续修改不会影响函数内的变量值。</li><li>[&amp;a]  //按应用传递。可改变变量。</li></ul><p>return-type：返回类型</p><p>一般情况下编译器可以推断出返回类型，可以用auto而不指定返回类型。但有多个return语句时需要指定返回类型。</p><p><strong>函数例子</strong></p><p>1.与sort()函数等参数中可传入函数的方法等搭配（也就是该题目中用的）</p><blockquote><p>匿名函数：格式[](){}，可以理解为中括号里面是函数名  [&amp;]代表没有名字，小括号里面是传入的参数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; costs;<span class="hljs-comment">//costs的每个元素是由价值与编号组成的pair</span><br><span class="hljs-built_in">sort</span>(costs.<span class="hljs-built_in">begin</span>(), costs.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; b)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a.first != b.first)<br>            <span class="hljs-keyword">return</span> a.first &gt; b.first;<span class="hljs-comment">//价值不同时，价值大的优先</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> a.second &lt; b.second;<span class="hljs-comment">//价值相同时，标号小的优先</span><br>    &#125;);<br></code></pre></td></tr></table></figure><p>这种方法等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; costs;<br><span class="hljs-keyword">auto</span> compare = [&amp;](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a,<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b )&#123;<br>        <span class="hljs-keyword">if</span> (a.first != b.first)<br>            <span class="hljs-keyword">return</span> a.first &gt; b.first;<span class="hljs-comment">//价值不同时，价值大的优先</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> a.second &lt; b.second;<span class="hljs-comment">//价值相同时，标号小的优先</span><br>&#125;<br><span class="hljs-built_in">sort</span>(costs.<span class="hljs-built_in">begin</span>(),costs.<span class="hljs-built_in">end</span>(),compare);<br></code></pre></td></tr></table></figure><p>2.直接写在main函数中，与inline函数相似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,y=<span class="hljs-number">2</span>,z=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> add = [&amp;z](<span class="hljs-keyword">auto</span> x,<span class="hljs-keyword">auto</span> y)&#123;z=x+y;<span class="hljs-keyword">return</span> z;&#125;;<br>    <span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">add</span>(x,y);<br>    cout&lt;&lt;res&lt;&lt;z&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-稳定排序"><a href="#C-稳定排序" class="headerlink" title="C++稳定排序"></a>C++稳定排序</h4><p>C++ 稳定排序函数：stable_sort()</p><ul><li><p>当指定范围内包含多个相等的元素时，sort() 排序函数无法保证不改变它们的相对位置。那么，如果既要完成排序又要保证相等元素的相对位置，该怎么办呢？可以使用 stable_sort() 函数。</p></li><li><p>stable_sort() 函数完全可以看作是 sort() 函数在功能方面的升级版。换句话说，stable_sort() 和 sort() 具有相同的使用场景，就连语法格式也是相同的，只不过前者在功能上除了可以实现排序，还可以保证不改变相等元素的相对位置。</p></li><li><p> sort() 函数一样，实现 stable_sort() 的函数模板也位于&lt;algorithm&gt;头文件中</p></li><li><p>table_sort() 函数的用法也有 2 种，其语法格式和 sort() 函数完全相同（仅函数名不同）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对 [first, last) 区域内的元素做默认的升序排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stable_sort</span> <span class="hljs-params">( RandomAccessIterator first, RandomAccessIterator last )</span></span>;<br><span class="hljs-comment">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stable_sort</span> <span class="hljs-params">( RandomAccessIterator first, RandomAccessIterator last, Compare comp )</span></span>;<br></code></pre></td></tr></table></figure><p>first 和 last 都为随机访问迭代器，它们的组合 [first, last) 用来指定要排序的目标区域</p></li></ul><h4 id="自定义排序函数"><a href="#自定义排序函数" class="headerlink" title="自定义排序函数"></a>自定义排序函数</h4><p> <strong>C++中sort自定义排序</strong></p><ul><li><p><strong>sort简介</strong></p><ul><li>用于C++中，对给定区间所有元素进行排序</li><li>使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)，执行效率较高</li><li>头文件 #include &lt;algorithm&gt;</li></ul></li><li><p><strong>sort使用方法</strong></p><p>sort函数有三个参数</p><p>sort(first,last,cmp);</p><p>其中，first是元素的起始地址，last是结束地址，cmp是排序的方式。对[first，last)（一定要注意这里的区间是左闭又开）区间内数据根据cmp的方式进行排序。也可以不写第三个参数，此时按默认排序，从小到大进行排序。</p></li><li><p><strong>自定义排序</strong></p><ul><li><p>自定义比较函数cmp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span>  <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">return</span> b&lt;a;<br>&#125;<br><span class="hljs-built_in">sort</span>(a,a+n,cmp);<br></code></pre></td></tr></table></figure><p>传入的参数类型和需要排序的数据类型一致，如果认为第一个参数比第二个小，也就是第一个参数需要排在第二个参数前面时返回true，反之返回 false。系统默认a&lt;b时返回true，于是从小到大排。而上面的例子是当b小于a时，认为a小于b。所以排序的结果就是将元素按从大到小的顺序排序。</p></li><li><p>重载比较运算符”&lt;”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Student&amp; s1, <span class="hljs-type">const</span> Student&amp; s2)<br>&#123;<br>        <span class="hljs-keyword">if</span>(s1.age==s2.age)<br>                <span class="hljs-keyword">return</span> s1.name &lt;s2.name;<span class="hljs-comment">//年龄相同时，按姓名小到大排</span><br>        <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> s1.age &gt; s2.age; <span class="hljs-comment">//从年龄大到小排序</span><br>&#125;<br><span class="hljs-built_in">sort</span>(a,a+n);<br></code></pre></td></tr></table></figure><p>Note：参数类型如果是自定义类型，比如自己定义的结构体、类，尽管sort函数默认是从小到大排列，但是这里必须要重载比较运算符”&lt;”</p><p>和cmp函数同理，如果认为第一个参数比第二个小就返回true，反之返回 false。</p></li><li><p>声明比较类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span><br>&#123;<br>       <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; s1, <span class="hljs-type">const</span> Student&amp; s2)</span></span><br><span class="hljs-function">       </span>&#123;<br>              <span class="hljs-keyword">if</span>(s1.age==s2.age)<br>                     <span class="hljs-keyword">return</span> s1.name &lt;s2.name;<br>              <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> s1.age &lt; s2.age;<br>        &#125;<br>&#125;;<br><span class="hljs-built_in">sort</span>(a,a+n,<span class="hljs-built_in">cmp</span>());<br></code></pre></td></tr></table></figure><p>还是同理，如果认为第一个参数比第二个小就返回true，反之返回 false。</p></li></ul></li></ul><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode.cn/problems/reorder-data-in-log-files/">https://leetcode.cn/problems/reorder-data-in-log-files/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先对日志文件进行预处理，将字母日志和数字日志分别存储在容器digit和容器alpha中，再用匿名函数对字母日志进行排序。再将排序后的日志文件合并，返回结果。</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">reorderLogFiles</span><span class="hljs-params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;<br>        vector&lt;string&gt; digit;<br>        vector&lt;string&gt; alpha;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> str : logs)<br>        &#123;<br>            <span class="hljs-type">char</span> c = str.<span class="hljs-built_in">back</span>();  <span class="hljs-comment">//返回字符串最后一个字符</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(c))  digit.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">else</span>  alpha.<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(alpha.<span class="hljs-built_in">begin</span>(),alpha.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">const</span> string &amp;log1,<span class="hljs-type">const</span> string &amp;log2)&#123;  <span class="hljs-comment">//lambda匿名函数</span><br>            <span class="hljs-type">int</span> pos1 = log1.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27; &#x27;</span>);  <span class="hljs-comment">//返回第一次出现&#x27; &#x27;的位置下标</span><br>            <span class="hljs-type">int</span> pos2 = log2.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>            string s1 = log1.<span class="hljs-built_in">substr</span>(pos1);  <span class="hljs-comment">//从下标pos1处开始复制字符串log1</span><br>            string s2 = log2.<span class="hljs-built_in">substr</span>(pos2);<br>            <span class="hljs-keyword">if</span>(s1 != s2)<br>            &#123;<br>                <span class="hljs-keyword">return</span> s1&lt;s2;<br>            &#125;<br>            <span class="hljs-keyword">return</span> log1&lt;log2;  <span class="hljs-comment">//s1==s2 只有前面的标识符不同 所以直接比较整个字符串相当于比较标识符</span><br>        &#125;);<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> str : alpha)  ans.<span class="hljs-built_in">push_back</span>(str);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> str : digit)  ans.<span class="hljs-built_in">push_back</span>(str);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 433.最小基因变化 BFS</title>
    <link href="/2022/05/09/LC%20433.%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96%20BFS/"/>
    <url>/2022/05/09/LC%20433.%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96%20BFS/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-433-最小基因变化"><a href="#LC-433-最小基因变化" class="headerlink" title="LC 433.最小基因变化"></a>LC 433.最小基因变化</h2><blockquote><p>由于复习数据库和PHP考试好几天没刷题了，今天补了三道题。</p></blockquote><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>力扣难度：中等 </p><p>经典BFS问题 BFS利用队列实现</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode.cn/problems/minimum-genetic-mutation/">https://leetcode.cn/problems/minimum-genetic-mutation/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>解题思路没有完全按照力扣官方给出的解法，但是大体思想是一样的只有一些小的细节不太一样，都是用了广度优先搜索的方法解题的。</p><p>解题思路：首先定义一个队列q用于存储变化后的gene序列和哈希表mp防止重复遍历gene序列进入死循环。只要队列不为空或者gene != end，则遍历队列中的元素（有点类似于层序遍历），利用判断条件distance(str,gene) == 1 &amp;&amp; mp[str] == false找出所有未遍历的在基因库bank中且与当前遍历gene只差一个字符的基因并将其插入队列尾部。distance()函数为判断两个不同基因序列所差字符个数的函数。每做完一层遍历之后 ans++，表示基因变化了一次</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(string str,string gene)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;str.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str[i] != gene[i])  cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        queue&lt;string&gt; q;<br>        unordered_map&lt;string,<span class="hljs-type">bool</span>&gt; mp;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        mp[start] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            &#123;<br>                <span class="hljs-keyword">auto</span> gene = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(gene == end)  <span class="hljs-keyword">return</span> ans;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> str : bank)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">distance</span>(str,gene) == <span class="hljs-number">1</span> &amp;&amp; mp[str] == <span class="hljs-literal">false</span>)<br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(str);<br>                        mp[str] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库常用命令操作</title>
    <link href="/2022/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<ul><li><p>启动数据库</p><p>net start mysql</p></li><li><p>关闭数据库</p><p>net  stop mysql</p></li><li><p>连接数据库</p><p>mysql -u root -p</p></li></ul><h4 id="管理数据库的命令"><a href="#管理数据库的命令" class="headerlink" title="管理数据库的命令"></a>管理数据库的命令</h4><ul><li><p><strong>USE 数据库名;</strong></p><p>选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。</p></li><li><p><strong>SHOW DATABASES;</strong></p><p>列出 MySQL 数据库管理系统的数据库列表。</p></li><li><p><strong>SHOW TABLES;</strong></p><p>显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。</p></li><li><p><strong>CREATE DATABASE 数据库名;</strong></p><p>创建数据库：CREATE DATABASE stu;  （注意MySQL语法要求大写）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「PHP」期末复习</title>
    <link href="/2022/05/05/%E3%80%8CPHP%E3%80%8D%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/05/05/%E3%80%8CPHP%E3%80%8D%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>愿世间再无不让打印的半开卷考试，整理了一天终于把PHP的内容整理完了，明天开始抄！</p><p>不过感觉这样整理的效果还挺好的，一边整理一边学比正常学的效率还要高。考完数据库和PHP再把Java整理一下，重拾Java，Java的语法啥的都快忘完了！！！</p></blockquote><h1 id="第1、2章-PHP入门-HTML和CSS简介"><a href="#第1、2章-PHP入门-HTML和CSS简介" class="headerlink" title="第1、2章 PHP入门 HTML和CSS简介"></a>第1、2章 PHP入门 HTML和CSS简介</h1><p>……</p><h1 id="第3章-数据与变量"><a href="#第3章-数据与变量" class="headerlink" title="第3章 数据与变量"></a>第3章 数据与变量</h1><h2 id="3-1-PHP数据类型"><a href="#3-1-PHP数据类型" class="headerlink" title="3-1 | PHP数据类型"></a>3-1 | PHP数据类型</h2><h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><ul><li><p>布尔型</p><p>用print或echo输出布尔型数据时，true被转换成字符串“1”，false被转换成空串。</p></li><li><p>整型</p></li><li><p>浮点型</p></li><li><p>字符串型</p><p>转义字符</p></li></ul><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><ul><li><p>数组</p><ul><li><p>在PHP中，数组是有序的映射。一个数组由若干元素组成，每个元素是一个键-值对。</p></li><li><p>键用于索引数组元素，一个数组不能有重复的键。键可以是整数也可以是字符串。</p></li><li><p>值也称为数组元素的值，可以是任意类型。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//例子：创建数组。</span><br><span class="hljs-variable">$arr1</span> = <span class="hljs-keyword">array</span>(<span class="hljs-number">0</span> =&gt; <span class="hljs-string">&quot;浙江&quot;</span>, <span class="hljs-number">1</span> =&gt; <span class="hljs-string">&quot;江苏&quot;</span>, <span class="hljs-number">2</span> =&gt; <span class="hljs-string">&quot;广东&quot;</span>);<br><span class="hljs-variable">$arr2</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;浙江&quot;</span> =&gt; <span class="hljs-string">&quot;杭州&quot;</span>, <span class="hljs-string">&quot;江苏&quot;</span> =&gt; <span class="hljs-string">&quot;南京&quot;</span>, <span class="hljs-string">&quot;广东&quot;</span> =&gt; <span class="hljs-string">&quot;广州&quot;</span>);<br><span class="hljs-comment">//通过一个具体的键可以访问对应的值，比如：</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$arr1</span>[<span class="hljs-number">0</span>];                <span class="hljs-comment">// 输出：浙江</span><br>Echo <span class="hljs-variable">$arr2</span>[“浙江”]       <span class="hljs-comment">// 输出：杭州</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>对象</p></li></ul><h4 id="NULL类型"><a href="#NULL类型" class="headerlink" title="NULL类型"></a>NULL类型</h4><p>NULL类型的唯一值是NULL，代表无值，不区分大小写。</p><p>一个变量在下面情况下具有NULL值</p><ul><li>被赋予常量NULL</li><li>不存在</li><li>被unset复原</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$var1</span> [, <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$var2</span>]* )<br><span class="hljs-comment">//unset用以销毁指定的一个或多个变量</span><br><span class="hljs-keyword">bool</span> <span class="hljs-title function_ invoke__">is_null</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$var</span>)<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">isset</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$var1</span> [, <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$var2</span>]*)<br><span class="hljs-comment">//检测指定变量是否设置</span><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">empty</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$var</span> )<br></code></pre></td></tr></table></figure><h2 id="3-2-类型转换"><a href="#3-2-类型转换" class="headerlink" title="3-2 | 类型转换"></a>3-2 | 类型转换</h2><p>PHP是弱类型的编程语言，在引入变量时，并不需要明确声明其类型。当给它赋一个字符串时，变量的类型就是字符串；如果再给它赋一个整数，那么变量的类型就变为整型的。</p><ul><li><p>自动类型转换</p><p>有时候在计算表达式时，PHP会根据上下文自动将一些数据转换成合适的类型来参与运算。</p></li><li><p>强制类型转换</p><p>语法：在要转换的变量（或表达式）之前加上用括号括起来的目标类型。</p></li></ul><h2 id="3-3-变量与常量"><a href="#3-3-变量与常量" class="headerlink" title="3-3 | 变量与常量"></a>3-3 | 变量与常量</h2><p>PHP变量总是以美元符号$开头，然后是变量名。</p><p>PHP是一种弱类型语言，或者动态类型语言。在PHP中，变量不需要显式声明，也没有固定的类型。变量的类型由赋给变量的值确定。</p><h4 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h4><ul><li><p>值赋值</p></li><li><p>引用赋值</p><p>引用赋值是指将源变量（右侧）的引用赋给目标变量（左侧），其结果是目标变量与源变量引用相同的内存单元。在源变量名前加上一个&amp;符号将实现按引用赋值。</p></li></ul><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul><li>全局变量</li><li>局部变量</li><li>静态变量</li><li>超全局变量</li></ul><h1 id="第4章-运算符与流程控制"><a href="#第4章-运算符与流程控制" class="headerlink" title="第4章 运算符与流程控制"></a>第4章 运算符与流程控制</h1><h2 id="4-1-运算符"><a href="#4-1-运算符" class="headerlink" title="4-1 | 运算符"></a>4-1 | 运算符</h2><ul><li><p>算术运算符</p></li><li><p>字符串运算符</p><p>字符串运算符是指字符串连接运算符（.），用于将两个字符串连接成一个新的字符串返回。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-variable">$b</span> = <span class="hljs-string">&quot;xyz&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$a</span>.<span class="hljs-string">&quot;123&quot;</span>.<span class="hljs-variable">$b</span>.<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;<br>php&gt;<br><span class="hljs-comment">//输出：abc123xyz</span><br></code></pre></td></tr></table></figure></li><li><p>比较运算符</p><p>=== 全等（值和类型均相同）</p></li><li><p>逻辑运算符</p></li><li><p>位运算符</p></li><li><p>赋值运算符</p></li><li><p>三目条件运算符</p></li></ul><h2 id="4-2-流程控制"><a href="#4-2-流程控制" class="headerlink" title="4-2 | 流程控制"></a>4-2 | 流程控制</h2><ul><li>选择结构</li><li>循环结构</li><li>跳转语句</li></ul><h2 id="4-3-包含文件"><a href="#4-3-包含文件" class="headerlink" title="4-3 | 包含文件"></a>4-3 | 包含文件</h2><ul><li>include语句</li><li>require语句</li><li>include_once语句</li><li>require_once语句</li></ul><h1 id="第5章-PHP函数"><a href="#第5章-PHP函数" class="headerlink" title="第5章 PHP函数"></a>第5章 PHP函数</h1><h2 id="5-1-函数的声明与调用"><a href="#5-1-函数的声明与调用" class="headerlink" title="5-1 | 函数的声明与调用"></a>5-1 | 函数的声明与调用</h2><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>函数声明应该出现在PHP开始标记和结束标记之间。</p><p>语法格式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> &lt;<span class="hljs-title">function_name</span>&gt;(<span class="hljs-params">[&lt;<span class="hljs-variable">$arg</span>&gt;[, &lt;<span class="hljs-variable">$arg</span>&gt;]*]</span>) </span>&#123;<br>      <span class="hljs-comment">// 要执行的代码;</span><br>&#125;<br><span class="hljs-comment">//函数体可以是任何合法的PHP代码。</span><br></code></pre></td></tr></table></figure><p>函数名的命名规则：</p><p>(1) 函数名不能和已有的函数重名。</p><p>(2) 函数名称只能包含字母、数字和下划线。</p><p>(3) 函数名称不能以数字开头。</p><p>(4) 长度不限，对<strong>大小写不敏感</strong>。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>函数只有在被调用时才会执行，格式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;functin_name&gt;([&lt;exp&gt;[, &lt;exp&gt;]*]);<br></code></pre></td></tr></table></figure><h2 id="5-2-函数参数"><a href="#5-2-函数参数" class="headerlink" title="5-2 | 函数参数"></a>5-2 | 函数参数</h2><h4 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h4><p>函数形参被定义在函数名之后，括号内部。一个函数的形参数目不限，两个形参之间用逗号分隔。函数形参类似于在函数内定义的局部变量，在函数内有效。</p><p>当调用包含形参的函数时，应提供相应的参数值，通常称为实参。实参是表达式，两个表达式之间用逗号分隔。</p><h4 id="PHP参数传递的方式"><a href="#PHP参数传递的方式" class="headerlink" title="PHP参数传递的方式"></a>PHP参数传递的方式</h4><ul><li><p>按值传递参数</p><p>默认情况下，函数的参数是按值传递的。这意味着，即使实参是变量，当函数对形参的值进行改变后，也不会影响函数外部实参的取值。</p></li><li><p>引用传递参数</p><p>要实现按引用传递：</p><p>(1) 形参名前加上&amp;符号，如&amp;$arg。</p><p>(2) 实参是变量。</p></li></ul><h4 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h4><p>在声明函数时，可以为形参指定默认值。形参默认值必须是常量表达式，通过运算符“=”给相应的形参赋值。</p><p>具有默认值的形参可以有多个，但必须放置在其他形参后面。当调用函数时，对不具有默认值的形参必须指定相应的实参，对具有默认值的形参，可以指定实参，也可以没有。</p><h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><ul><li>可变长形参<ul><li>PHP支持可变长参数。</li><li>可变长形参通过在形参名前加符号“…”实现。可变长形参必须是形参表中最后一个形参。</li><li>可变长形参可以接收零个或多个实参值，此时这些参数值将被组织成一个数组赋给该形参。</li></ul></li><li>可变长实参<ul><li>可变长实参在实参前加符号“…”实现。可变长实参的类型应该是数组。可变长实参必须是实参表中的最后一个实参。</li><li>当传递参数时，实参数组中的各元素将被自动取出并一一赋给对应的形参。</li></ul></li></ul><h2 id="5-3-函数返回值"><a href="#5-3-函数返回值" class="headerlink" title="5-3 | 函数返回值"></a>5-3 | 函数返回值</h2><p>表达式可以是任意类型的，所以一个函数可以返回数值、字符串等标量类型的值，也可以返回数组、对象等复合类型的值。</p><p>函数可以返回一个值，也可以返回一个引用。</p><p>要让函数返回一个引用，需要：</p><p>(1) 在函数声明时，函数名前使用&amp;；</p><p>(2) return语句所带的表达式是变量；</p><p>(3) 调用函数时，函数名前使用&amp;。</p><h2 id="5-4-变量函数"><a href="#5-4-变量函数" class="headerlink" title="5-4 | 变量函数"></a>5-4 | 变量函数</h2><h2 id="5-5-匿名函数"><a href="#5-5-匿名函数" class="headerlink" title="5-5 | 匿名函数"></a>5-5 | 匿名函数</h2><ul><li><p>匿名函数作为变量值</p><p>可以把匿名函数作为一个表达式赋给一个变量，然后就可以通过该变量来调用匿名函数了。</p><p>在内部处理中，PHP系统会自动把匿名函数转换成内置类Closure的一个实例对象，然后再把该实例对象赋给变量。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-comment">//给变量$green赋一个匿名函数</span><br>    <span class="hljs-variable">$greet</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable">$name</span></span>)</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-variable">$name</span>,<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;<br>&#125;;  <span class="hljs-comment">//函数末尾需要分号</span><br><br><span class="hljs-variable">$greet</span>(<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-variable">$greet</span>(<span class="hljs-string">&quot;php&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br><br><span class="hljs-comment">//输出：hello world</span><br><span class="hljs-comment">//    hello php</span><br></code></pre></td></tr></table></figure></li><li><p>用作回调类型参数的值</p><p>用于接收函数的形参被称为回调类型参数，传递给这种参数的函数被称为回调函数。</p><p>回调函数可以是正常的函数，也可以是匿名函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"><span class="hljs-variable">$name</span>,<span class="hljs-variable">$func</span></span>)</span>&#123;<br>    <span class="hljs-variable">$func</span>(<span class="hljs-variable">$name</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">display</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>)</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-variable">$str</span>,<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;<br>&#125;<br><span class="hljs-title function_ invoke__">myFunc</span>(<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;display&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-6-日期时间函数"><a href="#5-6-日期时间函数" class="headerlink" title="5-6 | 日期时间函数"></a>5-6 | 日期时间函数</h2><ol><li><h4 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h4><p>int time(void)</p><p>返回自从Unix纪元（格林威治时间1970年1月1日00:00:00）到当前时间经过的秒数。</p></li><li><h4 id="mktime函数"><a href="#mktime函数" class="headerlink" title="mktime函数"></a>mktime函数</h4><p>int mktime([ int $hour [, int $minute [, int $second [, int $month [, int $day [, int $year]]]]]] )</p><p>函数返回与指定日期时间信息相应的时间戳，即从Unix纪元到指定时间的秒数。</p></li><li><h4 id="date函数"><a href="#date函数" class="headerlink" title="date函数"></a>date函数</h4><p>string date(string $format [, int $timestamp ])</p><p>按照指定的格式串$format对指定的时间戳$timestamp进行格式化，返回格式化产生的字符串。如果缺省$timestamp，就使用当前的Unix时间戳，即time()的返回值。</p><p>格式串由格式符和普通文本组成。格式符描述了需要包含的相应的日期时间文本，普通文本则会原样保留在返回的字符串。</p></li><li><h4 id="getdate函数"><a href="#getdate函数" class="headerlink" title="getdate函数"></a>getdate函数</h4><p>array getdate([ int $timestamp = time() ])</p><p>返回一个根据指定时间戳$timestamp得出的包含有日期信息的关联数组。</p></li><li><h4 id="date-default-timezone-set"><a href="#date-default-timezone-set" class="headerlink" title="date_default_timezone_set"></a><strong>date_default_timezone_set</strong></h4><p>bool date_default_timezone_set(string $timezone_identifier)</p><p>函数为当前脚本中所有日期时间函数设置一个默认时区。如果参数值有效，函数返回true，否则返回false。</p><p>中国大陆的时区标识符可用PRC。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">date_default_timezone_set</span>(<span class="hljs-string">&quot;PRC&quot;</span>);<br><span class="hljs-variable">$time1</span> = <span class="hljs-title function_ invoke__">mktime</span>(<span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2016</span>);<span class="hljs-comment">// 根据日期时间信息获取时间戳$time1</span><br><span class="hljs-variable">$dt</span> = <span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&quot;Y-m-d H:i:s&quot;</span>, <span class="hljs-variable">$time1</span>);              <span class="hljs-comment">// 根据时间戳获得日期时间信息的字符串</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$dt</span>, <span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br><span class="hljs-variable">$time2</span> = <span class="hljs-title function_ invoke__">mktime</span>(<span class="hljs-number">9</span>, <span class="hljs-number">50</span>, <span class="hljs-number">38</span>, <span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2016</span>);<span class="hljs-comment">// 根据日期时间信息获取时间戳$time2</span><br><span class="hljs-variable">$wday</span> = <span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-variable">$time2</span>);              <span class="hljs-comment">// 获得指定时间戳属于星期几</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$wday</span>, <span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br><span class="hljs-variable">$lastday</span> = <span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-variable">$time2</span>);           <span class="hljs-comment">// 获得指定时间戳所在月份的天数</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$lastday</span>, <span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br><span class="hljs-variable">$days</span> = (<span class="hljs-variable">$time2</span> - <span class="hljs-variable">$time1</span>)/(<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>);<span class="hljs-comment">// 计算两个指定时间相差的天数</span><br><span class="hljs-keyword">echo</span> (<span class="hljs-keyword">int</span>)<span class="hljs-variable">$days</span>;<br><span class="hljs-meta">?&gt;</span><br><br><span class="hljs-comment">/*输出：</span><br><span class="hljs-comment">    2016-01-20 15:10:28</span><br><span class="hljs-comment">    5</span><br><span class="hljs-comment">    29</span><br><span class="hljs-comment">    22</span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="第6章-处理字符串"><a href="#第6章-处理字符串" class="headerlink" title="第6章 处理字符串"></a>第6章 处理字符串</h1><h2 id="6-1-长度与去空"><a href="#6-1-长度与去空" class="headerlink" title="6-1 | 长度与去空"></a>6-1 | 长度与去空</h2><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><p>1.字节长度</p><p>int strlen(string $str)</p><p>①返回字符串的长度，即字节个数。</p><p>②若str为空串或NULL，返回0。</p><p>2.字符长度</p><p>mixed mb_strlen(string $str [, string $encoding])</p><p>①返回字符串长度，即字符个数。字符串$str采用指定的字符集$encoding。</p><p>②若$str为空串或NULL，函数返回0。</p><p>③如果$encoding指定的不是一个字符集名称，函数产生一个警告信息，并返回false。</p><p>④如果$encoding指定的字符集与字符串实际采用的字符集不一致，函数返回的结果可能不正确。</p><h4 id="去空"><a href="#去空" class="headerlink" title="去空"></a>去空</h4><p>string trim($str [, $charlist])    //去除首尾端空白符号或指定字符</p><p>string ltrim($str[, $charlist])    //去除开头的空白符号或指定字符</p><p>string rtrim($str [, $charlist])    //去除尾部的空白符号或指定字符</p><p>①从字符串($str)的开始处和(或)结尾处去除空白符号(默认)或指定字符($charlist)，然后返回结果字符串。</p><p>②空白符号包括:换行符和回车符(\n和\r)、水平和垂直制表符(\t和\x0B)、空字符(\0)、空格。</p><p>③$charlist可以简单列出所有要过滤的字符，也可以使用..指定一个字符范围，如\x61..\x7a，表示所有的小写字母。</p><h2 id="6-2-大小写转换与比较"><a href="#6-2-大小写转换与比较" class="headerlink" title="6-2 | 大小写转换与比较"></a>6-2 | 大小写转换与比较</h2><h4 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h4><p><strong>1.</strong> <strong>小写转大写</strong></p><p>string strtoupper(string $string)    //将$string中所有的小写字母转换为大写并返回。</p><p><strong>2.</strong> <strong>大写转小写</strong></p><p>string strtolower(string $string)    //将$string中所有的大写字母转换为小写并返回。</p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p><strong>1.</strong> <strong>按字典顺序比较</strong></p><p>int strcmp(string $str1, string $str2)</p><p>int strcasecmp(string $str1, string $str2)</p><p>①按字典顺序比较。若str1大于str2，返回&gt;0；若str1小于str2，返回&lt;0；若str1等于str2，返回0。</p><p>②函数strcmp比较时区分大小写，函数strcasecmp比较时不区分大小写。</p><p><strong>2.</strong> <strong>按自然顺序比较</strong> </p><p>int strnatcmp(string $str1, string $str2)</p><p>int strnatcasecmp(string $str1, string $str2)</p><p>①按自然顺序比较，若str1大于str2，返回&gt;0；若str1小于str2，返回&lt;0；若str1等于str2，返回0。</p><p>②函数strnatcmp比较时区分大小写，函数strnatcasecmp比较时不区分大小写。</p><h2 id="6-3-子串处理"><a href="#6-3-子串处理" class="headerlink" title="6-3 | 子串处理"></a>6-3 | 子串处理</h2><h4 id="访问单个字符"><a href="#访问单个字符" class="headerlink" title="访问单个字符"></a>访问单个字符</h4><p>可以通过方括号或花括号访问字符串中的某单个字符：</p><p><strong>&lt;$string&gt;[&lt;$index&gt;]</strong>  </p><p>或</p><p><strong>&lt;$string&gt; {&lt;$index&gt;}</strong></p><p>可以返回指定索引位上的字符，类型为字符串。</p><p>如果指定的索引$index无效，那么PHP系统将产生一条注意（Notice）信息，式子返回空串。</p><h4 id="获取子串"><a href="#获取子串" class="headerlink" title="获取子串"></a>获取子串</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">string</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$str</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$start</span> [, <span class="hljs-keyword">int</span> <span class="hljs-variable">$length</span> ])<br><span class="hljs-keyword">string</span> <span class="hljs-title function_ invoke__">mb_substr</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$str</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$start</span> [,<span class="hljs-keyword">int</span> <span class="hljs-variable">$length</span> [,<span class="hljs-keyword">string</span> <span class="hljs-variable">$encoding</span>]])<br></code></pre></td></tr></table></figure><p>①函数substr以字节为单位；函数mb_substr以字符为单位，$encoding指定字符串采用的字符集的名称。</p><p>②若$start为非负整数，则子串的起始位置是字符串中下标为$start的字符，字符串的首字符下标为0。若指定的子串起始位置超出了字符串的最后一个字符，函数返回false。 </p><p>③若$start为负整数，则子串的起点位置是字符串的倒数第-$start个字符，字符串最后一个字符的位置是-1。若指定子串的起始位置超出了字符串的首字符，子串的起始位置从首字符开始。</p><p>④若忽略$length，则子串从起始位置一直取到字符串的最后一个字符。若$length为0或false，则函数返回空串。</p><p>⑤若$length为正整数，则其指定返回子串的字符个数；若该值太大，则取至最后一个字符。</p><p>⑥若$length为负整数，则子串从起始位置取至倒数第-$length个字符前的一个字符为止，即保留字符串末尾的-$length个字符。</p><p>若-$length大于字符串的长度，则函数返回false；</p><p>若要保留的字符中最左边第1个字符正好是起始位置字符，则函数返回空串；</p><p>若要保留的字符越过了起始位置字符且$start为负整数，则函数返回空串；</p><p>若要保留的字符越过了起始位置字符且$start为非负整数，则函数返回false。</p><p>⑦在函数substr中，若$length为NULL，则函数返回空串。在函数mb_substr中，当$length为NULL时，则子串从起始位置一直取至字符串尾部。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-string">&quot;abcdef&quot;</span>, -<span class="hljs-number">1</span>).<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;          <span class="hljs-comment">// 输出: f</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-string">&quot;abcdef&quot;</span>, -<span class="hljs-number">2</span>).<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;          <span class="hljs-comment">// 输出: ef</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-string">&quot;abcdef&quot;</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">1</span>).<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;       <span class="hljs-comment">// 输出: d</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-string">&quot;abcdef&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>).<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;       <span class="hljs-comment">// 输出: abcde</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-string">&quot;abcdef&quot;</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>).<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;       <span class="hljs-comment">// 输出: cde</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-string">&quot;abcdef&quot;</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>).<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;      <span class="hljs-comment">// 输出: de</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-string">&quot;abcdef&quot;</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">4</span>));         <span class="hljs-comment">// 输出: string(0) &quot;&quot;</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-string">&quot;abcdef&quot;</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">4</span>));          <span class="hljs-comment">// 输出: bool(false) </span><br><br><span class="hljs-variable">$str</span> = <span class="hljs-string">&quot;PHP语言&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$str</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>).<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;            <span class="hljs-comment">// 输出: 语</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">mb_substr</span>(<span class="hljs-variable">$str</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);        <span class="hljs-comment">// 输出: 语言</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="查找子串"><a href="#查找子串" class="headerlink" title="查找子串"></a>查找子串</h4><ul><li><p><strong>strpos</strong>函数</p><p>mixed strpos(string $haystack, mixed $needle [,int $offset ])</p><p>①返回子串$needle在字符串$haystack中第1次出现的位置。若没有发现子串，函数返回false。</p><p>②$offset指定搜索子串的起始位置，只能是非负整数，默认值为0。</p></li><li><p><strong>strrpos</strong>函数</p><p>①返回子串$needle在字符串$haystack中最后一次出现的位置。若没有发现子串，函数返回false。</p><p>②此函数的$offset可以是非负整数，也可以是负整数，默认值是0。若是非负整数，则从下标为$offset的字符开始查找，直至最后一个字符；若是负整数，则从首字符开始查找，直到倒数第-$offset个字符为止（只要子串的首字符在此位置上即可）。</p></li><li><p><strong>stripos</strong>函数</p><p>mixed stripos(string $haystack, mixed $needle [,int $offset ])</p><p>与strpos不同的是，stripos搜索时不区分大小写。</p></li><li><p><strong>strripos</strong>函数</p><p>mixed strripos(string $haystack, mixed $needle [,int $offset ])</p><p>与strrpos不同的是，strripos搜索时不区分大小写。</p></li></ul><h4 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h4><ul><li><p><strong>str_replace</strong>函数</p><p>mixed str_replace(mixed $search , mixed $replace, mixed $subject [, int &amp;$count ])</p><p>函数用$replace替换$subject中出现的所有$search，返回替换后的结果字符串。</p><p>①如果$search和$replace都是数组，那么就对$search中每个元素依次做替换操作，期间把$replace中的对应元素作为替换值。如果$replace的元素比$search的元素少，那么用空串作为$search中多余元素的替换值。</p><p>②如果$search是数组，而$replace是字符串，那么$replace被用作$search中的每个元素的替换值。</p><p>③如果$subject是一个数组，则上述替换操作将依次执行于$subject数组的每个元素，函数返回一个数组。</p><p>④如果指定$count变量，返回执行替换操作的次数。</p></li><li><p><strong>substr_replace</strong>函数</p><p>mixed substr_replace(mixed $str, mixed $replacement, mixed $start[, mixed $length])</p><p>函数用$replacement替换$str中从$start开始、长度为$length的子串，返回替换后的结果字符串。</p><p>①参数$start指定要被替换的子串的起始位置。若$start为非负整数，起始位置是下标为$start的字符；若$start为负整数，起始位置是倒数第-$start个字符。</p><p>②参数$length指定要被替换的子串的长度。</p><p>若$length为正整数，表示被替换的字符个数；</p><p>若$length为负整数，则子串从起始位置取至倒数第-$length个字符前的一个字符为止；</p><p>若$length为0，此函数的功能是插入;</p><p>若缺省$length，则被替换的子串是从$start开始至最后一个字符。</p><p>③若$str是数组，则$replacement、$start和$length会应用于$str的每个元素。如果$replacement、$start和$length也可以是数组，那么包括$str在内的各数组对应元素分别进行替换操作。函数返回一个数组。</p></li></ul><h2 id="6-4-分割和连接字符串"><a href="#6-4-分割和连接字符串" class="headerlink" title="6-4 | 分割和连接字符串"></a>6-4 | 分割和连接字符串</h2><ul><li><p><strong>explode</strong>函数</p><p>array explode(string $delimiter , string $string [, int $limit ])</p><p>依据定界字符串delimiter将字符串string分割成若干子串，并保存在一个数组中返回。</p><p>①若指定$limit为正整数，则返回的数组最多包含$limit个元素，最后一个元素包含$string的剩余部分；</p><p>②若指定$limit为0，被当做1处理，此时返回数组仅包含1个元素，即字符串$string本身； </p><p>③若指定$limit为负整数，则返回除了最后-limit个元素外的所有元素，可能会不包含任何元素。</p><p>④若$delimiter是空串，会给出一个警告（Warning）信息，函数返回false。</p></li><li><p><strong>implode</strong>函数</p><p>string implode([string $glue ,] array $pieces)</p><p>将数组pieces中的各元素连接成一个字符串返回，两个元素之间用glue连接。glue的默认值是空串。</p></li></ul><h2 id="6-5-格式化输出"><a href="#6-5-格式化输出" class="headerlink" title="6-5 | 格式化输出"></a>6-5 | 格式化输出</h2><p><strong>printf</strong>函数</p><p>int printf(string $format [, mixed $args [, mixed $… ]])</p><p>①根据格式化模板$format产生一个字符串输出，函数返回格式化产生的字符串的长度(字节数)。</p><p>②格式化模板由普通字符和格式符组成。普通字符原样出现在结果中，格式符通过应用于相应的参数出现在结果中。</p><p>③格式符的一般语法格式如下：%[+][‘&lt;填充符&gt;][-][&lt;宽度&gt;][.&lt;精度&gt;]&lt;类型&gt;</p><p>④类型指明该格式符如何应用于参数数据</p><p><strong>2.</strong> <strong>sprintf</strong>函数</p><p>string sprintf(string $format [, mixed $args [, mixed $… ]])</p><p>与printf不同，sprintf不产生输出，只是根据格式化模板format产生一个字符串并返回</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$num</span> = <span class="hljs-number">50</span>;<br><span class="hljs-variable">$location</span> = <span class="hljs-string">&#x27;tree&#x27;</span>;<br><span class="hljs-variable">$format</span> = <span class="hljs-string">&quot;There are %d monkeys in the %s&lt;br /&gt;&quot;</span>;<br><span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-variable">$format</span>, <span class="hljs-variable">$num</span>, <span class="hljs-variable">$location</span>);<br><br><span class="hljs-variable">$price</span> = <span class="hljs-number">12.567</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">sprintf</span>(<span class="hljs-string">&quot;The price is %5.2f&quot;</span>, <span class="hljs-variable">$price</span>);<br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><h2 id="6-6-字符串特殊处理"><a href="#6-6-字符串特殊处理" class="headerlink" title="6-6 | 字符串特殊处理"></a>6-6 | 字符串特殊处理</h2><ul><li><p><strong>nl2br</strong>函数</p><p>string nl2br(string $string)</p><p>将参数串中每个新行符(\n，\r，\n\r，\r\n)转换为HTML换行符(&lt;br /&gt;)。</p></li><li><p><strong>将字符转换成HTML实体</strong></p><p>string htmlspecialchars(string $string [, int $quotestyle [, string $encoding [, bool $double_encode]]] )</p><p>①将字符串中的特殊字符转换成HTML实体。</p><p>②参数string：要被转换的字符串。</p><p>③参数quotestyle：指定引号的转换</p><p>④参数encoding：指定字符串所用的字符编码。</p><p>⑤double_encode：指定是否转换已有的HTML实体，默认值为true，即要转换。</p></li><li><p><strong>addslashes</strong>函数</p><p>string addslashes(string $str)</p><p>①函数在参数字符串$str中的特殊字符前加上反斜杠（\）产生一个新的字符串返回。特殊字符包括：单引号（’）、双引号（”）、反斜线（\）与空字符（NUL）。</p><p>②这一功能有时在构建数据库的SQL语句时是有用的。</p></li><li><p><strong>urlencode函数</strong></p><p>string urlencode(string $str )</p><p>①函数可以对作为URL中查询参数值的字符串进行相应的编码并返回，以便作为URL的一部分。</p><p>②通常，URL只能包含字母数字以及-和_字符，对其他字符都要进行相应的编码。</p></li></ul><h2 id="6-7-正则表达式"><a href="#6-7-正则表达式" class="headerlink" title="6-7 | 正则表达式"></a>6-7 | 正则表达式</h2><ul><li><p>字符类</p><p>一个字符类在目标字符串中匹配一个单独的字符。</p><ul><li><p>一般字符 </p><p>一般字符类由一对方括号表示，可以使用-和^：[…]  [^…]  [a-z]  [^0-9]</p><table><thead><tr><th>一般字类</th><th>含义</th></tr></thead><tbody><tr><td>[…]</td><td>字符集合。匹配所包含的任意一个字符。例如，’[abc]’  可以匹配 “plain” 中的  ‘a’。</td></tr><tr><td>[^…]</td><td>反向字符集合。匹配未包含的任意字符。例如，’[^abc]’  可以匹配 “plain” 中的’p’。</td></tr><tr><td>[char1-char2]</td><td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td>[^char1-char2]</td><td>排除式字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr></tbody></table></li><li><p>特殊字符</p><table><thead><tr><th>特殊字符类</th><th align="left">含义</th></tr></thead><tbody><tr><td>.</td><td align="left">出现在方括号外，匹配除 “\n” 之外的任何单个字符。如‘a.c’匹配abc、awc、a9c、a#c等。</td></tr><tr><td>\w</td><td align="left">匹配包括下划线的任何单词字符，等价于[A-Za-z0-9_]。</td></tr><tr><td>\W</td><td align="left">匹配任何非单词字符，等价于[^A-Za-z0-9_]。</td></tr><tr><td>\d</td><td align="left">匹配一个数字字符，等价于[0-9]。</td></tr><tr><td>\D</td><td align="left">匹配一个非数字字符，等价于[^0-9]。</td></tr><tr><td>\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等，等价于[\n\r\f\t ]。说明：最后包含一个空格，但不包括\v。</td></tr><tr><td>\S</td><td align="left">匹配任何非空白字符。等价于[^\n\r\f\t ]。</td></tr></tbody></table></li></ul></li><li><p>元字符类与转义字符</p></li><li><p>选项模式与子模式</p></li><li><p>量词</p><p>量词用于指定重复次数，出现在要重复的对象后面。可以重复的对象包括：单独字符、字符类、转义字符、后向引用、子模式</p><table><thead><tr><th>*</th><th>匹配0次或更多次。例如，’xy*z’可以匹配”xz”、”xyz”、”xyyz”等。*等价于{0,}。</th></tr></thead><tbody><tr><td>+</td><td>匹配1次或更多次。例如，’xy+z’可以匹配”xyz”、”xyyz”、”xyyyz”等。+等价于{1,}。</td></tr><tr><td>?</td><td>匹配0次或1次。例如，’do(es)?’可以匹配”do”和”does”。?等价于{0,1}。</td></tr><tr><td>{<em>n}</em></td><td>严格匹配n次。 例如，’xy{2}z’可以匹配”xyyz”。</td></tr><tr><td>{<em>n,}</em></td><td>至少匹配n次。 例如，’xy{2,}z’可以匹配”xyyz”、”xyyyz”、”xyyyyz”等。</td></tr><tr><td>{<em>n,m}</em></td><td>至少匹配n次、最多匹配m次。例如，’xy{2,3}z’可以匹配”xyyz”、”xyyyz”。</td></tr></tbody></table></li><li><p>断言</p></li></ul><h2 id="6-8-PHP模式匹配函数"><a href="#6-8-PHP模式匹配函数" class="headerlink" title="6-8 | PHP模式匹配函数"></a>6-8 | PHP模式匹配函数</h2><ul><li><strong>preg_match函数（模式匹配及子模式匹配</strong>）</li><li><strong>preg_match_all</strong>函数</li><li><strong>preg_split</strong>函数</li></ul><h1 id="第8章-PHP访问数据库"><a href="#第8章-PHP访问数据库" class="headerlink" title="第8章 PHP访问数据库"></a>第8章 PHP访问数据库</h1><blockquote><p>PHP应用通常利用PHP的MySQLi扩展和PDO扩展访问数据库。</p><p>MySQLi扩展主要提供MySQLi、MySQLi_RESULT和MySQLi_STMT三个类，程序员可以使用这些类建立与MySQL数据库的连接、访问MySQL数据库以及处理查询结果。</p><p>PDO是一种数据访问抽象层，它为PHP程序员提供了一个轻量级的一致的编程接口。PDO扩展提供的应用程序编程接口主要包括PDO、PDOStatement和PDOException类。</p></blockquote><h2 id="8-1-使用MySQLi访问数据库"><a href="#8-1-使用MySQLi访问数据库" class="headerlink" title="8-1 | 使用MySQLi访问数据库"></a>8-1 | 使用MySQLi访问数据库</h2><h4 id="建立与MySQL服务器的连接"><a href="#建立与MySQL服务器的连接" class="headerlink" title="建立与MySQL服务器的连接"></a>建立与MySQL服务器的连接</h4><ul><li><p><strong>实例化</strong>MySQLi</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">construct</span> (<span class="hljs-keyword">string</span> <span class="hljs-variable">$host</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$username</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$passwd</span> [, <span class="hljs-keyword">string</span> <span class="hljs-variable">$dbname</span> = <span class="hljs-string">&quot;&quot;</span> [, <span class="hljs-keyword">int</span> <span class="hljs-variable">$port</span> = <span class="hljs-title function_ invoke__">ini_get</span>(<span class="hljs-string">&quot;mysqli.default_port&quot;</span>)]])<br></code></pre></td></tr></table></figure></li><li><p><strong>连接错误码和错误信息</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">int</span> <span class="hljs-variable">$connect_errno</span>                   <span class="hljs-comment">// 错误码，连接出错时非零</span><br><span class="hljs-keyword">string</span> <span class="hljs-variable">$connect_error</span>               <span class="hljs-comment">// 错误信息</span><br><span class="hljs-comment">//例：如$mysqli-&gt;connect_errno</span><br></code></pre></td></tr></table></figure></li><li><p><strong>关闭连接</strong></p><p>bool close()                         // 关闭与数据库服务器的连接</p></li></ul><p>例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;!DOCTYPE html&gt;<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Content-type:text/html;charset=UTF-8&quot;</span>);<br><br>@ <span class="hljs-variable">$mysqli</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">mysqli</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;elective_manage&quot;</span>, <span class="hljs-number">3306</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$mysqli</span>-&gt;connect_errno) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;不能连接到数据库&lt;br/&gt;&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;成功连接至数据库！&quot;</span>;<br><span class="hljs-variable">$mysqli</span>-&gt;<span class="hljs-title function_ invoke__">close</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="访问MySQL数据库"><a href="#访问MySQL数据库" class="headerlink" title="访问MySQL数据库"></a>访问MySQL数据库</h4><ul><li><strong>设置字符集</strong></li><li><strong>选择数据库</strong></li><li><strong>执行sql语句</strong></li><li><strong>获取受影响行数</strong></li></ul><p>例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;!DOCTYPE html&gt;<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Content-type:text/html;charset=UTF-8&quot;</span>);<br><br>@ <span class="hljs-variable">$mysqli</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">mysqli</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;elective_manage&quot;</span>, <span class="hljs-number">3306</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$mysqli</span>-&gt;connect_errno) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;不能连接到数据库&lt;br/&gt;&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-variable">$mysqli</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;SET NAMES &#x27;utf8&#x27;&quot;</span>);<br><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;INSERT INTO opencourse VALUES(null, &#x27;2015-2016-1&#x27;, &#x27;0901011008&#x27;, &#x27;1011&#x27;, default),&quot;</span><br>        . <span class="hljs-string">&quot;(null, &#x27;2015-2016-1&#x27;, &#x27;0901011008&#x27;, &#x27;1016&#x27;, default)&quot;</span>;<br><br><span class="hljs-variable">$result</span> = <span class="hljs-variable">$mysqli</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-variable">$sql</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-variable">$result</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;SQL语句执行失败！&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;插入的行数：&quot;</span>, <span class="hljs-variable">$mysqli</span>-&gt;affected_rows;<br><br><span class="hljs-variable">$mysqli</span>-&gt;<span class="hljs-title function_ invoke__">close</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="处理查询结果（MySQLi-RESULT）"><a href="#处理查询结果（MySQLi-RESULT）" class="headerlink" title="处理查询结果（MySQLi_RESULT）"></a>处理查询结果（MySQLi_RESULT）</h4><ul><li><strong>获取行数和列数</strong></li><li><strong>移动游标</strong></li><li><strong>返回查询结果的一行</strong></li><li><strong>释放查询结果</strong></li></ul><p>例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;!DOCTYPE html&gt;<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Content-type:text/html;charset=UTF-8&quot;</span>);<br><br>@ <span class="hljs-variable">$mysqli</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">mysqli</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;elective_manage&quot;</span>, <span class="hljs-number">3306</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$mysqli</span>-&gt;connect_errno) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;不能连接到数据库&lt;br/&gt;&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-variable">$mysqli</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;SET NAMES &#x27;utf8&#x27;&quot;</span>);<br><span class="hljs-variable">$query</span> = <span class="hljs-string">&quot;SELECT sn, sname, birthday FROM student WHERE gender=&#x27;男&#x27;&quot;</span>;<br><span class="hljs-variable">$result</span> = <span class="hljs-variable">$mysqli</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-variable">$query</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-variable">$result</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;SQL语句执行失败！&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;共&quot;</span> . <span class="hljs-variable">$result</span>-&gt;num_rows . <span class="hljs-string">&quot;行：&lt;br /&gt;&quot;</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-variable">$row</span> = <span class="hljs-variable">$result</span>-&gt;<span class="hljs-title function_ invoke__">fetch_array</span>()) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;sn&#x27;</span>] . <span class="hljs-string">&quot; &quot;</span> . <span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;sname&#x27;</span>] . <span class="hljs-string">&quot; &quot;</span> . <span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;birthday&#x27;</span>] . <span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">foreach($result as $row) &#123;</span><br><span class="hljs-comment">    echo $row-&gt;sn . &quot; &quot; . $row-&gt;sname . &quot; &quot; . $row-&gt;birthday . &quot;&lt;br /&gt;&quot;;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable">$result</span>-&gt;<span class="hljs-title function_ invoke__">free</span>();<br><span class="hljs-variable">$mysqli</span>-&gt;<span class="hljs-title function_ invoke__">close</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="事务管理（MySQLi）"><a href="#事务管理（MySQLi）" class="headerlink" title="事务管理（MySQLi）"></a>事务管理（MySQLi）</h4><ul><li><p><strong>初始化一个事务</strong></p><p>bool <strong>begin_transaction</strong>(void)</p></li><li><p><strong>提交事务</strong></p><p>bool <strong>commit</strong>(void)</p></li><li><p><strong>回滚事务</strong></p><p>bool <strong>rollback</strong>(void)</p></li></ul><h2 id="8-2-使用预处理语句"><a href="#8-2-使用预处理语句" class="headerlink" title="8-2 | 使用预处理语句"></a>8-2 | 使用预处理语句</h2><h4 id="创建预处理语句"><a href="#创建预处理语句" class="headerlink" title="创建预处理语句"></a>创建预处理语句</h4><ul><li>初始化语句对象</li><li>准备SQL语句</li></ul><h4 id="执行预处理语句"><a href="#执行预处理语句" class="headerlink" title="执行预处理语句"></a>执行预处理语句</h4><ul><li>绑定参数</li><li>执行</li><li>产生缓存结果集</li><li>获取受影响的行数</li></ul><h4 id="处理查询结果"><a href="#处理查询结果" class="headerlink" title="处理查询结果"></a>处理查询结果</h4><ul><li>获取列数和行数</li><li>移动游标</li><li>绑定结果</li><li>获取查询结果</li><li>释放缓存结果集</li><li>关闭语句对象</li></ul><h2 id="8-3-使用PDO访问数据库"><a href="#8-3-使用PDO访问数据库" class="headerlink" title="8-3 | 使用PDO访问数据库"></a>8-3 | 使用PDO访问数据库</h2><blockquote><p>PDO（PHP Data Object）是一种PHP扩展，它的使用与MySQLi扩展非常相似，但PDO不仅能用于访问MySQL数据库，也能用于访问其他的数据库。</p><p>PDO是一种数据访问抽象层，它为PHP程序员提供了一个轻量级的一致的编程接口。利用它，PHP应用能够用相同的代码访问各种不同的数据库。</p><p>PDO编程接口由3个类组成，包括PDO类、PDOStatement类和PDOException类。</p></blockquote><h4 id="建立与数据库服务器的连接"><a href="#建立与数据库服务器的连接" class="headerlink" title="建立与数据库服务器的连接"></a>建立与数据库服务器的连接</h4><p>一个PDO类的实例对象代表PHP与数据库服务器之间的一个连接。</p><p>construct(string $dsn [, string $username [, string $password]])</p><p>参数$dsn表示数据源名称（Data Source Name），包含与数据库连接所需的信息，如服务器的IP地址、端口号、数据库的名称等。$dsn由PDO驱动器名开头，紧跟一个冒号，后面的语法通常与具体的PDO驱动器有关。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;!DOCTYPE html&gt;<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Content-type:text/html;charset=UTF-8&quot;</span>);<br><br><span class="hljs-variable">$dsn</span> = <span class="hljs-string">&#x27;mysql:dbname=elective_manage;host=127.0.0.1&#x27;</span>;<br><span class="hljs-variable">$user</span> = <span class="hljs-string">&#x27;root&#x27;</span>;<br><span class="hljs-variable">$password</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable">$pdo</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">PDO</span>(<span class="hljs-variable">$dsn</span>, <span class="hljs-variable">$user</span>, <span class="hljs-variable">$password</span>);<br>&#125; <span class="hljs-keyword">catch</span> (PDOException <span class="hljs-variable">$e</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;连接失败: &#x27;</span> . <span class="hljs-variable">$e</span>-&gt;<span class="hljs-title function_ invoke__">getMessage</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;成功连接至elective_manage数据库&#x27;</span>;<br><span class="hljs-variable">$pdo</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h4><ul><li>执行增删改</li><li>获取错误码和错误信息</li><li>执行查询</li></ul><h4 id="使用预处理语句"><a href="#使用预处理语句" class="headerlink" title="使用预处理语句"></a>使用预处理语句</h4><ul><li>创建预处理语句</li><li>绑定参数</li><li>执行预处理语句</li></ul><h4 id="访问结果集"><a href="#访问结果集" class="headerlink" title="访问结果集"></a>访问结果集</h4><ul><li>获取列数</li><li>绑定列</li><li>获取结果集的一行</li><li>获取一行中的单列值</li><li>获取所有行</li></ul><h4 id="管理事物"><a href="#管理事物" class="headerlink" title="管理事物"></a>管理事物</h4><ul><li>初始化一个事物</li><li>提交事物</li><li>回滚事物</li></ul><h2 id="8-4-分页显示"><a href="#8-4-分页显示" class="headerlink" title="8-4  | 分页显示"></a>8-4  | 分页显示</h2><p>要显示的数据集通常通过查询数据库获得。在实现分页显示时，可以有两种策略：一是每次只从数据库获取当前页的数据并呈现；另一种是预先从数据库获取整个数据集，然后把当前页呈现出来。</p><p>为实现分页显示功能，通常需要引入以下变量：</p><ul><li><p><strong>$rows</strong>：数据集的大小，即数据集包含的记录数。</p></li><li><p><strong>$pageSize</strong>：页面大小，即一次显示几条记录（行）。</p></li><li><p><strong>$pageCount</strong>：总页数，可根据$rows与$pageSize计算获得：</p><p>$pageCount = (int)ceil($rows/$pageSize);</p></li><li><p><strong>$currentPage</strong>：当前页码。该变量的初值可以设置为1，之后能由用户指定。</p></li><li><p><strong>$first</strong>：当前页第1条记录在数据集中的索引。可以根据$currentPage和$pageSize计算获得：</p><p>$first = ($currentPage-1)*$pageSize;</p></li></ul><h1 id="第9章-表单与会话"><a href="#第9章-表单与会话" class="headerlink" title="第9章 表单与会话"></a>第9章 表单与会话</h1><h2 id="9-1-表单处理"><a href="#9-1-表单处理" class="headerlink" title="9-1 | 表单处理"></a>9-1 | 表单处理</h2><h4 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h4><ul><li><p>GET方法</p><p>GET方法适合少量数据的提交，GET方法不适合提交密码等敏感数据。</p></li><li><p>POST方法</p><p>POST方法的请求数据放置在请求体中、而不是URL中，所以其信息相对较为安全，且传输的数据量没有大小限制，可以非常大。</p></li></ul><h4 id="获取表单数据"><a href="#获取表单数据" class="headerlink" title="获取表单数据"></a>获取表单数据</h4><ol><li><p>获取请求方式</p><p>$_SERVER[“REQUEST_METHOD”] ， “GET”|”POST”</p></li><li><p>获取GET数据</p><p>$_GET[“参数名”]，如$_GET[“name”]</p><p>$_GET是一个包含通过GET方法传递给当前脚本的请求参数的数组</p></li><li><p>获取POST数据</p><p>$_POST[“参数名”]，如$_POST[“name”]</p><p>$_POST是一个包含通过POST方法传递给当前脚本的请求参数数组</p></li></ol><h4 id="验证表单数据"><a href="#验证表单数据" class="headerlink" title="验证表单数据"></a>验证表单数据</h4><h2 id="9-2-会话管理"><a href="#9-2-会话管理" class="headerlink" title="9-2 | 会话管理"></a>9-2 | 会话管理</h2><h2 id="9-3-页面跳转与重定向"><a href="#9-3-页面跳转与重定向" class="headerlink" title="9-3 | 页面跳转与重定向"></a>9-3 | 页面跳转与重定向</h2><p>PHP中实现网页跳转的几种常见技术</p><ul><li>使用超链接&lt;a&gt;元素</li><li>使用表单&lt;form&gt;元素</li><li>使用特定的&lt;meta&gt;标记</li><li>使用PHP中特定的header函数</li></ul><h2 id="9-4-文件上传与下载"><a href="#9-4-文件上传与下载" class="headerlink" title="9-4 | 文件上传与下载"></a>9-4 | 文件上传与下载</h2><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><ul><li><p>文件的打开与关闭</p><p>(1) fopen函数</p><p>resource fopen($filename, $mode [, bool $use_include_path=false])</p><p>(2) fclose函数</p><p>bool fclose(resource $handle)</p></li><li><p>文件的写入</p><p>(1) fwrite函数</p><p>int fwrite(resource $handle, string $string [, int $length])</p><p>(2) fputcsv函数</p><p>int fputcsv(resource $handle, array $fields [, string $delimiter = ‘,’ [, string $enclosure = ‘“‘]])</p></li><li><p>文件的读取</p><p>(1) fread函数</p><p>string fread(resource $handle, int $length)</p><p>(2) fgets函数</p><p>string fgets(resource $handle [, int $length])</p><p>(3) fgetcsv函数</p><p>array fgetcsv(resource $handle [, int $length=0 [, string $delimiter=’,’ [, string $enclosure=’”‘]]])</p><p>(4) feof函数</p><p>bool feof(resource $handle)</p><p>(5) rewind函数</p><p>bool rewind(resource $handle)</p></li><li><p>其他函数</p><p>(1) readfile函数</p><p>int <strong>readfile</strong>(string $filename [, bool $use_include_path = false])</p><p>函数读取指定文件的内容并将其写入到输出缓冲区。</p><p>函数返回实际从文件中读入的字节数。</p><p>(2) filesize函数</p><p>int <strong>filesize</strong>(string $filename)</p><p>函数返回指定文件的大小，即文件的字节数。</p><p>(3) iconv函数</p><p>string <strong>iconv</strong>(string $in_charset , string $out_charset , string $str)</p><p>函数将字符串$str从$in_charset字符集编码转换为</p><p>$out_charset字符集编码。</p></li></ul><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><ul><li>文件上传表单</li><li>获取上传文件</li></ul><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><ul><li>用a元素直接打开文件</li><li>通过读取文件内容打开文件</li></ul><h1 id="第10章-使用数组"><a href="#第10章-使用数组" class="headerlink" title="第10章 使用数组"></a>第10章 使用数组</h1><h2 id="10-1-数组"><a href="#10-1-数组" class="headerlink" title="10-1 | 数组"></a>10-1 | 数组</h2><ul><li>在PHP中，数组是有序的映射。一个数组由若干元素组成，每个元素是一个键-值对。键可以是整数也可以是字符串，值可以是任意类型。</li><li>在一个PHP数组中，键的类型可以是混合：有些元素的键是整数，有些元素的键是字符串。</li><li>如果一个数组的元素的值本身就是数组，就可形成多维数组。</li><li>在PHP中，不要求一个数组的各元素的值具有相同的类型。</li></ul><h2 id="10-2-创建和初始化数组"><a href="#10-2-创建和初始化数组" class="headerlink" title="10-2 | 创建和初始化数组"></a>10-2 | 创建和初始化数组</h2><h4 id="使用array语言结构使用array语言结构"><a href="#使用array语言结构使用array语言结构" class="headerlink" title="使用array语言结构使用array语言结构"></a><strong>使用array语言结构使用array语言结构</strong></h4><p>①语言结构array用于创建并初始化一个数组：</p><p>array (</p><p>  [[&lt;key&gt;]=&gt;&lt;value&gt; [, [&lt;key&gt;]=&gt;&lt;value&gt;]*]</p><p>)</p><p>②在指定一个元素时，键是可以缺省的。此时，PHP将使用之前已经被使用的最大的整数键加1作为该元素的键，且至少是0。</p><p>③一个数组元素的值可以是标量类型数据，也可以是数组本身，这样就能形成二维数组和多维数组。多维数组可以使用嵌套的array来创建。</p><h4 id="使用range函数"><a href="#使用range函数" class="headerlink" title="使用range函数"></a><strong>使用range函数</strong></h4><p>①range函数可以快速创建一个由指定范围内的值填充的数组。其语法格式如下：</p><p>​    array range (mixed $start , mixed $end [, number $step ])</p><p>②参数$start、$end和$step分别表示用于填充新数组的初值、最大值和步长。参数$step是可选的，其默认值为1。</p><h2 id="10-3-操作数组元素"><a href="#10-3-操作数组元素" class="headerlink" title="10-3 | 操作数组元素"></a>10-3 | 操作数组元素</h2><h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>①可以通过方括号访问数组元素，其格式如下：<br> &lt;array&gt;[&lt;key&gt;]</p><p>   说明：访问数组元素时，方括号和花括号是可以互换的，如$arr[5]可以用$arr{5}代替。</p><p>②bool array_key_exists(mixed $key, array $array)<br> 检测指定的$key是否为数组$array的某个元素的键，若是返回true，否则返回false。</p><p>③bool in_array(mixed $needle, array $haystack [, bool $strict ] )<br> 检测指定值$needle是否是数组$haystack的某个元素的值，若是返回true，否则返回false。<br> 参数$strict是可选的，默认值为false，此时采用相等比较（==）。若将其设置为true，则采用全等比较（===）。</p><p>④mixed array_search(mixed $needle, array $haystack [, bool $strict] )<br> 检测指定值$needle是否是数组$haystack的某个元素的值，若是函数返回相应元素的键，否则返回false。若数组中存在多个元素具有该值，则返回第一个元素的键。</p><h4 id="修改、添加或删除数组元素"><a href="#修改、添加或删除数组元素" class="headerlink" title="修改、添加或删除数组元素"></a>修改、添加或删除数组元素</h4><p>①利用方括号同样可以修改数组元素或添加数组元素。这只需要将值赋给指定的的元素即可。<br> 格式1：&lt;array&gt;[&lt;key&gt;] = &lt;value&gt;;</p><p>​        将数组元素array[key]的值替换成value。如果数组中原先没有该元素，那么添加这样一个元素。</p><p> 格式2：&lt;array&gt;[] = &lt;value&gt;;</p><p>​        在数组中添加一个元素，元素的值为value，键为数组之前已经被用的最大的整数键加1，或者为0。</p><p>②使用unset函数可以删除一个数组元素，甚至整个数组。</p><p>例如：<br> unset($new_arr[‘y’]);    // 删除数组new_arr中键为’y’的元素<br> unset($new_arr);     // 删除整个数组new_arr </p><h4 id="在数组头部或尾部操作元素"><a href="#在数组头部或尾部操作元素" class="headerlink" title="在数组头部或尾部操作元素"></a><strong>在数组头部或尾部操作元素</strong></h4><p>①array_unshift()函数<br> array_unshift()函数用于在参数数组$array的头部插入一个或多个元素，其语法格式如下：<br> int array_unshift (array &amp;$array , mixed $value1 [, mixed $… ])<br> 新插入元素的键是数值键，与数组中原先已存在的数值键一起，重新设置为从0开始的连续整数。数组中原有的字符串键不变。函数返回插入元素后数组的元素个数。</p><p>②array_shift()函数<br> array_shift()函数用于从参数数组的头部删除一个元素，其语法格式如下：<br> mixed array_shift (array &amp;$array)<br> 第一个元素被删除后，数组中其他数值键被重新设置为以0开始的连续整数。函数返回被删除元素的值。若数组原先是空的，函数返回NULL。</p><p>③array_push()函数<br> array_push()函数用于在参数数组array的尾部添加一个或多个元素，其语法格式如下：<br> int array_push (array &amp;$array, mixed $value1 [, mixed $… ] )<br> 新添加元素的键是数值键，从原有的最大数值键加1开始设置。如果原先没有数值键元素，则新添加元素的键从0开始设置。函数返回添加元素后数组的元素数。</p><p>④array_pop()函数<br> array_pop()函数用于从参数数组的尾部删除一个元素，其语法格式如下：<br> mixed array_pop (array &amp;$array)<br> 函数返回被删除的元素的值。若数组原先是空的，函数返回NULL。</p><h2 id="10-4-遍历数组"><a href="#10-4-遍历数组" class="headerlink" title="10-4 | 遍历数组"></a>10-4 | 遍历数组</h2><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><p>①当创建一个数组时，其数组指针初始指向第一个元素。</p><p>②mixed next (array &amp;$array)<br> 移动指定数组$array的内部指针至下一个元素，并返回下一个元素的值。</p><p>③mixed prev (array &amp;$array)<br> 移动指定数组$array的内部指针至上一个元素，并返回上一个元素的值。</p><p>④mixed reset (array &amp;$array)<br> 移动指定数组$array的内部指针至第一个元素，并返回第一个元素的值。</p><p>⑤mixed end (array &amp;$array)<br> 移动指定数组$array的内部指针至最后一个元素，并返回最后一个元素的值。</p><p>⑥mixed current (array &amp;$array)<br> 返回数组$array当前元素的值。如果数组为空，或者数组指针移出了数组的范围，函数返回false。</p><p>⑦mixed key (array &amp;$array)<br> 返回数组$array当前元素的键。如果数组为空，或者数组指针移出了数组的范围，函数返回NULL。</p><h4 id="使用for语句遍历数组"><a href="#使用for语句遍历数组" class="headerlink" title="使用for语句遍历数组"></a><strong>使用for语句遍历数组</strong></h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$fruit</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;cranberry&#x27;</span>);<br><span class="hljs-variable">$c</span> = <span class="hljs-title function_ invoke__">count</span>(<span class="hljs-variable">$fruit</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span>&lt;<span class="hljs-variable">$c</span>; <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$fruit</span>[<span class="hljs-variable">$i</span>].<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="使用while语句遍历数组"><a href="#使用while语句遍历数组" class="headerlink" title="使用while语句遍历数组"></a><strong>使用while语句遍历数组</strong></h4><p>①key函数、current函数、next函数。</p><p>②each函数、list结构</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$fruit</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> =&gt; <span class="hljs-string">&#x27;cranberry&#x27;</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-variable">$key</span>=<span class="hljs-title function_ invoke__">key</span>(<span class="hljs-variable">$fruit</span>)) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$key</span>.<span class="hljs-string">&quot;=&gt;&quot;</span>.<span class="hljs-title function_ invoke__">current</span>(<span class="hljs-variable">$fruit</span>).<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br>    <span class="hljs-title function_ invoke__">next</span>(<span class="hljs-variable">$fruit</span>);<br>&#125;<br><span class="hljs-comment">// 使用each函数和list语言结构</span><br><span class="hljs-title function_ invoke__">reset</span>(<span class="hljs-variable">$fruit</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">list</span>(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>) = <span class="hljs-title function_ invoke__">each</span>(<span class="hljs-variable">$fruit</span>)) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$key</span>.<span class="hljs-string">&quot;=&gt;&quot;</span>.<span class="hljs-variable">$value</span>.<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="使用foreach语句遍历数组"><a href="#使用foreach语句遍历数组" class="headerlink" title="使用foreach语句遍历数组"></a><strong>使用foreach语句遍历数组</strong></h4><p>①格式1：<br> foreach (<array_expression> as &lt;$value&gt;)<br>   &lt;statement&gt;</p><p>②格式2：<br> foreach (<array_expression> as &lt;$key&gt; =&gt; &lt;$value&gt;)<br>   &lt;statement&gt;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$fruit</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> =&gt; <span class="hljs-string">&#x27;cranberry&#x27;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$fruit</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span>=&gt;<span class="hljs-variable">$value</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$key</span>.<span class="hljs-string">&quot;=&gt;&quot;</span>.<span class="hljs-variable">$value</span>.<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="10-5-数组运算符"><a href="#10-5-数组运算符" class="headerlink" title="10-5 | 数组运算符"></a>10-5 | 数组运算符</h2><p>PHP提供了一些数组运算符，可以实现数组的联合、相等和不相等比较。</p><table><thead><tr><th>运算符</th><th>名称</th><th>例子</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>联合</td><td>$a + $b</td><td>返回一个包含了$a和$b两个数组中所有元素的数组。</td></tr><tr><td>==</td><td>松散相等</td><td>$a == $b</td><td>如果数组$a和数组$b具有相同的键值对，返回true。</td></tr><tr><td>===</td><td>严格相等</td><td>$a === $b</td><td>如果数组$a和数组$b具有相同的键值对以及相同的顺序和类型，返回true。</td></tr><tr><td>!=（&lt;&gt;）</td><td>不松散相等</td><td>$a != $b</td><td>如果数组$a和数组$b不是松散相等，返回true。</td></tr><tr><td>!==</td><td>不严格相等</td><td>$a !== $b</td><td>如果数组$a和数组$b不是严格相等，返回true。</td></tr></tbody></table><h2 id="10-6-数组排序"><a href="#10-6-数组排序" class="headerlink" title="10-6 | 数组排序"></a>10-6 | 数组排序</h2><ul><li><h4 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h4><p>bool sort (array &amp;$array [, int $sort_flags])</p><p>①函数根据元素值对数$array各元素从小到大进行排序。排序后，各元素的键重新设置为从0为开始的连续的整数。若排序成功，函数返回true；否则，返回false</p><p>②可选参数sort_flags的取值：<br> SORT_REGULAR：默认值。 正常比较（不改变类型）。<br> SORT_NUMERIC：数值化比较。<br> SORT_STRING：字符串化比较。<br> SORT_LOCALE_STRING：基于当前场所的字符串化比较。<br> SORT_NATURAL：自然顺序比较。<br> SORT_FLAG_CASE：能与SORT_STRING或SORT_NATURAL组合，以便比较时不区分大小写。</p></li><li><h4 id="asort和ksort函数"><a href="#asort和ksort函数" class="headerlink" title="asort和ksort函数"></a>asort和ksort函数</h4><p>①bool asort ( array &amp;$array [, int $sort_flags])<br> 该函数根据元素值对数组$array各元素从小到大进行排序。排序时，各元素的键和值保持关联。若排序成功，函数返回true；否则，返回false。</p><p>②bool ksort ( array &amp;$array [, int $sort_flags])<br> 该函数根据元素键对数组$array各元素从小到大进行排序。排序时，各元素的值和键保持关联。若排序成功，函数返回true；否则，返回false。</p></li><li><h4 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h4><p>① bool rsort(array &amp;$array [, int $sort_flags])</p><pre><code class="hljs"> bool arsort(array &amp;$array [, int $sort_flags]) bool krsort(array &amp;$array [, int $sort_flags])</code></pre><p>②上面三个函数分别与sort、asort和ksort函数相对应。</p></li><li><h4 id="用户定义排序"><a href="#用户定义排序" class="headerlink" title="用户定义排序"></a>用户定义排序</h4></li></ul><h2 id="10-7-并集、交集和差集"><a href="#10-7-并集、交集和差集" class="headerlink" title="10-7 | 并集、交集和差集"></a>10-7 | 并集、交集和差集</h2><h4 id="求数组的并集"><a href="#求数组的并集" class="headerlink" title="求数组的并集"></a>求数组的并集</h4><p>①合并数组可以将若干数组合并在一起，返回一个包含各数组所有元素的数组。合并时，各参数数组依次将其各元素按其原先的顺序追加到结果数组中，各数值键被重新设置为从0开始的连续整数。</p><p>②array array_merge(array $array1 [, array $…])<br> array array_merge_recursive ( array $array1 [, array $…])</p><p>③array_merge_recursive函数与array_merge函数的功能大致相同，区别在于：如果合并的数组中存在有相同字符串键的元素，不是执行替换操作，而是合并操作，即将两个值合并成一个数组作为元素值。如果两个值本身就是数组，就将两个数组合并成一个数组作为元素值。所以这是一种递归合并。</p><h4 id="求数组的交集"><a href="#求数组的交集" class="headerlink" title="求数组的交集"></a>求数组的交集</h4><p>①array array_intersect ( array $array1, array $array2 [, array $array3]*)<br> 函数返回一个数组，这个数组仅包含第一个参数数组中其值在其他所有参数数组中都出现的元素。</p><p>②array array_intersect_assoc ( array $array1,  array $array2 [, array $array3]*)<br> 函数返回一个数组，这个数组仅包含第一个参数数组中其键-值对在其他所有参数数组中都出现的元素。</p><h4 id="求数组的差集"><a href="#求数组的差集" class="headerlink" title="求数组的差集"></a>求数组的差集</h4><p>①array array_diff ( array $array1, array $array2 [, array $array3]*)<br> 返回一个数组，这个数组仅包含第一个参数数组中其值没有在任何其他参数数组中出现的元素。</p><p>②array array_diff_assoc ( array $array1,  array $array2 [,array $array3]*)<br> 返回一个数组，这个数组仅包含第一个参数数组中其键-值对没有在任何其他参数数组中出现的元素。</p><h2 id="10-8-其他常用的数组函数"><a href="#10-8-其他常用的数组函数" class="headerlink" title="10-8 | 其他常用的数组函数"></a>10-8 | 其他常用的数组函数</h2><h4 id="计数与统计"><a href="#计数与统计" class="headerlink" title="计数与统计"></a>计数与统计</h4><p>①int count(array $array [, int $mode])<br> 返回数组中元素的个数。参数mode的取值如下：<br> COUNT_NORMAL：默认值。仅统计最外层数组的元素个数。<br> COUNT_RECURSIVE：递归统计各层数组的元素个数。</p><p>②array array_count_values(array $array)<br> 返回一个关联数组，其元素的键是参数数组中元素的值，相应的值是该键作为元素值在参数数组中出现的次数（频度）。</p><p>③number array_sum(array $array)<br> 计算参数数组中各元素值的和，返回一个整数或浮点数。<br> 对非数值型元素值，函数会将其转换成数值（大多数情况为0）。函数对内部数组的元素值不会进行递归累加。</p><h1 id="第11章-PHP面向对象程序设计"><a href="#第11章-PHP面向对象程序设计" class="headerlink" title="第11章 PHP面向对象程序设计"></a>第11章 PHP面向对象程序设计</h1><p>…….</p><h1 id="第12章-Ajax与jQuery"><a href="#第12章-Ajax与jQuery" class="headerlink" title="第12章 Ajax与jQuery"></a>第12章 Ajax与jQuery</h1><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><ul><li>Ajax是Asynchronous JavaScript And XML的首字母缩写，称为异步JavaScript和XML。</li><li>Ajax不是一种新的编程语言或技术，而是现有的几种技术的一种结合。它产生了一种新的、强大的开发Web应用的方法。Ajax包括：<ul><li>基于HTML+CSS来呈现信息。</li><li>使用XMLHttpRequest从Web服务器异步获取数据。</li><li>利用XML、JSON等来表示数据。</li><li>通过DOM实现页面的局部更新及动态效果。</li><li>运用JavaScript将各个方面绑定在一起。</li></ul></li><li>利用Ajax技术，Web应用可以在后台异步地向服务器发送数据和获取数据，而不会妨碍原有页面的显示和行为；Web应用能够动态地局部更新原有的页面，而不需要完整地重载一个页面。</li><li>Ajax的优点<ul><li>带来持续、动态的用户体验。</li><li>减轻网络通信的负担。</li><li>减轻服务器的负担。</li><li>创建桌面应用风格的界面。</li><li>促进数据和页面呈现的分离。</li></ul></li><li>Ajax的缺点<ul><li>无法正常使用书签化和后退按钮的功能。</li><li>兼容性不理想。不同的浏览器对Ajax的支持状况有所不同。</li><li>使用Ajax的脚本代码保存在HTML页中，不利于代码的保密。</li></ul></li></ul><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><ul><li>jQuery是一个“写的更少，但做的更多”的轻量级JavaScript库。涉及：<ul><li>HTML 元素选取</li><li>HTML 元素操作</li><li>CSS 操作</li><li> HTML 事件处理</li><li>HTML元素的动画效果</li><li>Ajax等</li></ul></li><li>jQuery库位于一个JavaScript文件中，其中包含了所有的jQuery函数和方法。<br> 可以通过下面的标记把jQuery添加到网页中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">“text/javascript”</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">src</span>=<span class="hljs-string">“jquery-3.1.0.min.js”</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>jQuery是一个开源项目，可以从<a href="http://www.jquery.com免费下载.共有两个版本的/">www.jquery.com免费下载。共有两个版本的</a> jQuery 可供下载：一份是精简过的，另一份是未压缩的（供调试或阅读）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>解忧杂货</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 43.字符串相乘</title>
    <link href="/2022/05/02/LC%2043.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <url>/2022/05/02/LC%2043.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-43-字符串相乘"><a href="#LC-43-字符串相乘" class="headerlink" title="LC 43.字符串相乘"></a>LC 43.字符串相乘</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>对每次得到的字符串进行累加，可以使用「<a href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a>」的做法。</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>注意</strong>：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>如果 num1 和 num2 之一是 0，则直接将 0 作为结果返回即可。</p><p>如果 num1 和 num2 都不是 0，则可以通过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。这道题中，被乘数是 num1，乘数是 num2。</p><p>需要注意的是，num2 除了最低位以外，其余的每一位的运算结果都需要补 0。</p><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/QQ%E6%88%AA%E5%9B%BE20220502192051.png?raw=true" alt="方法一：做加法"></p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        string ans = <span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-type">int</span> m = num1.<span class="hljs-built_in">size</span>(),n = num2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>        &#123;<br>            string cur;<br>            <span class="hljs-type">int</span> add = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//末尾补0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>; j&gt;i; j--)<br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> y = num2[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span>; j--)<br>            &#123;<br>                <span class="hljs-type">int</span> x = num1[j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-type">int</span> sum = x*y+add;<br>                cur.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span>+sum%<span class="hljs-number">10</span>);<br>                add = sum/<span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(add != <span class="hljs-number">0</span>)<br>            &#123;<br>                cur.<span class="hljs-built_in">push_back</span>(add%<span class="hljs-number">10</span>);<br>                add = add/<span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-built_in">reverse</span>(cur.<span class="hljs-built_in">begin</span>(),cur.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">//字符串翻转</span><br>            ans = <span class="hljs-built_in">addStrings</span>(ans,cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//字符串相加 LeetCode 415</span><br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string &amp;num1,string &amp;num2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> i = num1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,j = num2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,add = <span class="hljs-number">0</span>;<br>        string ans;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> || j&gt;=<span class="hljs-number">0</span> || add != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x,y;<br>            <span class="hljs-keyword">if</span>(num1[i] &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                x = num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                x = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num2[j] &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                y = num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                y = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> sum = x+y+add;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span>+sum%<span class="hljs-number">10</span>);<br>            add = sum/<span class="hljs-number">10</span>;<br>            i--;<br>            j--;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>方法1的时间和空间复杂度较高，方法一的做法是从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。如果使用数组代替字符串存储结果，则可以减少对字符串的操作。</p><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/QQ%E6%88%AA%E5%9B%BE20220502192422.png?raw=true" alt="方法二：做乘法"></p><p>LeetCode题解：<a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五一&#39;s Vlog</title>
    <link href="/2022/05/01/%E4%BA%94%E4%B8%80-s-Vlog/"/>
    <url>/2022/05/01/%E4%BA%94%E4%B8%80-s-Vlog/</url>
    
    <content type="html"><![CDATA[<h2 id="五一’s-Vlog"><a href="#五一’s-Vlog" class="headerlink" title="五一’s Vlog"></a>五一’s Vlog</h2><blockquote><p>五一’s Vlog 坐标青岛市 三万步 早九晚十 打卡东方影都 中山公园 湛山寺 八大关 海水浴场 小红楼美术馆 栈桥… </p><p>小红楼美术馆贼拉nice的一个地方 非常适合拍照 对于喜欢周杰伦的人来说真的是一种情怀</p></blockquote><blockquote><p>小小愿望：解封之后可以离开青岛市去泰安夜爬泰山看日出</p></blockquote><p>在东方影都 第二海水浴场和小红楼美术馆拍了几张我觉得挺有艺术感和氛围感的img</p><p>浅浅留念一下</p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181535.jpg" alt="微信图片_20220503181535"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181418.jpg" alt="微信图片_20220503181418"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181506.jpg" alt="微信图片_20220503181506"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181513.jpg" alt="微信图片_20220503181513"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181428.jpg" alt="微信图片_20220503181428"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181527.jpg" alt="微信图片_20220503181527"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181457.jpg" alt="微信图片_20220503181457"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181520.jpg" alt="微信图片_20220503181520"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181402.jpg" alt="微信图片_20220503181402"></p><p><img src="https://img.yiqiangshiyia.cn/blog/70BB5589229B05B912D4991998BFAB7A.jpg" alt="70BB5589229B05B912D4991998BFAB7A"></p><blockquote><p>哈哈哈 第一次以Blog的方式记录生活 我是一个不太喜欢记录生活的人 但是偶尔记录一下也还挺哦可的！！！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vlog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 417.太平洋大西洋水流问题 DFS+BFS</title>
    <link href="/2022/04/27/LC%20417.%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98%20DFS+BFS/"/>
    <url>/2022/04/27/LC%20417.%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98%20DFS+BFS/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-417-太平洋大西洋水流问题"><a href="#LC-417-太平洋大西洋水流问题" class="headerlink" title="LC 417.太平洋大西洋水流问题"></a>LC 417.太平洋大西洋水流问题</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>这是一道学习BFS和DFS绝绝子的题目，之前没怎么做过BFS和DFS的题目，一直都不太会，每日一题遇到了这么典型的题目当然要搞清楚啦。4.27今天一天的任务就是搞懂这道题BFS和DFS两种解法。</p></blockquote><p><strong>DFS利用了递归的思想</strong></p><p><strong>BFS利用了队列的思想</strong></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">https://leetcode-cn.com/problems/pacific-atlantic-water-flow/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法1：深度优先搜索（DFS）"><a href="#方法1：深度优先搜索（DFS）" class="headerlink" title="方法1：深度优先搜索（DFS）"></a>方法1：深度优先搜索（DFS）</h4><blockquote><p>雨水的流动方向是从高到低，每个单元格上的雨水只能流到高度小于等于当前单元格的相邻单元格。从一个单元格开始，通过搜索的方法模拟雨水的流动，则可以判断雨水是否可以从该单元格流向海洋。</p><p>如果直接以每个单元格作为起点模拟雨水的流动，则会重复遍历每个单元格，导致时间复杂度过高。为了降低时间复杂度，可以从矩阵的边界开始反向搜索寻找雨水流向边界的单元格，反向搜索时，每次只能移动到高度相同或更大的单元格。</p><p>由于矩阵的左边界和上边界是太平洋，矩阵的右边界和下边界是大西洋，因此从矩阵的左边界和上边界开始反向搜索即可找到雨水流向太平洋的单元格，从矩阵的右边界和下边界开始反向搜索即可找到雨水流向大西洋的单元格。</p><p>可以<strong>使用深度优先搜索实现反向搜索</strong>，搜索过程中需要记录每个单元格是否可以从太平洋反向到达以及是否可以从大西洋反向到达。反向搜索结束之后，遍历每个网格，如果一个网格既可以从太平洋反向到达也可以从大西洋反向到达，则该网格满足太平洋和大西洋都可以到达，将该网格添加到答案中。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> dirs[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;  <span class="hljs-comment">//定义方向数组，分别表示向上下左右四个方向流动</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; heights;  <span class="hljs-comment">//定义一个全局数组</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;ocean)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> m = ocean.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = ocean[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(ocean[row][col])<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ocean[row][col] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//分别对上下左右四个方向进行搜索</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> newRow = row+dirs[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> newCol = col+dirs[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(newRow &gt;= <span class="hljs-number">0</span> &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;= <span class="hljs-number">0</span> &amp;&amp; newCol &lt; n &amp;&amp; heights[newRow][newCol] &gt;= heights[row][col])<br>            &#123;<br>                <span class="hljs-built_in">dfs</span>(newRow,newCol,ocean);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;heights = heights;<br>        <span class="hljs-type">int</span> m = heights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//防止重复遍历单元格，增加时间复杂度，定义bool类型数组进行标记,默认值为false</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">pacific</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">atlantic</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">//从左边缘开始dfs可以流入太平洋的单元格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>,pacific);<br>        &#125;<br>        <span class="hljs-comment">//从上边缘开始dfs可以流入太平洋的单元格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;n; j++)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,j,pacific);<br>        &#125;<br>        <span class="hljs-comment">//从右边缘开始dfs可以流入大西洋的单元格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(i,n<span class="hljs-number">-1</span>,atlantic);<br>        &#125;<br>        <span class="hljs-comment">//从下边缘开始dfs可以流入大西洋的单元格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n<span class="hljs-number">-1</span>; j++)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(m<span class="hljs-number">-1</span>,j,atlantic);<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(pacific[i][j] &amp;&amp; atlantic[i][j])<br>                &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; cell;<br>                    cell.<span class="hljs-built_in">push_back</span>(i);<br>                    cell.<span class="hljs-built_in">push_back</span>(j);<br>                    ans.<span class="hljs-built_in">push_back</span>(cell);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法2：宽度优先搜索（BFS）"><a href="#方法2：宽度优先搜索（BFS）" class="headerlink" title="方法2：宽度优先搜索（BFS）"></a>方法2：宽度优先搜索（BFS）</h4><blockquote><p>反向搜索也可以使用广度优先搜索实现。搜索过程中同样需要记录每个单元格是否可以从太平洋反向到达以及是否可以从大西洋反向到达。反向搜索结束之后，遍历每个网格，如果一个网格既可以从太平洋反向到达也可以从大西洋反向到达，则该网格满足太平洋和大西洋都可以到达，将该网格添加到答案中。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> dirs[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;  <span class="hljs-comment">//定义方向数组，分别表示向上下左右四个方向流动</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; heights;  <span class="hljs-comment">//定义一个全局数组</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;ocean)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(ocean[row][col])<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = ocean.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = ocean[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        ocean[row][col] = <span class="hljs-literal">true</span>;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;  <span class="hljs-comment">//定义队列存放单元格的位置坐标</span><br>        q.<span class="hljs-built_in">emplace</span>(row,col);  <span class="hljs-comment">//note：这里只能用q.emplace()不能使用q.push()</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [row,col] = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)<br>            &#123;<br>                <span class="hljs-type">int</span> newRow = row+dirs[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> newCol = col+dirs[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(newRow &gt;= <span class="hljs-number">0</span> &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;=<span class="hljs-number">0</span> &amp;&amp; newCol &lt; n &amp;&amp; heights[newRow][newCol] &gt;= heights[row][col] &amp;&amp; !ocean[newRow][newCol])<br>                &#123;<br>                    ocean[newRow][newCol] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(newRow,newCol);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;heights = heights;<br>        <span class="hljs-type">int</span> m = heights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//防止重复遍历单元格，增加时间复杂度，定义bool类型数组进行标记,默认值为false</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">pacific</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">atlantic</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">//从左边缘开始dfs可以流入太平洋的单元格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>,pacific);<br>        &#125;<br>        <span class="hljs-comment">//从上边缘开始dfs可以流入太平洋的单元格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;n; j++)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,j,pacific);<br>        &#125;<br>        <span class="hljs-comment">//从右边缘开始dfs可以流入大西洋的单元格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(i,n<span class="hljs-number">-1</span>,atlantic);<br>        &#125;<br>        <span class="hljs-comment">//从下边缘开始dfs可以流入大西洋的单元格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n<span class="hljs-number">-1</span>; j++)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(m<span class="hljs-number">-1</span>,j,atlantic);<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(pacific[i][j] &amp;&amp; atlantic[i][j])<br>                &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; cell;<br>                    cell.<span class="hljs-built_in">push_back</span>(i);<br>                    cell.<span class="hljs-built_in">push_back</span>(j);<br>                    ans.<span class="hljs-built_in">push_back</span>(cell);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 824.山羊拉丁文</title>
    <link href="/2022/04/21/LC%20824.%20%E5%B1%B1%E7%BE%8A%E6%8B%89%E4%B8%81%E6%96%87/"/>
    <url>/2022/04/21/LC%20824.%20%E5%B1%B1%E7%BE%8A%E6%8B%89%E4%B8%81%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-824-山羊拉丁文"><a href="#LC-824-山羊拉丁文" class="headerlink" title="LC 824.山羊拉丁文"></a>LC 824.山羊拉丁文</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>这道题在LeetCode为简单题，但是通过不断更新两个下标i,j分割字符串的思路比较有借鉴意义。比直接遍历用split()函数分割字符串要更简单。</p></blockquote><p>string(cnt,’a’)    //字符串的一种构造函数，表示生成一个字符串，包含 cnt 个字符 ‘a’</p><p>sentence.substr(i,j-i)    //注意第一个参数为sentence下标其实位置，第二个参数为单词复制的长度而不是结束位置的下标。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode-cn.com/problems/goat-latin/">https://leetcode-cn.com/problems/goat-latin/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>我们可以对给定的字符串 sentence 进行一次遍历，找出其中的每一个单词，并根据题目的要求进行操作。</p><p>在寻找单词时，我们可以使用语言自带的 split() 函数，将空格作为分割字符，得到所有的单词。为了节省空间，我们也可以直接进行遍历：每当我们遍历到一个空格或者到达 sentence 的末尾时，我们就找到了一个单词。</p><p>当我们得到一个单词 w 后，我们首先需要判断 w 的首字母是否为元音字母。我们可以使用一个哈希集合 vowels 存储所有的元音字母 aeiouAEIOU，这样只需要判断 w 的首字母是否在 vowels 中。如果是元音字母，那么单词本身保持不变；如果是辅音字母，那么需要首字母移到末尾，这里使用语言自带的字符串切片函数即可。在这之后，我们需要在末尾添加 m 以及若干个 a，因此可以使用一个变量 cnt 记录需要添加的 a 的个数，它的初始值为 1，每当我们得到一个单词，就将它的值增加 1。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">toGoatLatin</span><span class="hljs-params">(string sentence)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; vowels = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>&#125;;<br>        <span class="hljs-type">int</span> n = sentence.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">1</span>;<br>        string ans;<br>        <span class="hljs-keyword">while</span>(i &lt; n)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; sentence[j] != <span class="hljs-string">&#x27; &#x27;</span>)  j++;<br>            cnt++;<br>            <span class="hljs-keyword">if</span>(cnt != <span class="hljs-number">2</span>)  ans = ans+<span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-keyword">if</span>(vowels.<span class="hljs-built_in">count</span>(sentence[i]))<br>            &#123;<br>                ans = ans+sentence.<span class="hljs-built_in">substr</span>(i,j-i)+<span class="hljs-string">&#x27;m&#x27;</span>+<span class="hljs-built_in">string</span>(cnt,<span class="hljs-string">&#x27;a&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans = ans+sentence.<span class="hljs-built_in">substr</span>(i+<span class="hljs-number">1</span>,j-i<span class="hljs-number">-1</span>)+sentence[i]+<span class="hljs-string">&#x27;m&#x27;</span>+<span class="hljs-built_in">string</span>(cnt,<span class="hljs-string">&#x27;a&#x27;</span>);<br>            &#125;<br>            i = j+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python图形化界面设计</title>
    <link href="/2022/04/20/Python%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/04/20/Python%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Github+PicGo搭建的图床没有梯子不好用，Github经常加载不出来。最近要复习考试，考完试有空把用Github搭建的图床换成Gitee+PicGo，再重新上传之前的笔记测试一下吧。</p><p>额……  还有博客的域名没整，没绑定域名又拍云CDN加速也整不了。算算了，等考完试在腾讯云重新买一个.cn的域名再折腾吧。</p></blockquote><h2 id="Python图形化界面设计"><a href="#Python图形化界面设计" class="headerlink" title="Python图形化界面设计"></a>Python图形化界面设计</h2><blockquote><p>学习链接：<a href="https://www.jianshu.com/p/91844c5bca78">https://www.jianshu.com/p/91844c5bca78</a></p></blockquote><blockquote><p>Python自带了tkinter 模块，实质上是一种流行的面向对象的GUI工具包 TK 的Python编程接口，提供了快速便利地创建GUI应用程序的方法。其图像化编程的基本步骤通常包括：</p><p>一、导入 tkinter 模块</p><p>二、创建 GUI 根窗体</p><p>三、添加人机交互控件并编写相应的函数</p><p>四、在主事件循环中等待用户触发事件响应</p></blockquote><h3 id="Python图形化界面设计-1"><a href="#Python图形化界面设计-1" class="headerlink" title="Python图形化界面设计"></a>Python图形化界面设计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">import</span> tkinter<br>root=Tk()<br>root.title(<span class="hljs-string">&quot;我的第一个Python窗口&quot;</span>)   <span class="hljs-comment"># title() 方法可设置其标题文字</span><br>root.geometry(<span class="hljs-string">&#x27;550x400&#x27;</span>)  <span class="hljs-comment">#geometry()方法可以设置窗体的大小（以像素为单位）  x为小写英文字母x</span><br><br><span class="hljs-comment">#标签</span><br>lb=Label(root,text=<span class="hljs-string">&quot;我的第一个标签&quot;</span>,<br>bg=<span class="hljs-string">&quot;#d3fbfb&quot;</span>,      <span class="hljs-comment">#背景颜色</span><br>fg=<span class="hljs-string">&quot;red&quot;</span>,          <span class="hljs-comment">#字体颜色</span><br>font=<span class="hljs-string">&quot;&#x27;楷体&#x27;，32&quot;</span>,  <span class="hljs-comment">#标签字体</span><br>width=<span class="hljs-number">32</span>,<br>height=<span class="hljs-number">2</span>,<br>relief=RAISED    <span class="hljs-comment">#浮雕样式</span><br><span class="hljs-comment">#属性 relief 为控件呈现出来的3D浮雕样式，有 FLAT(平的)、RAISED(凸起的)、SUNKEN(凹陷的)、GROOVE(沟槽状边缘)和 RIDGE(脊状边缘) 5种。</span><br>)<br>lb.pack()<br><span class="hljs-comment">#控件布局 常见的控件布局有三种：pack() grid() place() 具体详见笔记</span><br></code></pre></td></tr></table></figure><h3 id="Python简单加法计算器"><a href="#Python简单加法计算器" class="headerlink" title="Python简单加法计算器"></a>Python简单加法计算器</h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426111614315.png?raw=true" alt="image-20220426111614315.png"></p><p>Python简单加法计算器代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#将两个输入框输入文本转化为浮点数值进行加法运算 要求每次单击按钮计算结果是以文本的形式追加到文本框中 将原输入框清空</span><br><span class="hljs-comment">#按钮方法一：不传参数调用函数run1()实现 按钮方法二：用lambda()调用函数run2(x,y)同时传递参数实现</span><br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run1</span>():<br>    a = <span class="hljs-built_in">float</span>(inp1.get())<br>    b = <span class="hljs-built_in">float</span>(inp2.get())<br>    s = <span class="hljs-string">&#x27;%0.2f+%0.2f=%0.2f\n&#x27;</span>%(a,b,a+b)<br>    txt.insert(END,s)  <span class="hljs-comment">#追加显示运算结果</span><br>    inp1.delete(<span class="hljs-number">0</span>,END)  <span class="hljs-comment">#清空输入</span><br>    inp2.delete(<span class="hljs-number">0</span>,END)  <span class="hljs-comment">#清空输入</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run2</span>(<span class="hljs-params">x,y</span>):<br>    a = <span class="hljs-built_in">float</span>(x)<br>    b = <span class="hljs-built_in">float</span>(y)<br>    s = <span class="hljs-string">&#x27;%0.2f+%0.2f=%0.2f\n&#x27;</span>%(a,b,a+b)<br>    txt.insert(END,s)<br>    inp1.delete(<span class="hljs-number">0</span>,END)<br>    inp2.delete(<span class="hljs-number">0</span>,END)<br><br>root = Tk()<br>root.geometry(<span class="hljs-string">&#x27;460x240&#x27;</span>)<br>root.title(<span class="hljs-string">&#x27;简单加法计算器&#x27;</span>)<br><br>lb1 = Label(root,text=<span class="hljs-string">&#x27;请输入两个数，按下面两个按钮之一进行加法计算&#x27;</span>)<br>lb1.place(relx=<span class="hljs-number">0.1</span>,rely=<span class="hljs-number">0.1</span>,relwidth=<span class="hljs-number">0.8</span>,relheight=<span class="hljs-number">0.1</span>)<br>inp1=Entry(root)<br>inp1.place(relx=<span class="hljs-number">0.1</span>,rely=<span class="hljs-number">0.2</span>,relwidth=<span class="hljs-number">0.3</span>,relheight=<span class="hljs-number">0.1</span>)<br>inp2=Entry(root)<br>inp2.place(relx=<span class="hljs-number">0.6</span>,rely=<span class="hljs-number">0.2</span>,relwidth=<span class="hljs-number">0.3</span>,relheight=<span class="hljs-number">0.1</span>)<br><br><span class="hljs-comment">#方法一：直接调用run1()</span><br>btn1 = Button(root,text=<span class="hljs-string">&#x27;方法一&#x27;</span>,command=run1)<br>btn1.place(relx=<span class="hljs-number">0.1</span>,rely=<span class="hljs-number">0.4</span>,relwidth=<span class="hljs-number">0.3</span>,relheight=<span class="hljs-number">0.1</span>)<br><span class="hljs-comment">#方法二：利用lambda函数传参数调用run2()</span><br>btn2 = Button(root,text=<span class="hljs-string">&#x27;方法二&#x27;</span>,command=<span class="hljs-keyword">lambda</span>:run2(inp1.get(),inp2.get()))<br>btn2.place(relx=<span class="hljs-number">0.6</span>,rely=<span class="hljs-number">0.4</span>,relwidth=<span class="hljs-number">0.3</span>,relheight=<span class="hljs-number">0.1</span>)<br><span class="hljs-comment">#在窗体垂直自上而下位置60%处起 布局相对窗体高度40%高的文本框</span><br>txt = Text(root)<br>txt.place(rely=<span class="hljs-number">0.6</span>,relheight=<span class="hljs-number">0.4</span>)<br>root.mainloop()<br><br><span class="hljs-comment">#place()方法：根据控件实例在父容器中的绝对或相对位置参数进行布局 常用参数布局：</span><br><span class="hljs-comment">#lb.place(x=,y=) x y:控件实例在根窗体中水平和垂直方向上的其实位置（单位为像素）根窗体左上角为x=0,y=0 水平向右 垂直向下为正方向</span><br><span class="hljs-comment">#lb.place(height=,width=) height width:控件实例本身的高度和宽度（单位为像素）</span><br><span class="hljs-comment">#lb.place(relx=,rely=) relx rely:控件实例在根窗体中水平和垂直方向上起始布局的相对位置 即相对于根窗体宽和高的比例位置 取值在0.0~1.0之间</span><br><span class="hljs-comment">#lb.place(relheight=,relwidth=) relheight relwidth:控件实例相对于根窗体的高度和宽度比例 取值在0.0~1.0之间</span><br><span class="hljs-comment">#利用place的方法配合relx rely和relwidth relheight参数所得到的界面可自适应根窗体尺寸的大小</span><br></code></pre></td></tr></table></figure><h3 id="python图形化界面设计时钟"><a href="#python图形化界面设计时钟" class="headerlink" title="python图形化界面设计时钟"></a><strong>python图形化界面设计时钟</strong></h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426111840666.png?raw=true" alt="image-20220426111840666.png"></p><p>python图形化界面设计时钟代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#tkinter常见控件的特征属性</span><br><span class="hljs-comment">#文本输入和输出相关控件：标签（Label）消息（Message）输入框（Entry）文本框（Text）Label和Message除了单行和多行不同外 属性和用法基本一直 用于呈现文本信息</span><br><span class="hljs-comment">#利用configure()方法或config来实现文本变化</span><br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">import</span> tkinter<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gettime</span>():<br>    timestr = time.strftime(<span class="hljs-string">&quot;%H:%M:%S&quot;</span>)  <span class="hljs-comment">#获取当前的时间并转化为字符串</span><br>    lb.configure(text=timestr)  <span class="hljs-comment">#重新设置标签文本</span><br>    root.after(<span class="hljs-number">1000</span>,gettime)  <span class="hljs-comment">#每隔1s调用函数 gettime自身获取时间</span><br>root = tkinter.Tk()<br>root.title(<span class="hljs-string">&quot;时钟&quot;</span>)<br>lb = tkinter.Label(root,text=<span class="hljs-string">&#x27;&#x27;</span>,fg=<span class="hljs-string">&#x27;blue&#x27;</span>,font=(<span class="hljs-string">&quot;黑体&quot;</span>,<span class="hljs-number">80</span>))<br>lb.pack()<br>gettime()<br>lb.mainloop()<br></code></pre></td></tr></table></figure><h3 id="python图形化界面设计（复选框）"><a href="#python图形化界面设计（复选框）" class="headerlink" title="python图形化界面设计（复选框）"></a><strong>python图形化界面设计（复选框）</strong></h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426112015548.png?raw=true" alt="image-20220426112015548.png"></p><p>python图形化界面设计（复选框）代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span>*<br><span class="hljs-comment">#复选框</span><br><span class="hljs-keyword">import</span> tkinter<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>():<br>    <span class="hljs-keyword">if</span>(ChackVar1.get()==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ChackVar2.get()==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ChackVar3.get()==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ChackVar4.get()==<span class="hljs-number">0</span>):<br>        s = <span class="hljs-string">&#x27;您还没选择任何爱好项目&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        s1 = <span class="hljs-string">&quot;足球&quot;</span> <span class="hljs-keyword">if</span> ChackVar1.get()==<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span><br>        s2 = <span class="hljs-string">&quot;篮球&quot;</span> <span class="hljs-keyword">if</span> ChackVar2.get()==<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span><br>        s3 = <span class="hljs-string">&quot;游泳&quot;</span> <span class="hljs-keyword">if</span> ChackVar3.get()==<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span><br>        s4 = <span class="hljs-string">&quot;田径&quot;</span> <span class="hljs-keyword">if</span> ChackVar4.get()==<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span><br>        s = <span class="hljs-string">&quot;您选择了%s%s%s%s&quot;</span>%(s1,s2,s3,s4)<br>    lb2.config(text=s)<br><br>root = Tk()<br>root.title(<span class="hljs-string">&#x27;复选框&#x27;</span>)<br>lb1 = Label(root,text=<span class="hljs-string">&#x27;请选择您的爱好项目&#x27;</span>)<br>lb1.pack()<br><br>ChackVar1 = IntVar()<br>ChackVar2 = IntVar()<br>ChackVar3 = IntVar()<br>ChackVar4 = IntVar()<br><br>ch1 = Checkbutton(root,text=<span class="hljs-string">&#x27;足球&#x27;</span>,variable = ChackVar1,onvalue=<span class="hljs-number">1</span>,offvalue=<span class="hljs-number">0</span>)<br>ch2 = Checkbutton(root,text=<span class="hljs-string">&#x27;篮球&#x27;</span>,variable = ChackVar2,onvalue=<span class="hljs-number">1</span>,offvalue=<span class="hljs-number">0</span>)<br>ch3 = Checkbutton(root,text=<span class="hljs-string">&#x27;游泳&#x27;</span>,variable = ChackVar3,onvalue=<span class="hljs-number">1</span>,offvalue=<span class="hljs-number">0</span>)<br>ch4 = Checkbutton(root,text=<span class="hljs-string">&#x27;田径&#x27;</span>,variable = ChackVar4,onvalue=<span class="hljs-number">1</span>,offvalue=<span class="hljs-number">0</span>)<br>ch1.pack()<br>ch2.pack()<br>ch3.pack()<br>ch4.pack()<br><br>btn = Button(root,text=<span class="hljs-string">&#x27;OK&#x27;</span>,command=run)  <span class="hljs-comment">#按钮的command参数和函数相连接</span><br>btn.pack()<br>lb2 = Label(root,text=<span class="hljs-string">&#x27;&#x27;</span>)<br>lb2.pack()<br><br>root.mainloop()<br><span class="hljs-comment">#复选框：复选框（Checkbutton）是为了返回多个选项值的交互控件 通常不直接触发函数的执行 该控件除了具有共有属性外</span><br><span class="hljs-comment">#还具有显示文本（text）返回变量（variable）选中返回值（onvalue）和未选中默认返回值（offvalue）等重要属性</span><br><span class="hljs-comment">#返回变量variable = var通常可以预先逐项分别声明变量的类型var = IntVar()（默认）或var = StringVar()</span><br><span class="hljs-comment">#在所调用的函数中方可分别调用var.get()方法取得被选中实例的onvalue或offvalue值 复选框实例通常还可分别利用</span><br><span class="hljs-comment">#seclet() deselect()和toggle()方法对其进行选中、清除选中和反选操作</span><br></code></pre></td></tr></table></figure><h3 id="python图形化界面设计（列表框）"><a href="#python图形化界面设计（列表框）" class="headerlink" title="python图形化界面设计（列表框）"></a><strong>python图形化界面设计（列表框）</strong></h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426112137578.png?raw=true" alt="image-20220426112137578.png"></p><p>python图形化界面设计（列表框）代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#列表框：列表框（Listbox）可供用户单选或多选所列条目以形成人机交互 列表框的主要控件方法如下:</span><br><span class="hljs-comment">#curselection()：返回光标选中项目的元组 注意并不是单个的整数</span><br><span class="hljs-comment">#delete(起始位置,终止位置)：删除项目 终止位置可省略 全部清空为delete(0,END)</span><br><span class="hljs-comment">#get(起始位置,终止位置)：返回范围所含项目文本的元组 终止位置可忽略</span><br><span class="hljs-comment">#insert(位置,项目元素)：插入项目元素（若有多项,可用列表或元组类型赋值）若位置为END 则将项目元素添加到最后</span><br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ini</span>():<br>    Lstbox1.delete(<span class="hljs-number">0</span>,END)<br>    list_items = [<span class="hljs-string">&quot;数学&quot;</span>,<span class="hljs-string">&quot;物理&quot;</span>,<span class="hljs-string">&quot;化学&quot;</span>,<span class="hljs-string">&quot;语文&quot;</span>,<span class="hljs-string">&quot;外语&quot;</span>]<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> list_items:<br>        Lstbox1.insert(END,item)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">clear</span>():<br>    Lstbox1.delete(<span class="hljs-number">0</span>,END)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ins</span>():<br>    <span class="hljs-keyword">if</span> entry.get() != <span class="hljs-string">&#x27;&#x27;</span>:<br>        <span class="hljs-keyword">if</span> Lstbox1.curselection() == ():<br>            Lstbox1.insert(Lstbox1.size(),entry.get())<br>        <span class="hljs-keyword">else</span>:<br>            Lstbox1.insert(Lstbox1.curselection(),entry.get())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">updt</span>():<br>    <span class="hljs-keyword">if</span> entry.get() != <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> Lstbox1.curselection() != ():<br>        selected=Lstbox1.curselection()[<span class="hljs-number">0</span>]<br>        Lstbox1.delete(selected)<br>        Lstbox1.insert(selected,entry.get())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delt</span>():<br>    <span class="hljs-keyword">if</span> Lstbox1.curselection() != ():<br>        Lstbox1.delete(Lstbox1.curselection())<br><br>root = Tk()<br>root.title(<span class="hljs-string">&#x27;列表框实验&#x27;</span>)<br>root.geometry(<span class="hljs-string">&#x27;320x240&#x27;</span>)<br><br>frame1 = Frame(root,relief=RAISED)<br>frame1.place(relx=<span class="hljs-number">0.0</span>)<br>frame2 = Frame(root,relief=GROOVE)<br>frame2.place(relx=<span class="hljs-number">0.5</span>)<br><br>Lstbox1 = Listbox(frame1)<br>Lstbox1.pack()<br><br>entry = Entry(frame2)<br>entry.pack()<br><br>btn1 = Button(frame2,text=<span class="hljs-string">&#x27;初始化&#x27;</span>,command=ini)<br>btn1.pack(fill=X)<br>btn2 = Button(frame2,text=<span class="hljs-string">&#x27;添加&#x27;</span>,command=ins)<br>btn2.pack(fill=X)<br>btn3 = Button(frame2,text=<span class="hljs-string">&#x27;插入&#x27;</span>,command=ins) <br>btn3.pack(fill=X)<br>btn4 = Button(frame2,text=<span class="hljs-string">&#x27;修改&#x27;</span>,command=updt)<br>btn4.pack(fill=X)<br>btn5 = Button(frame2,text=<span class="hljs-string">&#x27;删除&#x27;</span>,command=delt)<br>btn5.pack(fill=X)<br>btn6 = Button(frame2,text=<span class="hljs-string">&#x27;清空&#x27;</span>,command=clear)<br>btn6.pack(fill=X)<br>root.mainloop()<br></code></pre></td></tr></table></figure><h3 id="python图形化界面设计（组合框）"><a href="#python图形化界面设计（组合框）" class="headerlink" title="python图形化界面设计（组合框）"></a><strong>python图形化界面设计（组合框）</strong></h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426112247491.png?raw=true" alt="image-20220426112247491.png"></p><p>python图形化界面设计（组合框）代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tkinter.ttk <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">import</span> tkinter<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc</span>(<span class="hljs-params">event</span>):<br>       a = <span class="hljs-built_in">float</span>(t1.get())<br>       b = <span class="hljs-built_in">float</span>(t2.get())<br>       dic = &#123;<span class="hljs-number">0</span>:a+b,<span class="hljs-number">1</span>:a-b,<span class="hljs-number">2</span>:a*b,<span class="hljs-number">3</span>:a/b&#125;<br>       c = dic[comb.current()]<br>       lbl.config(text=<span class="hljs-built_in">str</span>(c))<br><br>root = Tk()<br>root.title(<span class="hljs-string">&#x27;四则运算&#x27;</span>)<br>root.geometry(<span class="hljs-string">&#x27;320x240&#x27;</span>)<br><br>t1 = Entry(root)<br>t1.place(relx=<span class="hljs-number">0.1</span>,rely=<span class="hljs-number">0.1</span>,relwidth=<span class="hljs-number">0.2</span>,relheight=<span class="hljs-number">0.1</span>)<br>t2 = Entry(root)<br>t2.place(relx=<span class="hljs-number">0.5</span>,rely=<span class="hljs-number">0.1</span>,relwidth=<span class="hljs-number">0.2</span>,relheight=<span class="hljs-number">0.1</span>)<br><br>var = StringVar()<br><br>comb = Combobox(root,textvariable=var,values=[<span class="hljs-string">&#x27;加&#x27;</span>,<span class="hljs-string">&#x27;减&#x27;</span>,<span class="hljs-string">&#x27;乘&#x27;</span>,<span class="hljs-string">&#x27;除&#x27;</span>,])<br>comb.place(relx=<span class="hljs-number">0.1</span>,rely=<span class="hljs-number">0.5</span>,relwidth=<span class="hljs-number">0.2</span>)<br>comb.bind(<span class="hljs-string">&#x27;&lt;&lt;ComboboxSelected&gt;&gt;&#x27;</span>,calc)<br><br>lbl=Label(root,text=<span class="hljs-string">&#x27;结果&#x27;</span>)<br>lbl.place(relx=<span class="hljs-number">0.5</span>,rely=<span class="hljs-number">0.7</span>,relwidth=<span class="hljs-number">0.2</span>,relheight=<span class="hljs-number">0.3</span>)<br>root.mainloop()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python从excel表中读取数据并绘图</title>
    <link href="/2022/04/20/Python%E4%BB%8Eexcel%E8%A1%A8%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%BB%98%E5%9B%BE/"/>
    <url>/2022/04/20/Python%E4%BB%8Eexcel%E8%A1%A8%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%BB%98%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="Python从excel表中读取数据并绘图"><a href="#Python从excel表中读取数据并绘图" class="headerlink" title="Python从excel表中读取数据并绘图"></a>Python从excel表中读取数据并绘图</h2><blockquote><p>图文教程链接：<a href="https://mp.weixin.qq.com/s/DchGtK_wOavZ9eSPeV8ZUQ">https://mp.weixin.qq.com/s/DchGtK_wOavZ9eSPeV8ZUQ</a></p></blockquote><h3 id="一、柱状图"><a href="#一、柱状图" class="headerlink" title="一、柱状图"></a>一、柱状图</h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426105632700.png?raw=true" alt="Excel表中的数据"></p><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426105719236.png?raw=true" alt="image-20220426105719236.png"></p><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment">#中文处理模块</span><br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> rcParams  <span class="hljs-comment">#中文处理模块 解决标签文字乱码情况</span><br>rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = <span class="hljs-string">&#x27;simhei&#x27;</span>  <span class="hljs-comment">#中文处理模块 解决标签文字乱码情况</span><br>Vae = pd.read_excel(<span class="hljs-string">&#x27;Vae专辑.xlsx&#x27;</span>)<br><span class="hljs-comment">#Vae.sort_values(by=&#x27;歌曲数目&#x27;,inplace=True,ascending=False)</span><br><span class="hljs-comment">#降序排列</span><br><span class="hljs-comment">#Vae.sort_values(by=&#x27;歌曲数目&#x27;,inplace=True,ascending=True)</span><br><span class="hljs-comment">#升序排列</span><br><span class="hljs-comment">#print(Vae)</span><br>Vae.plot.bar(x=<span class="hljs-string">&#x27;专辑&#x27;</span>,y=<span class="hljs-string">&#x27;歌曲数目&#x27;</span>,color=<span class="hljs-string">&#x27;blue&#x27;</span>)<br><span class="hljs-comment">#color=&#x27;blue&#x27;  统一设置柱状图颜色</span><br>plt.xticks(rotation=<span class="hljs-number">360</span>)  <span class="hljs-comment">#调整标签方向使其横向写</span><br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬虫</title>
    <link href="/2022/04/20/Python%E7%88%AC%E8%99%AB/"/>
    <url>/2022/04/20/Python%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Python爬虫学习"><a href="#Python爬虫学习" class="headerlink" title="Python爬虫学习"></a>Python爬虫学习</h2><p><strong>学习爬虫前需要安装的标准库</strong></p><p>安装如下：</p><p>pip install requests</p><p>pip install re</p><p>pip install bs4</p><p><strong>爬虫的四个主要步骤：</strong></p><p>1.明确目标</p><p>2.爬(将网站的所有内容给爬下来)</p><p>3.取(将自己想要的数据取下来)</p><p>4.保存数据</p><p><strong>接下来的所有代码操作都是在执行爬虫的四个主要步骤</strong></p><p>import requests    #爬取html的标准库函数</p><p>ret=requests.get(‘<a href="http://www.qiushibaike.com/&#39;">http://www.qiushibaike.com/&#39;</a>)    #ret返回的是网页请求成功的状态码</p><p>result=ret.content.decode()    #通过这段代码能够把网页的中文源代码返回给我们</p><p>print(result)    #result是一个字符串</p><p>通过请求一个url，来得到前端的数据，然后从前端的数据里面获取我们想要的内容</p><p>import re    #python的一个模块 用来将自己想要的数据取下来</p><p>re模块是针对字符串这种数据格式来提取的一种方法</p><p>具体代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests  <span class="hljs-comment">#爬取html的标准库函数</span><br>headers=&#123;<br>    <span class="hljs-string">&quot;User-Urgent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&quot;</span><br>&#125;  <span class="hljs-comment">#防反爬 模拟人去访问网站 </span><br>ret=requests.get(<span class="hljs-string">&#x27;https://www.xbiquge.la/paihangbang/&#x27;</span>)   <span class="hljs-comment">#ret返回的是网页请求成功的状态码</span><br>result=ret.content.decode()   <span class="hljs-comment">#通过这段代码能够把网页的中文源代码返回给我们</span><br><span class="hljs-comment">#result是一个字符串</span><br>novel = <span class="hljs-string">&#x27;&lt;li&gt;\d&lt;a href=&quot;.+&quot;&gt;(.*?)&lt;\/a&gt;&lt;\/li&gt;&#x27;</span><br>content=re.findall(novel,result)<br><span class="hljs-comment">#re.S代表可以匹配到换行符</span><br><span class="hljs-comment">#print(content)</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;笔趣阁爬虫数据.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> content:<br>         s = i+<span class="hljs-string">&#x27;\n&#x27;</span><br>         f.write(s)<br></code></pre></td></tr></table></figure><h3 id="一个完整的爬虫实例（re模块解析）"><a href="#一个完整的爬虫实例（re模块解析）" class="headerlink" title="一个完整的爬虫实例（re模块解析）"></a><strong>一个完整的爬虫实例（re模块解析）</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br>headers=&#123;<br>    <span class="hljs-string">&quot;User-Urgent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&quot;</span><br>&#125;<br>ret=requests.get(<span class="hljs-string">&#x27;https://www.xbiquge.la/paihangbang/&#x27;</span>) <br>result=ret.content.decode() <br><span class="hljs-comment">#print(type(result))   </span><br>novel = <span class="hljs-string">&#x27;&lt;li&gt;\d&lt;a href=&quot;.+&quot;&gt;(.*?)&lt;\/a&gt;&lt;\/li&gt;&#x27;</span><br>content=re.findall(novel,result)<br><span class="hljs-comment">#print(content)</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;笔趣阁爬虫数据.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> content:<br>         s = i+<span class="hljs-string">&#x27;\n&#x27;</span><br>         f.write(s)<br></code></pre></td></tr></table></figure><h3 id="一个完整的爬虫实例（BeautifulSoup模块解析）"><a href="#一个完整的爬虫实例（BeautifulSoup模块解析）" class="headerlink" title="一个完整的爬虫实例（BeautifulSoup模块解析）"></a><strong>一个完整的爬虫实例（BeautifulSoup模块解析）</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests  <br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>headers=&#123;<br>    <span class="hljs-string">&quot;User-Urgent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&quot;</span><br>&#125;<br>ret=requests.get(<span class="hljs-string">&#x27;https://www.xbiquge.la/paihangbang/&#x27;</span>) <br>result=ret.content.decode() <br><span class="hljs-comment">#print(type(result)) </span><br>soup = BeautifulSoup(result,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-comment">#print(type(soup))</span><br>content = soup.find_all(<span class="hljs-string">&#x27;li&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> content:<br>    <span class="hljs-built_in">print</span>(i.text)<br></code></pre></td></tr></table></figure><h3 id="写给小吕的详细解释版"><a href="#写给小吕的详细解释版" class="headerlink" title="写给小吕的详细解释版"></a><strong>写给小吕的详细解释版</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re  <span class="hljs-comment">#re为python的一个模块 用于解析网页源代码</span><br><span class="hljs-comment">#同样可以实现该功能的还有bs4 lxml等</span><br><span class="hljs-keyword">import</span> requests  <span class="hljs-comment">#爬取html的标准库函数</span><br><br>headers=&#123;<br>    <span class="hljs-string">&quot;User-Urgent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&quot;</span><br>&#125;  <span class="hljs-comment">#防反爬 模拟人去访问网站 </span><br><br>ret=requests.get(<span class="hljs-string">&#x27;https://www.xbiquge.la/paihangbang/&#x27;</span>)   <span class="hljs-comment">#ret返回的是网页请求成功的状态码</span><br><span class="hljs-comment">#requests.get()可以得到该网站的代码</span><br><br>result=ret.content.decode()   <span class="hljs-comment">#对代码进行解析 通过解析能够把网页的中文源代码返回给我们</span><br><span class="hljs-comment">#得到中文源代码之后只需要提取我们所需要的的数据即可</span><br><span class="hljs-comment">#result是一个字符串</span><br><br>novel = <span class="hljs-string">&#x27;&lt;li&gt;\d&lt;a href=&quot;.+&quot;&gt;(.*?)&lt;\/a&gt;&lt;\/li&gt;&#x27;</span><br><span class="hljs-comment">#使用正则表达式去匹配代码中的关键字 小括号()前后代表所要去匹配代码的标签</span><br><span class="hljs-comment">#(.*?)代表所要提取的内容</span><br><span class="hljs-comment">#这个地方你在展示的时候如果说不明白的话 你可以这么说：</span><br><span class="hljs-comment">#正则表达式是爬虫的关键 用来提取所爬代码中我们所需要的数据 如果大家想要更深入的了解的话 可以建议大家去b站看一下这个视频</span><br><span class="hljs-comment">#b站视频链接(https://www.bilibili.com/video/BV1da4y1p7iZ)</span><br><span class="hljs-comment">#这个视频详细的介绍了正则表达式的使用 以及还推荐了一个很实用的在线的正则表达式检验的网站 同学们可以去学习一下</span><br><span class="hljs-comment">#正则表达式检验网站(https://regex101.com/)</span><br><br>content=re.findall(novel,result)  <span class="hljs-comment">#调用re模块 re.finaall是用来查找result中与novel所匹配的内容 以列表的形式返回所匹配到的字符串</span><br><span class="hljs-comment">#将所匹配到的字符串存储在content列表中</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;笔趣阁爬虫数据.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment">#以写入的方式将所提取的数据存入txt文件中 &#x27;w&#x27;代表写入 encoding=&#x27;utf-8&#x27;代表声明文件的编码方式</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> content:  <span class="hljs-comment">#循环遍历列表</span><br>         s = i+<span class="hljs-string">&#x27;\n&#x27;</span>    <span class="hljs-comment">#&#x27;\n&#x27;代表换行符 每写入一个列表元素之后进行换行</span><br>         f.write(s)    <span class="hljs-comment">#将列表元素写入文件中</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记</title>
    <link href="/2022/04/20/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/20/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>上传之前的Python学习笔记，顺便测试一下GitHub+PicGo搭建的图床</p></blockquote><h2 id="Python基础语法"><a href="#Python基础语法" class="headerlink" title="Python基础语法"></a>Python基础语法</h2><h3 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a><strong>数字类型转换</strong></h3><p>eval()和float()函数都可以把input() 函数接收到的数值型字符串转为数值类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())   <span class="hljs-comment">#输入整数字符串，转换为整数；输入浮点数字符串，转换为浮点数</span><br>b = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>())  <span class="hljs-comment">#输入整数和浮点数，都转换为浮点数</span><br>c = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())    <span class="hljs-comment">#只接受整数输入，输出为整数</span><br></code></pre></td></tr></table></figure><p>例：float(‘3.14’) 的结果是数值 3.14</p><p>int()函数可以把整数字符串转为整数</p><p>例：int(‘5’) 的结果是数值 5</p><h3 id="格式化浮点数的两种方法"><a href="#格式化浮点数的两种方法" class="headerlink" title="格式化浮点数的两种方法"></a><strong>格式化浮点数的两种方法</strong></h3><p>方法一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Interest is&quot;</span>,<span class="hljs-built_in">round</span>(interest,<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:10.nf&#125;&quot;</span>,<span class="hljs-built_in">format</span>(interest))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:.nf&#125;&quot;</span>,<span class="hljs-built_in">format</span>(interest))<br></code></pre></td></tr></table></figure><p><strong>Note：</strong>{}中的三个数分别表示从第一个字符开始、格式化浮点数后的字符长度、保留到小数点后的第n位</p><p><strong>// 是Python中数学运算符： 整除(向小取整)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">5</span> / <span class="hljs-number">2</span>     <span class="hljs-comment">#  2.5</span><br><span class="hljs-number">5</span> // <span class="hljs-number">2</span>    <span class="hljs-comment">#  2</span><br>-<span class="hljs-number">5</span> / <span class="hljs-number">2</span>    <span class="hljs-comment"># -2.5</span><br>-<span class="hljs-number">5</span> // <span class="hljs-number">2</span>  <span class="hljs-comment"># -3</span><br></code></pre></td></tr></table></figure><h3 id="Python-实现一行输入多个数字-用空格隔开"><a href="#Python-实现一行输入多个数字-用空格隔开" class="headerlink" title="Python 实现一行输入多个数字(用空格隔开)"></a><strong>Python</strong> <strong>实现一行输入多个数字(用空格隔开)</strong></h3><p>很多人都会使用以下代码，来实现多个字符串的连续输入，但是这是以换行进行操作的，而有些题目需要将一些数字进行一行输入</p><p>a=input()</p><p>b=input()</p><p><strong>1.实现一行输入多个数字，并以空格隔开。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a,b=<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br><span class="hljs-built_in">print</span>(a,b)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))<br></code></pre></td></tr></table></figure><p>#运行结果</p><p>1 2</p><p>1 2</p><p>&lt;class ‘int’&gt;</p><p><strong>2.实现一个输入多个单词，每个单词之间用逗号隔开。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">str1,str2=<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,<span class="hljs-built_in">input</span>().split(<span class="hljs-string">&#x27;,&#x27;</span>))<br><span class="hljs-built_in">print</span>(str1,str2)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(str1))<br></code></pre></td></tr></table></figure><p>#运行结果</p><p>love,china</p><p>love china</p><p>&lt;class ‘str’&gt;</p><p>例题：将二进制日期翻译为十进制的形式并输出。例如，日期 00010 00000 00010 00000 00001 00011，翻译为2020年1月3日。int(x,2)：将一个二进制的数字准换为十进制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入报道日期，每位二进制数之间用空格隔开&quot;</span>)<br>sstr=<span class="hljs-string">&quot;&quot;</span><br>year1,year2,year3,year4,month,day=<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,<span class="hljs-built_in">input</span>().split())<br>sstr=sstr+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(year1,<span class="hljs-number">2</span>))+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(year2,<span class="hljs-number">2</span>))+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(year3,<span class="hljs-number">2</span>))+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(year4,<span class="hljs-number">2</span>))+<span class="hljs-string">&quot;年&quot;</span><br>sstr=sstr+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(month,<span class="hljs-number">2</span>))+<span class="hljs-string">&quot;月&quot;</span><br>sstr=sstr+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(day,<span class="hljs-number">2</span>))+<span class="hljs-string">&quot;日&quot;</span><br><span class="hljs-built_in">print</span>(sstr)<br></code></pre></td></tr></table></figure><p>#运行结果</p><p>请输入报道日期，每位二进制数之间用空格隔开</p><p>00010 00000 00001 00100 00100 00001</p><p>2014年4月1日</p><h3 id="格式化数字和字符串解题报告"><a href="#格式化数字和字符串解题报告" class="headerlink" title="格式化数字和字符串解题报告"></a><strong>格式化数字和字符串解题报告</strong></h3><h4 id="格式化数字："><a href="#格式化数字：" class="headerlink" title="格式化数字："></a><strong>格式化数字：</strong></h4><p>format格式化数字:</p><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220420194240729.png?raw=true" alt="format格式化数字"></p><p>格式化浮点数的两种方法：</p><p>方法一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Interest is&quot;</span>,<span class="hljs-built_in">round</span>(interest,<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:10.nf&#125;&quot;</span>,<span class="hljs-built_in">format</span>(interest))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:.nf&#125;&quot;</span>,<span class="hljs-built_in">format</span>(interest))<br></code></pre></td></tr></table></figure><p>PS:{}中的三个数分别表示从第一个字符开始、格式化浮点数后的字符长度、保留到小数点后的第n位</p><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a><strong>格式化字符串</strong></h4><p><strong>1.format格式化字符串</strong></p><p>format（）方法接受位置参数和关键字参数，两者均传递一个叫做replacement字段，而这个replacement字段在字符串内由大括号表示。</p><p>位置参数：</p><p>字符串中的{0}{1}{2}表示位置，依次被format中的三个参数代换，format中的三个参数就叫做位置参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;&#123;0&#125; prety &#123;1&#125; &#123;2&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-string">&quot;python&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure><p>I prety love python         </p><p>关键字参数：format将参数中等值的字符串替换进去，这就是关键字参数</p><p>字符串中的{a}{b}{c}相当于三个标签，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;&#123;a&#125; prety &#123;b&#125; &#123;c&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a=<span class="hljs-string">&quot;I&quot;</span>,b=<span class="hljs-string">&quot;love&quot;</span>,c=<span class="hljs-string">&quot;python&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure><p>I prety love python</p><p>位置参数和关键字参数同时用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;&#123;a&#125; prety &#123;b&#125; &#123;c&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a=<span class="hljs-string">&quot;I&quot;</span>,b=<span class="hljs-string">&quot;love&quot;</span>,c=<span class="hljs-string">&quot;python&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure><p>I prety love python</p><p><strong>2.格式化操作符：%</strong></p><p>%c:格式化字符及其ASCLL值</p><p>%s:格式化字符串</p><p>%d：格式化整数</p><p>%o:格式化无符号八进制数</p><p>%x:格式化无符号十六进制数</p><p>%X格式化无符号十六进制数（大写）</p><p>%f:格式化浮点数字，可指定小数点后的精度</p><p>%e：用科学计数法格式化浮点数</p><h3 id="lambda函数学习"><a href="#lambda函数学习" class="headerlink" title="lambda函数学习"></a>lambda函数学习</h3><p>lambda函数是一种匿名函数，python允许使用lambda 关键字来创建匿名函数，匿名函数比普通函数要简洁。</p><p>lambda函数的使用方法：</p><p>python中lambda函数的使用非常的精简，基本语法是在冒号（：）左边放原函数的参数，可以有多个参数，用逗号（，）隔开即可：冒号右边是返回值。</p><p>举例：</p><p>当只有一个参数的时候：</p><p>普通函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ds</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x+<span class="hljs-number">1</span><br>y=ds(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><p>输出值为11</p><p>匿名函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y=<span class="hljs-keyword">lambda</span> x : <span class="hljs-number">2</span>*x+<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(y(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>输出值为11</p><p>当有两个或者两个以上的参数时：</p><p>普通函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y</span>):<br>  <span class="hljs-keyword">return</span> x+y<br>z=add(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(z)<br></code></pre></td></tr></table></figure><p>匿名函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">z=<span class="hljs-keyword">lambda</span> x,y : x+y<br><span class="hljs-built_in">print</span>(z(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure><p>lambda函数的作用：</p><p>1.python写一些执行脚本时，使用lambda就可以省下定义函数过程，比如说只是需要写个简单的脚本来管理服务器时，就不需要专门定义一个函数然后再写调用，使用lambda函数就可以使代码变得更加精简。</p><p>2．对于一些比较抽象并且整个程序执行下来只需要调用一两次的函数，有时候给函数起个名字也是比较头疼的问题，使用lambda函数就不需要 考虑命名的问题了。</p><p>3.简化代码的可读性，由于阅读普通函数经常要跳到开头def定义的位置，使用lambda函数就可以省去这样的步骤</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">string1=<span class="hljs-built_in">input</span>()<br>list_string=<span class="hljs-built_in">list</span>(string1)  <span class="hljs-comment">#将字符串转化成列表</span><br><span class="hljs-built_in">print</span>(list_string)<br><span class="hljs-comment">#向列表中添加元素</span><br>list_string.append()  <span class="hljs-comment">#append()可以在列表末尾添加单个元素</span><br>list_string.extend([])  <span class="hljs-comment">#extend()可以在列表末尾添加多个元素 且元素是以列表的形式添加的</span><br>list_string.insert(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)  <span class="hljs-comment">#insert()可以在列表的任意位置添加元素 insert()有两个参数 第一个参数代表在列表中的插入位置 第二个参数代表在列表中插入的元素</span><br><span class="hljs-comment">#从列表中获取元素 类似于数组</span><br><span class="hljs-comment">#列表分片 列表的分片可以更加快速的获取列表中的元素</span><br>list_string[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]  <span class="hljs-comment">#分号前后的两个参数值分别代表元素的位置</span><br>list_string[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>:<span class="hljs-number">2</span>]  <span class="hljs-comment">#列表分片还可以引入第三个参数步长 步长代表每前进一个步长后再取出一个元素</span><br>list_string[::-<span class="hljs-number">1</span>]  <span class="hljs-comment">#特殊情况 当步长为-1时 代表输出一个反转列表</span><br><span class="hljs-comment">#从列表中删除元素</span><br>list_string.remove(<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment">#无需知道元素的位置 若不存在则会报错 remove不能删除指定位置的元素</span><br><span class="hljs-keyword">del</span> list_string[<span class="hljs-number">0</span>]  <span class="hljs-comment">#del是语句不是列表方法 不用小括号 []中元素代表删除元素的位置</span><br>list_string.pop()  <span class="hljs-comment">#pop默认弹出列表中的最后一个元素 当在()中加上索引值也可以删除具体位置的列表元素</span><br><span class="hljs-comment">#列表比较大小 列表的+ *</span><br>list_string+list_string  <span class="hljs-comment">#+表示连接两个列表</span><br>list_string*<span class="hljs-number">3</span>  <span class="hljs-comment">#*表示对列表进行3次复制</span><br>list_string.count(<span class="hljs-number">1</span>)  <span class="hljs-comment">#count()用于计算()中参数在列表中出现的次数</span><br>list_string.index(<span class="hljs-number">1</span>)  <span class="hljs-comment">#index()用于返回()中参数在列表中的位置</span><br>list_string.index(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)  <span class="hljs-comment">#index()方法还有两个参数 限定查找范围</span><br>list_string.reverse()  <span class="hljs-comment">#reverse()对列表进行反转</span><br>list_string.sort()  <span class="hljs-comment">#sort()对列表进行排序</span><br>string2=<span class="hljs-string">&#x27;&#x27;</span>.join(list_string)  <span class="hljs-comment">#将列表转化成字符串</span><br><span class="hljs-built_in">print</span>(string2)<br></code></pre></td></tr></table></figure><h3 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a><strong>字典和集合</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建和访问字典</span><br>dict1=&#123;<span class="hljs-string">&quot;李宁&quot;</span>:<span class="hljs-string">&quot;一切皆有可能&quot;</span>,<span class="hljs-string">&quot;耐克&quot;</span>:<span class="hljs-string">&quot;Just do it&quot;</span>,<span class="hljs-string">&quot;阿迪达斯&quot;</span>:<span class="hljs-string">&quot;Impossible is nothing&quot;</span>,<span class="hljs-string">&quot;鱼C工作室&quot;</span>:<span class="hljs-string">&quot;让编程改变时间&quot;</span>&#125;<br><span class="hljs-comment">#冒号：前面的是键 后面的是值</span><br><span class="hljs-comment">#也可以用dict()来创建字典</span><br>dict1=dict1(F=<span class="hljs-number">70</span>,i=<span class="hljs-number">105</span>,s=<span class="hljs-number">115</span>,h=<span class="hljs-number">104</span>,C=<span class="hljs-number">67</span>)<br>dict1.fromkeys((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-string">&quot;Number&quot;</span>)  <span class="hljs-comment">#fromkeys()用于创建并返回一个新的字典 有两个参数 第一个参数时字典的键 第二个参数时传入键对应的值</span><br><span class="hljs-comment">#访问字典</span><br>dict1=&#123;&#125;<br>dict1=dict1.fromkeys(<span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>),<span class="hljs-string">&quot;赞&quot;</span>)<br>dict1.keys()  <span class="hljs-comment">#keys()用于返回字典中的键</span><br>dict1.values()  <span class="hljs-comment">#values()用于返回字典中所有的值</span><br>dict1.items()  <span class="hljs-comment">#items()返回字典中所有的键值对</span><br>dict1.get(<span class="hljs-number">31</span>,<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment">#第二个参数为所设置的默认返回值 可以不加</span><br>dict1.clear()  <span class="hljs-comment">#清空字典</span><br>dict1.copy  <span class="hljs-comment">#复制字典</span><br>dict1.pop(<span class="hljs-number">2</span>)  <span class="hljs-comment">#给定键弹出对应的值</span><br>dict1.popitem  <span class="hljs-comment">#弹出一项</span><br>dict1.update()  <span class="hljs-comment">#用来更新字典</span><br><span class="hljs-comment">#dict1=&#123;&quot;米奇&quot;:&quot;老鼠&quot;,&quot;汤姆&quot;:&quot;猫&quot;,&quot;小白&quot;:&quot;猪&quot;&#125;</span><br><span class="hljs-comment">#dict1.update(小白=&quot;狗&quot;)</span><br><span class="hljs-comment">#集合</span><br><span class="hljs-comment">#集合：用大括号括起来一堆数字 如果没有体现出映射关系就是集合</span><br><span class="hljs-comment">#集合具有无序性 无法索引集合中的某个元素</span><br><span class="hljs-comment">#集合会自动删除重复的元素</span><br><span class="hljs-comment">#创建集合</span><br>set1=&#123;<span class="hljs-string">&quot;小甲鱼&quot;</span>,<span class="hljs-string">&quot;小鱿鱼&quot;</span>,<span class="hljs-string">&quot;小姑娘&quot;</span>,<span class="hljs-string">&quot;小甲鱼&quot;</span>&#125;  <span class="hljs-comment">#用大括号括起来创建</span><br>set2=<span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;小甲鱼&quot;</span>,<span class="hljs-string">&quot;小鱿鱼&quot;</span>,<span class="hljs-string">&quot;小姑娘&quot;</span>,<span class="hljs-string">&quot;小甲鱼&quot;</span>])  <span class="hljs-comment">#直接创建</span><br><span class="hljs-comment">#访问集合</span><br><span class="hljs-comment">#集合是无序的所以不能用下标访问 但是可以用迭代的方法访问</span><br>set1=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;<br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> set1:<br>    <span class="hljs-built_in">print</span>(each,end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment">#也可以用in或not in判断元素是否在集合中存在</span><br>set1.add(<span class="hljs-number">6</span>)  <span class="hljs-comment">#add()方法可以为集合添加元素</span><br>set1.remove(<span class="hljs-number">5</span>)  <span class="hljs-comment">#remove可以删除集合中的已知元素</span><br><span class="hljs-comment">#不可变集合</span><br>set1=<span class="hljs-built_in">frozenset</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 560.和为 K 的子数组</title>
    <link href="/2022/04/18/LC%20560.%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/04/18/LC%20560.%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-560-和为-K-的子数组"><a href="#LC-560-和为-K-的子数组" class="headerlink" title="LC 560.和为 K 的子数组"></a>LC 560.和为 K 的子数组</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>解决数组问题时，如果多层循环遍历超时，多考虑前缀和的思想来减少循环次数降低时间复杂度。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法1：枚举"><a href="#方法1：枚举" class="headerlink" title="方法1：枚举"></a>方法1：枚举</h4><p>两层循环遍历，超出时间限制</p><h4 id="方法2：前缀和-哈希表"><a href="#方法2：前缀和-哈希表" class="headerlink" title="方法2：前缀和+哈希表"></a>方法2：前缀和+哈希表</h4><blockquote><p>我们可以基于方法一利用数据结构进行进一步的优化，我们知道方法一的瓶颈在于对每个 i，我们需要枚举所有的 j 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。</p><p>我们定义 pre[i] 为 0..i 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：<br>pre[i]=pre[i−1]+nums[i]</p><p>那么 j..i 这个子数组和为 k 这个条件我们可以转化为<br>pre[i]−pre[j−1]==k</p><p>简单移项可得符合条件的下标 j 需要满足<br>pre[j−1]==pre[i]−k</p><p>所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1) 时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。</p><p>需要注意的是，从左往右边更新边计算的时候已经保证了mp[pre[i]−k] 里记录的 pre[j] 的下标范围是 0≤j≤i 。同时，由于 pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用 pre 变量来记录 pre[i−1] 的答案即可。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        mp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)<br>        &#123;<br>            pre = pre+num;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(pre-k) != mp.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                cnt = cnt+mp[pre-k];<br>            &#125;<br>            mp[pre]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>LeetCode题解：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/">https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 385.迷你语法分析器</title>
    <link href="/2022/04/15/LC%20385.%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <url>/2022/04/15/LC%20385.%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-385-迷你语法分析器"><a href="#LC-385-迷你语法分析器" class="headerlink" title="LC 385.迷你语法分析器"></a>LC 385.迷你语法分析器</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>一道题做了一个多小时，人都麻了… 4.15今天日子也很特殊 哈哈哈！</p></blockquote><p>这道题的 NestedInteger 其实就是定义的一个新的数据类型，相当于集合之类的。核心思想就是栈的嵌套，先把 NestedInteger 类型的数字放入栈中，然后再将栈顶的元素top嵌套入栈的top-1中。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。</p><p>列表中的每个元素只可能是整数或整数嵌套列表</p><p>示例1</p><blockquote><p>输入：s = “324”,<br>输出：324<br>解释：你应该返回一个 NestedInteger 对象，其中只包含整数值 324。</p></blockquote><p>示例2</p><blockquote><p>输入：s = “[123,[456,[789]]]”,<br>输出：[123,[456,[789]]]<br>解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：</p><ol><li>一个 integer 包含值 123</li><li>一个包含两个元素的嵌套列表：<br> i.  一个 integer 包含值 456<br> ii. 一个包含一个元素的嵌套列表<pre><code class="hljs">  a. 一个 integer 包含值 789</code></pre></li></ol></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：深度优先搜索</strong></p><p>模拟</p><p><strong>方法2：栈</strong></p><p><img src="https://raw.githubusercontent.com/yiqiangshiyia/img/main/images/QQ%E6%88%AA%E5%9B%BE20220415164146.png" alt="图示模拟栈的过程"></p><p>当s[i] == ‘[‘时：建立一个’[]’，放入栈中</p><p>当isdigit(s[i])时：记录数字num</p><p>当s[i] == ‘,’ || s[i] == ‘]’时：如果数字不为空，将数字加入栈顶，重置数字num = 0</p><p>当s[i] == ‘]’ &amp;&amp; st.size()&gt;1时，将栈顶元素加入栈顶的倒数第二个元素中，直到栈的到小为1</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">NestedInteger <span class="hljs-title">deserialize</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;[&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">NestedInteger</span>(<span class="hljs-built_in">stoi</span>(s));<br>        stack&lt;NestedInteger&gt; st;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span>)<br>            &#123;<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">NestedInteger</span>());<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i]))<br>            &#123;<br>                num = num*<span class="hljs-number">10</span> + s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;,&#x27;</span> || s[i] == <span class="hljs-string">&#x27;]&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i<span class="hljs-number">-1</span>]))<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(flag)  num = num*<span class="hljs-number">-1</span>;<br>                    st.<span class="hljs-built_in">top</span>().<span class="hljs-built_in">add</span>(<span class="hljs-built_in">NestedInteger</span>(num));<br>                    num = <span class="hljs-number">0</span>;<br>                    flag = <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; st.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>                &#123;<br>                    NestedInteger ni = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    st.<span class="hljs-built_in">top</span>().<span class="hljs-built_in">add</span>(ni);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>b栈学习视频：<a href="https://www.bilibili.com/video/BV195411U7h4?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV195411U7h4?spm_id_from=333.337.search-card.all.click</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dapp学习</title>
    <link href="/2022/04/14/Dapp%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/04/14/Dapp%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Dapp"><a href="#Dapp" class="headerlink" title="Dapp"></a>Dapp</h2><h3 id="Dapp原理"><a href="#Dapp原理" class="headerlink" title="Dapp原理"></a>Dapp原理</h3><p>中心化app的数据存储在中心化服务器上，dapp的数据存储在区块链上</p><h3 id="Dapp开发环境"><a href="#Dapp开发环境" class="headerlink" title="Dapp开发环境"></a>Dapp开发环境</h3><blockquote><p>以太坊：以太坊（英文Ethereum）是一个开源的有智能合约功能的公共区块链平台，通过其专用加密货币以太币（Ether，简称“ETH”）提供去中心化的以太虚拟机（Ethereum Virtual Machine）来处理点对点合约。</p></blockquote><p>基于以太坊的开发环境</p><ul><li><p>geth+js</p></li><li><p>ganache+js（主要）</p></li><li><p>truffle（js框架 以太坊官方提供的框架）</p></li></ul><h3 id="Geth私链环境搭建"><a href="#Geth私链环境搭建" class="headerlink" title="Geth私链环境搭建"></a>Geth私链环境搭建</h3><p>geth是以太坊的一个客户端</p><ul><li><p>安装geth</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">$ sudo apt-get install software-properties-common<br>$ sudo<span class="hljs-built_in"> add-apt-repository </span>-y ppa:ethereum/etherum<br>$ sudo apt-get update<br>$ sudo apt-get install etherum<br></code></pre></td></tr></table></figure></li></ul><h3 id="ganache使用"><a href="#ganache使用" class="headerlink" title="ganache使用"></a>ganache使用</h3><ul><li><p>ganache</p><p>目前主流的基于以太坊开发Dapp的方式主要是ganache和truffle</p><p>ganache的github地址：<a href="https://link.zhihu.com/?target=https://github.com/trufflesuite/ganache/releases">https://</a><a href="https://github.com/trufflesuite/ganache/releases">https://github.com/trufflesuite/ganache/releases</a></p><blockquote><p>Ganache可以快速启动个人以太坊区块链，并可以使用它来运行测试，执行命令、检查状态，同时控制链条的运行方式。通过Ganache我们可以快速查看所有账户的当前状态，包括他们的地址、私钥、交易和余额。查看Ganache内部区块链的日志输出，包括响应和其他重要的调试信息，检查所有块和交易，以获取相关问题的信息。</p></blockquote></li><li><p>连接ganache节点-Remix连接节点</p></li><li><p>连接ganache节点-MetaMask连接节点（导入账号）</p></li></ul><p>知乎上有具体使用方法：<a href="https://zhuanlan.zhihu.com/p/46524142">https://zhuanlan.zhihu.com/p/46524142</a></p><h3 id="使用Web3js和区块链进行交互"><a href="#使用Web3js和区块链进行交互" class="headerlink" title="使用Web3js和区块链进行交互"></a>使用Web3js和区块链进行交互</h3><ul><li>express安装</li><li>创建工程</li><li>和区块链交互</li><li>运行</li></ul><h3 id="智能合约编写、部署"><a href="#智能合约编写、部署" class="headerlink" title="智能合约编写、部署"></a>智能合约编写、部署</h3><p><a href="http://remix.hubwiz.com/#optimize=false&version=soljson-v0.5.1+commit.c8a2cb62.js">智能合约在线编译器</a></p><h3 id="完整Dapp-demo"><a href="#完整Dapp-demo" class="headerlink" title="完整Dapp demo"></a>完整Dapp demo</h3><ul><li><p>编写智能合约</p></li><li><p>编译合约</p><p>在remix上进行编译</p><blockquote><p>智能合约在线编译器：<a href="http://remix.hubwiz.com/#optimize=false&amp;version=soljson-v0.5.1+commit.c8a2cb62.js">http://remix.hubwiz.com/#optimize=false&amp;version=soljson-v0.5.1+commit.c8a2cb62.js</a></p></blockquote></li><li><p>部署合约</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">ganache-<span class="hljs-keyword">cli</span><br><span class="hljs-keyword">mkdir</span> deploy-proj<br><span class="hljs-keyword">cd</span> deploy-proj<br>npm install web3 -<span class="hljs-keyword">save</span><br></code></pre></td></tr></table></figure><p>编写deploy.js</p><p>部署</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">deploy</span>.js<br></code></pre></td></tr></table></figure></li><li><p>创建工程</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">express -e dapp4<br>cd dapp4<br><span class="hljs-built_in">npm</span> install<br><span class="hljs-built_in">npm</span> start<br></code></pre></td></tr></table></figure></li><li><p>修改app.js</p></li><li><p>修改route/index.js</p></li><li><p>编辑view/index.html</p></li><li><p>运行</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">ganache-<span class="hljs-keyword">cli</span><br>npm_start<br></code></pre></td></tr></table></figure></li></ul><h3 id="使用truffle"><a href="#使用truffle" class="headerlink" title="使用truffle"></a>使用truffle</h3><ul><li><p>truffle介绍</p><p>Truffle是针对基于以太坊的Solidity语言的一套开发框架，本身基于Javascript。</p><p>官方学习文档：<a href="https://learnblockchain.cn/docs/truffle/index.html">https://learnblockchain.cn/docs/truffle/index.html</a></p></li><li><p>安装truffle</p><p>只要通过以下命令就可以安装Truffle</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g truffle<br></code></pre></td></tr></table></figure></li><li><p>写合约</p><p>写完合约之后在remix中调试</p></li><li><p>创建工程</p><ul><li>使用命令创建工程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> Vote<br><span class="hljs-built_in">cd</span> Vote<br>truffle unbox webpack<br></code></pre></td></tr></table></figure><ul><li>创建合约</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> contracts<br><span class="hljs-keyword">rm</span> <span class="hljs-keyword">meta</span>.sol<br><span class="hljs-keyword">rm</span> Lib.sol<br>vim Voting.sol<br></code></pre></td></tr></table></figure><ul><li><p>将上面的合约代码复制到Voting.sol中</p></li><li><p>修改migrations/_deploy_contracts.js</p></li></ul></li><li><p>编译合约</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">truffle compile</span><br></code></pre></td></tr></table></figure></li><li><p>部署合约</p><ul><li><p>启动ganache-cli</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">ganache-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure></li><li><p>修改truffle-config.js</p></li><li><p>部署</p></li><li><p>部署完后可以用truffle console进行测试</p></li></ul></li><li><p>修改前端页面</p><p>修改app/src/index.html</p><p>修改app/src/index.js</p></li><li><p>运行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> dev<br></code></pre></td></tr></table></figure><p>打开浏览器，输入127.0.0.1:8080</p><p><strong>使用truffle完成投票dapp的开发实例</strong></p><p>1、投票的智能合约</p><p>投票智能合约代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript">pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.6</span><span class="hljs-number">.0</span>;<br><br>contract <span class="hljs-title class_">Voting</span> &#123;<br>    bytes32[] <span class="hljs-keyword">public</span> candidateList;<br>    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">bytes32</span> =&gt;</span> uint8) <span class="hljs-keyword">public</span> votesReceived;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">bytes32[] memory candidateListName</span>) <span class="hljs-keyword">public</span>  &#123;<br>        candidateList = candidateListName;<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateCanditate</span>(<span class="hljs-params">bytes32 candidateName</span>)internal view <span class="hljs-title function_">returns</span>(<span class="hljs-params">bool</span>) &#123;<br>        <span class="hljs-keyword">for</span> (uint8 i =<span class="hljs-number">0</span>; i &lt; candidateList.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (candidateName == candidateList[i])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">voteForCandidate</span>(<span class="hljs-params">bytes32 candidateName</span>) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-built_in">require</span>(<span class="hljs-title function_">validateCanditate</span>(candidateName));<br>        votesReceived[candidateName] += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">totalVotesFor</span>(<span class="hljs-params">bytes32 candidateName</span>) view <span class="hljs-keyword">public</span> <span class="hljs-title function_">returns</span>(<span class="hljs-params">uint8</span>) &#123;<br>        <span class="hljs-built_in">require</span>(<span class="hljs-title function_">validateCanditate</span>(candidateName));<br>        <span class="hljs-keyword">return</span> votesReceived[candidateName];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、合约的编译部署</p><p>3、编写前端页面</p><p>4、和智能合约的交互</p></li></ul><p>区块链学习官站：<a href="https://learnblockchain.cn/">https://learnblockchain.cn/</a></p><p>区块链、超级账本、智能合约等概念官网文档 <a href="https://gitee.com/link?target=https://hyperledger-fabric.readthedocs.io/en/release-1.4/">https://hyperledger-fabric.readthedocs.io/en/release-1.4/</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++字符串常用函数</title>
    <link href="/2022/04/11/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/2022/04/11/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h2><h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a>push_back()函数</h3><blockquote><p>push_back()函数的用法</p><p>函数将一个新的元素加到vector的最后面，位置为当前最后一个元素的下一个元素。</p></blockquote><p><strong>push_back()函数也同样适用于string字符串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;&quot;</span>;<br>str.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;d&#x27;</span>);<br></code></pre></td></tr></table></figure><p>类似的：</p><p>pop_back()    //移除最后一个元素</p><p>clear()    //清空所有元素</p><p>empty()    //判断vector是否为空，如果返回true为空</p><p>erase()    // 删除指定元素</p><h3 id="reverse-函数"><a href="#reverse-函数" class="headerlink" title="reverse()函数"></a>reverse()函数</h3><p>对字符串进行翻转的函数</p><p>reverse(s.begin(),s.end());</p><h3 id="str-‘0’"><a href="#str-‘0’" class="headerlink" title="str-‘0’"></a>str-‘0’</h3><p>实际就是减去 ‘0’ 的ASCII码值，也就是一个整数。</p><p>对字符串进行类型转换（string→int）</p><h3 id="isdigit-函数"><a href="#isdigit-函数" class="headerlink" title="isdigit()函数"></a>isdigit()函数</h3><p>C ++库函数 void isalpha(int c) 检查所传的字符是否是字母。</p><h3 id="isalpha-函数"><a href="#isalpha-函数" class="headerlink" title="isalpha()函数"></a>isalpha()函数</h3><p>C ++库函数 void isalpha(int c) 检查所传的字符是否是字母。</p><h3 id="add-函数"><a href="#add-函数" class="headerlink" title="add()函数"></a>add()函数</h3><h3 id="stoi-函数"><a href="#stoi-函数" class="headerlink" title="stoi()函数"></a>stoi()函数</h3><p>stoi函数中放入string类型的参数，可以把string类型转换成int类型</p><h3 id="substr-函数"><a href="#substr-函数" class="headerlink" title="substr()函数"></a>substr()函数</h3><p>用途：一种构造string的方法，也可以用来复制字符串的一部分</p><p>形式：s.substr(pos, n)</p><p>解释：返回一个string，包含s中从pos开始的n个字符的拷贝（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）</p><p>补充：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾</p><h3 id="tolower-函数"><a href="#tolower-函数" class="headerlink" title="tolower()函数"></a>tolower()函数</h3><p>C ++库函数 int tolower(int c) 把给定的字母转换为小写字母。</p><h3 id="toupper-函数"><a href="#toupper-函数" class="headerlink" title="toupper()函数"></a>toupper()函数</h3><p>C ++库函数 int toupper(int c) 把给定的字母转换为大写字母。</p><h3 id="string-back-函数"><a href="#string-back-函数" class="headerlink" title="string.back()函数"></a>string.back()函数</h3><p>C++string.back()函数 此函数同于访问字符串的最后一个字符 。</p><h3 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a>find()函数</h3><p>C++ string中的find()函数，string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数）</p><ul><li><p>返回子串出现在母串中的首次出现的位置，和最后一次出现的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">flag = <span class="hljs-string">&quot;c&quot;</span>;<br>position = s.<span class="hljs-built_in">find_first_of</span>(flag);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s.find_first_of(flag) is :%d\n&quot;</span>,position);<br>position = s.<span class="hljs-built_in">find_last_of</span>(flag);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s.find_last_of(flag) is :%d\n&quot;</span>,position);<br></code></pre></td></tr></table></figure></li><li><p>查找某一给定位置后的子串的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//从字符串s 下标5开始，查找字符串b ,返回b 在s 中的下标</span><br>  position=s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">5</span>);<br>  cout&lt;&lt;<span class="hljs-string">&quot;s.find(b,5) is : &quot;</span>&lt;&lt;position&lt;&lt;endl;<br></code></pre></td></tr></table></figure></li><li><p>查找所有子串在母串中出现的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//查找s 中flag 出现的所有位置。</span><br>    <span class="hljs-type">char</span> flag=<span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-type">int</span> position=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>((position=s.<span class="hljs-built_in">find</span>(flag,position))!=string::npos)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;position  &quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; : &quot;</span>&lt;&lt;position&lt;&lt;endl;<br>        position++;<br>        i++;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="C-数据类型转换"><a href="#C-数据类型转换" class="headerlink" title="C++ 数据类型转换"></a>C++ 数据类型转换</h2><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><blockquote><p>自动类型转换是指在不同类型数据进行混合运算时，系统会自动进行数据类型的转换。</p></blockquote><p>string→int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str;<br>cout&lt;&lt;str-<span class="hljs-string">&#x27;0&#x27;</span><br>cout&lt;&lt;str-<span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>int→string</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><blockquote><p>强制类型转换在表达式中可以根据需要把任意一个数据的类型转换成另一个数据类型。强制类型转换是靠强制类型转换控制运算符实现的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-built_in">double</span>(<span class="hljs-number">2.5</span>);<br><span class="hljs-type">double</span> b = <span class="hljs-built_in">double</span>(<span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><p><a href="http://c.biancheng.net/view/208.html">http://c.biancheng.net/view/208.html</a></p><p><a href="https://blog.csdn.net/weixin_46274168/article/details/117209139">https://blog.csdn.net/weixin_46274168/article/details/117209139</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map unordered_map set unordered_set的用法和区别</title>
    <link href="/2022/04/10/map%20unordered_map%20set%20unordered_set%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/10/map%20unordered_map%20set%20unordered_set%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><table><thead><tr><th align="center"><strong>数据结构</strong></th><th align="center"><strong>map</strong></th><th align="center"><strong>unordered_map</strong></th><th align="center"><strong>set</strong></th><th align="center"><strong>unordered_set</strong></th></tr></thead><tbody><tr><td align="center">实现机理</td><td align="center">红黑树</td><td align="center">hash表</td><td align="center">红黑树</td><td align="center">hash表</td></tr><tr><td align="center">元素格式</td><td align="center">key+value</td><td align="center">key+value</td><td align="center">key</td><td align="center">key</td></tr><tr><td align="center">存储规律</td><td align="center">键升序</td><td align="center">无序</td><td align="center">键升序</td><td align="center">无序</td></tr><tr><td align="center">元素重复</td><td align="center">键不可,值可</td><td align="center">键不可,值可</td><td align="center">不可重复</td><td align="center">不可重复</td></tr><tr><td align="center">头文件</td><td align="center">#include&lt; map&gt;</td><td align="center">#include<unordered_map></td><td align="center">#include&lt; set&gt;</td><td align="center">#include<unordered_set></td></tr></tbody></table><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h4 id="内部实现机理"><a href="#内部实现机理" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>map内部实现了一个 红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树）， 红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p><h4 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a><strong>优缺点以及适用处</strong></h4><p>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作；红黑树，内部实现一个红黑树使得map的很多操作在O(logN)的时间复杂度下就可以实现，因此效率非常的高。</p><p>缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率（低于unorder_map），但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间（但占用的内存比unorder_map低）</p><p>适用处：对于那些数据存储有顺序要求的问题，用map会更高效一些</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>1.构造函数 2.插入数据 3.判断是否有元素 4.遍历 5.查找 </p><p>参考博客</p><p><a href="https://blog.csdn.net/weixin_45774972/article/details/113418453?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">C++ 中使用哈希表(unordered_map)的常用操作</a> </p><p><a href="https://lover.blog.csdn.net/article/details/82633778?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&utm_relevant_index=6">简述C++中map和unordered_map的用法</a> </p><p><a href="https://blog.csdn.net/qq_30815237/article/details/91047041">C++ map set unordered_map和unorder_set的区别</a></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; list = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">34</span>,<span class="hljs-number">22</span>,<span class="hljs-number">39</span>,<span class="hljs-number">5</span> &#125;;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = list.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>map[i] = list[i];  <span class="hljs-comment">//倒序插入</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = map.<span class="hljs-built_in">begin</span>(); i != map.<span class="hljs-built_in">end</span>(); i++) &#123;<br>cout &lt;&lt; i-&gt;first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;  <span class="hljs-comment">//输出的数是有序的且有两个5</span><br>&#125;<br><span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != map.<span class="hljs-built_in">end</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;find key=&quot;</span> &lt;&lt; map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>)-&gt;first &lt;&lt; <span class="hljs-string">&quot;, value=&quot;</span> &lt;&lt; map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>)-&gt;second &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">count</span>(<span class="hljs-number">5</span>) &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//m.count(n)计算下标为n的位置有无数据，有返回1，无返回0</span><br>cout &lt;&lt; <span class="hljs-string">&quot;count 5: &quot;</span> &lt;&lt; map.<span class="hljs-built_in">count</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;  <span class="hljs-comment">//find()和count()的输入参数都是key值</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>map是基于RBT的，因此元素是有序存储的（默认按键的升序排列）。</p></blockquote><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><h4 id="内部实现机理-1"><a href="#内部实现机理-1" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>unordered_map内部实现了一个 哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此， 其元素的排列顺序是无序的。</p><h4 id="优缺点以及适用处-1"><a href="#优缺点以及适用处-1" class="headerlink" title="优缺点以及适用处"></a><strong>优缺点以及适用处</strong></h4><p>优点： 因为内部实现了哈希表，因此其查找速度非常的快（运行效率快于map）</p><p>缺点： 哈希表的建立比较耗费时间（unorder_map占用的内存比map要高）</p><p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><p>1.构造函数 2.插入数据 3.判断是否有元素 4.遍历 5.查找 </p><p><a href="https://blog.csdn.net/weixin_45774972/article/details/113418453?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">C++ 中使用哈希表(unordered_map)的常用操作</a> </p><p><a href="https://lover.blog.csdn.net/article/details/82633778?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&utm_relevant_index=6">简述C++中map和unordered_map的用法</a> </p><p><a href="https://blog.csdn.net/qq_30815237/article/details/91047041">C++ map set unordered_map和unorder_set的区别</a></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; list = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">34</span>,<span class="hljs-number">22</span>,<span class="hljs-number">39</span>,<span class="hljs-number">5</span> &#125;;<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = list.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>map[i] = list[i];  <span class="hljs-comment">//倒序插入</span><br>&#125;<br>cout &lt;&lt; map[<span class="hljs-number">0</span>] &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator i = map.<span class="hljs-built_in">begin</span>(); i != map.<span class="hljs-built_in">end</span>(); i++) &#123;<br>cout &lt;&lt; i-&gt;first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;  <span class="hljs-comment">//输出的数是有序的且有两个5</span><br>&#125;<br><span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != map.<span class="hljs-built_in">end</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;find key=&quot;</span> &lt;&lt; map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>)-&gt;first &lt;&lt; <span class="hljs-string">&quot;, value=&quot;</span> &lt;&lt; map.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>)-&gt;second &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">count</span>(<span class="hljs-number">5</span>) &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//m.count(n)计算下标为n的位置有无数据，有返回1，无返回0</span><br>cout &lt;&lt; <span class="hljs-string">&quot;find 5: &quot;</span> &lt;&lt; map.<span class="hljs-built_in">count</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;  <span class="hljs-comment">//find()和count()的输入都是key值</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>unordered_map 是基于hash表的，因此元素是无序存储的（不按键升序排列）。</p></blockquote><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h4 id="内部实现机理-2"><a href="#内部实现机理-2" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; list = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">34</span>,<span class="hljs-number">22</span>,<span class="hljs-number">39</span>,<span class="hljs-number">5</span> &#125;;<br>set&lt;<span class="hljs-type">int</span>&gt; set1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = list.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>set1.<span class="hljs-built_in">insert</span>(list[i]);  <span class="hljs-comment">//倒序插入</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = set1.<span class="hljs-built_in">begin</span>(); i != set1.<span class="hljs-built_in">end</span>(); i++) &#123;<br>cout &lt;&lt; *i &lt;&lt; endl;  <span class="hljs-comment">//输出的数是有序的且只有一个5</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;find 5: &quot;</span> &lt;&lt; *set1.<span class="hljs-built_in">find</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;<br>cout &lt;&lt;<span class="hljs-string">&quot;count 5: &quot;</span> &lt;&lt; set1.<span class="hljs-built_in">count</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><blockquote><p>set 是基于RBT的，因此元素是顺序存储的（默认按键值升序排列）。</p></blockquote><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><h4 id="内部实现机理-3"><a href="#内部实现机理-3" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>unordered_set的内部实现了一个 哈希表，因此， 其元素的排列顺序是无序的。</p><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; list = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">34</span>,<span class="hljs-number">22</span>,<span class="hljs-number">39</span>,<span class="hljs-number">5</span> &#125;;<br>unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = list.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>set.<span class="hljs-built_in">insert</span>(list[i]);  <span class="hljs-comment">//倒序插入</span><br>&#125;<br><span class="hljs-keyword">for</span> (unordered_set&lt;<span class="hljs-type">int</span>&gt;::iterator i = set.<span class="hljs-built_in">begin</span>(); i != set.<span class="hljs-built_in">end</span>(); i++) &#123;<br>cout &lt;&lt; *i &lt;&lt; endl;  <span class="hljs-comment">//输出的数是无序的且只有一个5</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;find 39: &quot;</span> &lt;&lt; *set.<span class="hljs-built_in">find</span>(<span class="hljs-number">39</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;count 14:&quot;</span> &lt;&lt; set.<span class="hljs-built_in">count</span>(<span class="hljs-number">14</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><blockquote><p>unordered_set 是基于hash表的，因此元素是无序存储的（不按键值升序排列）。</p></blockquote><h2 id="unordered-map与unordered-set的区别"><a href="#unordered-map与unordered-set的区别" class="headerlink" title="unordered_map与unordered_set的区别"></a>unordered_map与unordered_set的区别</h2><blockquote><p>后者就是在哈希表插入value，而这个value就是它自己的key，而不是像之前的unordered_map那样有键-值对，这里单纯就是为了方便查询这些值。</p><p>它们几乎相同. unordered_set只包含键,没有值.没有从键到值的映射,因此不需要operator[]. unordered_map将键映射到值.</p></blockquote><h2 id="unordered-map与map的区别"><a href="#unordered-map与map的区别" class="headerlink" title="unordered_map与map的区别"></a>unordered_map与map的区别</h2><blockquote><p>这两个的内部结构都是采用哈希表来实现。区别在哪里？unordered_map在C++11的时候被引入标准库了，而hash_map没有，所以建议还是使用unordered_map比较好。</p></blockquote><h2 id="hash-map与unordered-map的区别"><a href="#hash-map与unordered-map的区别" class="headerlink" title="hash_map与unordered_map的区别"></a>hash_map与unordered_map的区别</h2><blockquote><p>虽然都是map，但是内部结构大大的不同哎，map的内部结构是R-B-tree来实现的，所以保证了一个稳定的动态操作时间，查询、插入、删除都是O（logN），最坏和平均都是。而unordered_map如前所述，是哈希表。顺便提一下，哈希表的查询时间虽然是O（1），但是并不是unordered_map查询时间一定比map短，因为实际情况中还要考虑到数据量，而且unordered_map的hash函数的构造速度也没那么快，所以不能一概而论，应该具体情况具体分析。</p></blockquote><p>参考博客：</p><p><a href="https://blog.csdn.net/bryant_zhang/article/details/111600209">C++：map,unordered_map,set和unordered_set的用法和区别</a></p><p><a href="https://blog.csdn.net/u013195320/article/details/23046305?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&utm_relevant_index=1">C++中map、hash_map、unordered_map、unordered_set通俗辨析</a></p><p> </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数据库系统概论」期末复习</title>
    <link href="/2022/04/07/%E3%80%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8D%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/04/07/%E3%80%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8D%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h1><p><a href="https://youpai.roccoshi.top/img/20210107010414.png"><img src="https://youpai.roccoshi.top/img/20210107010414.png" alt="img"></a></p><h1 id="2-关系数据库"><a href="#2-关系数据库" class="headerlink" title="2. 关系数据库"></a>2. 关系数据库</h1><h2 id="1-关系数据结构及形式化定义"><a href="#1-关系数据结构及形式化定义" class="headerlink" title="1 | 关系数据结构及形式化定义"></a>1 | 关系数据结构及形式化定义</h2><p>关系模型中数据的逻辑结构是一张扁平的二维表</p><p>关系是笛卡尔积的有限子集，所以关系也是一张二维表</p><p><strong>候选码</strong>：若关系中某一属性的值能唯一标识一个元组，而其子集不能，则称该属性组为候选码</p><p><strong>主码</strong>：若一个关系中有多个候选码，则选定其中一个为主码</p><p><strong>主属性</strong>：候选码的诸属性称为主属性</p><p><strong>非主属性</strong>：不包含在任何候选码中的属性称为非主属性或非码属性</p><p><strong>全码</strong>：关系模式的所有属性是这个关系模式的候选码，称为全码</p><h2 id="2-关系的完整性"><a href="#2-关系的完整性" class="headerlink" title="2 | 关系的完整性"></a>2 | 关系的完整性</h2><p>关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。</p><h2 id="3-关系代数"><a href="#3-关系代数" class="headerlink" title="3| 关系代数"></a>3| 关系代数</h2><h4 id="3-1-传统的集合运算"><a href="#3-1-传统的集合运算" class="headerlink" title="3-1 | 传统的集合运算"></a>3-1 | 传统的集合运算</h4><p>并、叉、交、笛卡尔积</p><h4 id="3-2-专门的关系运算"><a href="#3-2-专门的关系运算" class="headerlink" title="3-2 | 专门的关系运算"></a>3-2 | 专门的关系运算</h4><p>选择</p><p>投影：投影操作 是从列的角度进行运算</p><p>连接：两种常用的连接：等值连接和自然连接</p><p>除运算：除法是用象集来定义的</p><p>关系代数的五个基本操作：其余三种运算可以用这五种基本运算来表达</p><p><a href="https://youpai.roccoshi.top/img/20210107010534.png"><img src="https://youpai.roccoshi.top/img/20210107010534.png" alt="img"></a></p><p>关系代数中可能会用到的各个符号:</p><p><a href="https://youpai.roccoshi.top/img/20210107010616.png"><img src="https://youpai.roccoshi.top/img/20210107010616.png" alt="img"></a></p><h1 id="3-关系数据库标准语言SQL"><a href="#3-关系数据库标准语言SQL" class="headerlink" title="3. 关系数据库标准语言SQL"></a>3. 关系数据库标准语言SQL</h1><h2 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1 | SQL概述"></a>1 | SQL概述</h2><h3 id="1-1-SQL的特点"><a href="#1-1-SQL的特点" class="headerlink" title="1-1 | SQL的特点"></a>1-1 | SQL的特点</h3><p>1、综合统一 </p><p>2、高度非过程化</p><p>3、面向集合的操作方式</p><p>4、以同一种语法结构提供多种使用方式</p><p>5、语言简洁，易学易用</p><h3 id="1-2-SQL与三级模式体系结构图"><a href="#1-2-SQL与三级模式体系结构图" class="headerlink" title="1-2 | SQL与三级模式体系结构图"></a>1-2 | SQL与<strong>三级模式</strong>体系结构图</h3><p><a href="https://youpai.roccoshi.top/img/20210106174625.png"><img src="https://youpai.roccoshi.top/img/20210106174625.png" alt="image-20201226123540167"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174625.png">image-20201226123540167</a></p><p>模式：模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征描述，是所有用户的公共数据视图</p><p>外模式：外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</p><p>内模式：内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式</p><h2 id="2-数据定义"><a href="#2-数据定义" class="headerlink" title="2 | 数据定义"></a>2 | 数据定义</h2><p>SQL数据的定义功能：定义各种数据库的对象</p><p>SQL数据库定义功能包括模式定义、表定义、视图定义和索引定义</p><p><a href="https://youpai.roccoshi.top/img/20210106174626.png"><img src="https://youpai.roccoshi.top/img/20210106174626.png" alt="image-20201226123755751"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174626.png">image-20201226123755751</a></p><p>数据库对象命名机制的层次结构：</p><p>一个关系数据库管理系统中可以建立多个数据库，一个数据库可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</p><h3 id="2-1-模式的定义与删除"><a href="#2-1-模式的定义与删除" class="headerlink" title="2-1 | 模式的定义与删除"></a>2-1 | 模式的定义与删除</h3><h3 id="2-2-基本表的定义、删除与修改"><a href="#2-2-基本表的定义、删除与修改" class="headerlink" title="2-2 | 基本表的定义、删除与修改"></a>2-2 | 基本表的定义、删除与修改</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE <span class="hljs-operator">&lt;</span>name<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h4><p>格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>(<br>    <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>,<br>    <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>,<br>   ...<br>    <span class="hljs-operator">&lt;</span>表级完整性约束条件<span class="hljs-operator">&gt;</span><br>);<br></code></pre></td></tr></table></figure><p>列级完整性约束条件</p><p>表级完整性约束条件</p><p>实例：建立一个 “课程” 表Course</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Course<br>(Cno <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">PRIMARY</span> KEY,  <span class="hljs-comment">/*列级完整性约束条件，Cno是主码*/</span><br>     Cname <span class="hljs-type">CHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  <span class="hljs-comment">/*列级完整性约束条件，Cname不能取空值*/</span><br>     Cpno <span class="hljs-type">CHAR</span>(<span class="hljs-number">40</span>),  <span class="hljs-comment">/*Cpno的含义是先修课*/</span><br>     Ccredit <span class="hljs-type">SMALLINT</span>,<br>     <span class="hljs-keyword">FOREIGN</span> KEY(Cpno) <span class="hljs-keyword">REFERENCES</span> Course(Cno)<br>     <span class="hljs-comment">/*表级完整性约束条件，Cpno是外码，被参照表是Course，被参照对的列是Cno*/</span><br>    );<br></code></pre></td></tr></table></figure><p>常用的完整性约束:</p><p><a href="https://youpai.roccoshi.top/img/20210106174627.png"><img src="https://youpai.roccoshi.top/img/20210106174627.png" alt="image-20201226125004438"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174627.png">image-20201226125004438</a></p><h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><p>格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">ADD</span>[<span class="hljs-keyword">COLUMN</span>]<span class="hljs-operator">&lt;</span>新列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>[完整性约束]]<br>[<span class="hljs-keyword">ADD</span><span class="hljs-operator">&lt;</span>表级完整性约束<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">DROP</span>[<span class="hljs-keyword">COLUMN</span>]<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[CASCADE<span class="hljs-operator">|</span>RESTRICT]]<br>[<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span><span class="hljs-operator">&lt;</span>完整性约束名<span class="hljs-operator">&gt;</span> [RESTRICT<span class="hljs-operator">|</span>CASCADE]]<br>[<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span><span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>]<br></code></pre></td></tr></table></figure><h4 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> [RESTRICT<span class="hljs-operator">|</span>CASCADE]<br></code></pre></td></tr></table></figure><blockquote><p>RESTRICT：若选择RESTRICT，则该表的删除是有限制条件的</p><p>CASCADE：若选择CASCADE，则该表的删除是没有限制条件的</p></blockquote><h2 id="3-数据查询（重点）"><a href="#3-数据查询（重点）" class="headerlink" title="3 | 数据查询（重点）"></a>3 | 数据查询（重点）</h2><p>语法:</p><p><a href="https://youpai.roccoshi.top/img/20210106174628.png"><img src="https://youpai.roccoshi.top/img/20210106174628.png" alt="image-20201226130756283"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174628.png">image-20201226130756283</a></p><h3 id="3-1-单表查询"><a href="#3-1-单表查询" class="headerlink" title="3-1 | 单表查询"></a>3-1 | 单表查询</h3><h4 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h4><p><a href="https://youpai.roccoshi.top/img/20210106174629.png"><img src="https://youpai.roccoshi.top/img/20210106174629.png" alt="image-20201226130825216"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174629.png">image-20201226130825216</a></p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">23</span>;    <span class="hljs-comment">/*找年龄20-23岁的*/</span><br><span class="hljs-keyword">where</span> dept <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;ma&#x27;</span>, <span class="hljs-string">&#x27;cs&#x27;</span>);    <span class="hljs-comment">/*查询不是is, ma, cs系得*/</span><br><span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;刘%&#x27;</span>;    <span class="hljs-comment">/*找姓刘的*/</span><br><span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;__阳&#x27;</span>;    <span class="hljs-comment">/*找名字叫xx阳的*/</span><br><span class="hljs-keyword">where</span> cname <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;DB\_Design&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;\&#x27;</span>;<br><span class="hljs-comment">/*escape定义转义字符, 出现在其后的第一个字符不是通配符而是字符本身*/</span><br></code></pre></td></tr></table></figure><h4 id="ORDER-BY字句"><a href="#ORDER-BY字句" class="headerlink" title="ORDER BY字句"></a>ORDER BY字句</h4><p>用户可以用ORDER BY字句对查询结果按照一个或多个属性的升序（ASC）或降序（DESC）排列，默认值为升序。</p><p>对属性列排序：</p><ul><li>asc为升序</li><li>desc为降序</li><li>默认为升序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Sdept,Sage <span class="hljs-keyword">DESC</span>;  <span class="hljs-comment">/*Sdept默认升序*/</span><br></code></pre></td></tr></table></figure><h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-built_in">COUNT</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)<br><span class="hljs-built_in">SUM</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)<br><span class="hljs-built_in">AVG</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)<br><span class="hljs-built_in">MAX</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)<br><span class="hljs-built_in">MIN</span>([<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">|</span><span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>如果指定DISTINCT短语，则表示在计算时要取消指定列中的重复行。如果不指定DISTINCT短语或者ALL短语（ALL为默认值），则表示不取消重复行。</p></blockquote><h4 id="GROUP-BY短语"><a href="#GROUP-BY短语" class="headerlink" title="GROUP BY短语"></a>GROUP BY短语</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>GROUP BY子句将查询结果按某一列或多列的值分组，值相等的为一组。</p><p>分散后聚集函数将作用于每一个组，即每一组都有一个函数值。</p><p>Note:</p><p>按指定的一列或者多列分组, 值相等的为一组, HAVING子句作用于各个组之上</p><ul><li>如果未对查询结果分组, 集函数作用于整个查询结果</li><li>对查询结果分组后, 集函数分别作用于各个组</li><li>使用GROUP BY子句后, SELECT子句的列名表中只能出现分组属性和集函数, 不能出现在group by中没有出现的属性</li></ul><p>例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*查询各个课程号和相应的选课人数*/</span><br><span class="hljs-keyword">select</span> cno, <span class="hljs-built_in">count</span>(sno)<br><span class="hljs-keyword">from</span> sc<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> cno;<br><br><span class="hljs-comment">/*查询有3门以上课程是90分以上的学生学号及其(90分以上的)课程数。*/</span><br><span class="hljs-keyword">select</span> sno, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> sc<br><span class="hljs-keyword">where</span> grade <span class="hljs-operator">&gt;=</span> <span class="hljs-number">90</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sno<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="3-2-连接查询"><a href="#3-2-连接查询" class="headerlink" title="3-2 | 连接查询"></a>3-2 | 连接查询</h3><h3 id="3-3-嵌套查询"><a href="#3-3-嵌套查询" class="headerlink" title="3-3 | 嵌套查询"></a>3-3 | 嵌套查询</h3><p>分类:</p><ul><li><p><strong>相关子查询</strong> : 子查询执行依赖于父查询条件</p></li><li><p><strong>不相关子查询</strong> : 子查询执行不依赖于父查询条件</p></li></ul><h4 id="带有IN谓词的子查询"><a href="#带有IN谓词的子查询" class="headerlink" title="带有IN谓词的子查询"></a>带有IN谓词的子查询</h4><h4 id="带有比较运算的子查询"><a href="#带有比较运算的子查询" class="headerlink" title="带有比较运算的子查询"></a>带有比较运算的子查询</h4><p>带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是单个值时，可以用&gt;、&lt;、=、&gt;=、&lt;=、!=或&lt;&gt;等比较运算符。</p><h4 id="带有ANY（SOME）或ALL谓词的子查询"><a href="#带有ANY（SOME）或ALL谓词的子查询" class="headerlink" title="带有ANY（SOME）或ALL谓词的子查询"></a>带有ANY（SOME）或ALL谓词的子查询</h4><p>子查询返回单值时可以用比较运算符，但返回多值时要用ANY或ALL谓词修饰。而使用ANY或ALL谓词时必须同时使用比较运算符。</p><p><a href="https://youpai.roccoshi.top/img/20210106174630.png"><img src="https://youpai.roccoshi.top/img/20210106174630.png" alt="img"></a></p><p>例子: (为不相关子查询)</p><p><a href="https://youpai.roccoshi.top/img/20210106174631.png"><img src="https://youpai.roccoshi.top/img/20210106174631.png" alt="image-20201226133604299"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174631.png">image-20201226133604299</a></p><p>使用any/all谓词与集函数具有等价关系, 而用集函数查询通常比any/all查询效率高因为前者可以减少比较次数</p><p><a href="https://youpai.roccoshi.top/img/20210106174632.png"><img src="https://youpai.roccoshi.top/img/20210106174632.png" alt="image-20201226133751280"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174632.png">image-20201226133751280</a></p><h4 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h4><p>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false， 故子查询通常只用select *</p><p><a href="https://youpai.roccoshi.top/img/20210106174633.png"><img src="https://youpai.roccoshi.top/img/20210106174633.png" alt="image-20201226133932439"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174633.png">image-20201226133932439</a></p><p>使用<strong>EXISTS子查询的效率要优于使用连接查询和IN查询</strong></p><p>EXISTS通常引入的是相关子查询, 而IN更多的是不相关子查询</p><h3 id="3-4-集合查询"><a href="#3-4-集合查询" class="headerlink" title="3-4 | 集合查询"></a>3-4 | 集合查询</h3><p>集合操作命令</p><table><thead><tr><th>命令</th><th></th></tr></thead><tbody><tr><td>UNION</td><td>并</td></tr><tr><td>INTERSECT</td><td>交</td></tr><tr><td>MINUS</td><td>差</td></tr></tbody></table><p><a href="https://youpai.roccoshi.top/img/20210106174634.png"><img src="https://youpai.roccoshi.top/img/20210106174634.png" alt="image-20201226140459748"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174634.png">image-20201226140459748</a></p><h2 id="4-数据更新"><a href="#4-数据更新" class="headerlink" title="4 | 数据更新"></a>4 | 数据更新</h2><h3 id="4-1-插入数据"><a href="#4-1-插入数据" class="headerlink" title="4-1 | 插入数据"></a>4-1 | 插入数据</h3><h4 id="插入单个结果"><a href="#插入单个结果" class="headerlink" title="插入单个结果"></a>插入单个结果</h4><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...)]<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-operator">&lt;</span>常量<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>常量<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...)<br></code></pre></td></tr></table></figure><p>如果不指定属性列, 则values必须以完整的元组插入, 且属性与表中属性顺序一致</p><p>举例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> sc(sno, cno)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;95001&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="插入子查询结果"><a href="#插入子查询结果" class="headerlink" title="插入子查询结果"></a>插入子查询结果</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> [(<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...)]<br>子查询;<br></code></pre></td></tr></table></figure><p>举例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> Deptage(Sdept, Avgage)<br><span class="hljs-keyword">SELECT</span> Sdept,<span class="hljs-built_in">AVG</span>(Sage)  <span class="hljs-comment">-- 属性个数要匹配</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sdept;<br></code></pre></td></tr></table></figure><h4 id="注意完整性约束"><a href="#注意完整性约束" class="headerlink" title="注意完整性约束"></a>注意完整性约束</h4><p><a href="https://youpai.roccoshi.top/img/20210106174635.png"><img src="https://youpai.roccoshi.top/img/20210106174635.png" alt="image-20201226143151436"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174635.png">image-20201226143151436</a></p><h3 id="4-2-修改数据"><a href="#4-2-修改数据" class="headerlink" title="4-2 | 修改数据"></a>4-2 | 修改数据</h3><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">SET</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span>表达式<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span>表达式<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span>]<br></code></pre></td></tr></table></figure><p>举例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> student<br><span class="hljs-keyword">set</span> sage <span class="hljs-operator">=</span> <span class="hljs-number">22</span><br><span class="hljs-keyword">where</span> sno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95001&#x27;</span><br><span class="hljs-keyword">Copy</span><br><span class="hljs-comment">-- 将所有学生年龄增加一岁</span><br><span class="hljs-keyword">update</span> student<br><span class="hljs-keyword">set</span> sage <span class="hljs-operator">=</span> sage <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="4-3-删除数据"><a href="#4-3-删除数据" class="headerlink" title="4-3 | 删除数据"></a>4-3 | 删除数据</h3><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><p>删除表中满足where指定条件的元组</p><p>例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span><br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> sno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95001&#x27;</span>;<br><span class="hljs-keyword">Copy</span><br><span class="hljs-comment">-- 删除所有学生的选课记录</span><br><span class="hljs-keyword">delete</span><br><span class="hljs-keyword">from</span> sc;<br><span class="hljs-keyword">Copy</span><br><span class="hljs-comment">-- 删除CS系所有学生的选课记录</span><br><span class="hljs-keyword">delete</span> <br><span class="hljs-keyword">from</span> sc<br><span class="hljs-keyword">where</span> sno <span class="hljs-keyword">in</span> (<br><span class="hljs-keyword">select</span> sno<br>    <span class="hljs-keyword">from</span> student<br>    <span class="hljs-keyword">where</span> student.sdept <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CS&#x27;</span><br>);<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>删除时的参照完整性:</p><ul><li>不允许被删除</li><li>级联删除 ( 通过CASCADE参数指定 )</li></ul><h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5 | 视图"></a>5 | 视图</h2><p>视图的特点：</p><p>1、虚表，是从一个或几个基本表（或视图）导出的表</p><p>2、只存放视图的定义，不存放视图对应的数据</p><p>3、基本表中的数据发生变化，从视图中查询出的数据也随之改变</p><p>数据库系统的<strong>三级模式</strong>: 外模式, 模式, 内模式</p><p>数据库系统的<strong>两级映像</strong>: 外模式-模式映像 模式-内模式映像</p><ul><li>外模式-模式映像用途: <strong>保证数据的逻辑独立性</strong></li><li>模式-内模式映像用途: <strong>保证数据的物理独立性</strong></li></ul><p>视图对应的就是三级模式/两级映像体系结构中的外模式和外模式/模式映像</p><h3 id="5-1-定义视图"><a href="#5-1-定义视图" class="headerlink" title="5-1 | 定义视图"></a>5-1 | 定义视图</h3><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>]...)]<br><span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>子查询<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure><p><a href="https://youpai.roccoshi.top/img/20210106174636.png"><img src="https://youpai.roccoshi.top/img/20210106174636.png" alt="image-20210102151117045"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174636.png">image-20210102151117045</a></p><p>DBMS执行create view语句时只是把视图的定义存入数据字典, 并不执行其中的select语句, 在对视图查询时, 按视图的定义从基本表中将数据查出</p><p>例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> IS_STUDENT<br><span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> sno, sname, sage<br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> sdept <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;IS&#x27;</span>;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>若一个视图是从单个基本表导出的, 并且只去掉了基本表的某些行和某些列但保留了码, 则这类视图称为<strong>行列子集视图</strong>, 上例所建立的视图就是行列子集视图</p><h3 id="5-2-查询视图"><a href="#5-2-查询视图" class="headerlink" title="5-2 | 查询视图"></a>5-2 | 查询视图</h3><p>视图消解：从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转化过程称为视图消解。</p><h3 id="5-3-更新视图"><a href="#5-3-更新视图" class="headerlink" title="5-3 | 更新视图"></a>5-3 | 更新视图</h3><h3 id="5-4-视图的作用"><a href="#5-4-视图的作用" class="headerlink" title="5-4 | 视图的作用"></a>5-4 | 视图的作用</h3><p>1、视图能够简化用户的操作</p><p>2、视图使用户能以多种角度看待同一数据</p><p>3、视图对重构数据库提供了一定程度的逻辑独立性</p><p>4、视图能够对机密数据提供安全防护</p><p>5、适当利用视图可以更清晰地表达查询</p><h1 id="4-数据库安全-赋权"><a href="#4-数据库安全-赋权" class="headerlink" title="4. 数据库安全-赋权"></a>4. 数据库安全-赋权</h1><blockquote><p>数据库的安全性控制通过授权机制来实现, 即通过赋予用户对数据库的使用权限来保证数据的安全</p></blockquote><h2 id="1-授权GRANT语句"><a href="#1-授权GRANT语句" class="headerlink" title="1 | 授权GRANT语句"></a>1 | 授权<code>GRANT</code>语句</h2><ul><li>将数据库中的某些对象的某些操作权限赋予某些用户</li></ul><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Grant</span> <span class="hljs-operator">&lt;</span>权限s<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ON</span><span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">TO</span><span class="hljs-operator">&lt;</span>用户s<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><ul><li>DBA拥有数据库操作的所有权限并可将权限赋予其他用户</li><li>建立数据库对象的用户称为OWNER, 他拥有对该对象的所有操作权限</li><li>接收权限的用户可以是一个或者多个具体用户, 也可以是全体用户PUBLIC</li><li><code>WITH GRANT OPTION</code>子句: 获得某种权限的用户还可以把这种权限再授予别的用户, 没有指定with grant option时, 获得某种权限的用户只能使用该权限, 不能传播该权限</li></ul><h3 id="所有权限一览表"><a href="#所有权限一览表" class="headerlink" title="所有权限一览表"></a>所有权限一览表</h3><p><a href="https://youpai.roccoshi.top/img/20201227101704.png"><img src="https://youpai.roccoshi.top/img/20201227101704.png" alt="image-20201227101703896"></a></p><p><a href="https://youpai.roccoshi.top/img/20201227101704.png">image-20201227101703896</a></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span><br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student<br><span class="hljs-keyword">to</span> user1;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>把对sc表的全部权限授予全部用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> priviliges<br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc<br><span class="hljs-keyword">to</span> public;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>把查询student表和修改学生学号的权限授予给用户3和用户4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">update</span>(sno), <span class="hljs-keyword">select</span><br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student<br><span class="hljs-keyword">to</span> user3, user4;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>把对表sc的insert权限授予给user5用户, 并允许他再将此权限授予其他用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">insert</span><br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc<br><span class="hljs-keyword">to</span> user5<br><span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> option;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>把在数据库S_C中的建表权限授予用户8</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> createtab<br><span class="hljs-keyword">on</span> database S_C<br><span class="hljs-keyword">to</span> user8;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h2 id="2-收回权限REVOKE语句"><a href="#2-收回权限REVOKE语句" class="headerlink" title="2 | 收回权限REVOKE语句"></a>2 | 收回权限<code>REVOKE</code>语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限s<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>用户s<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">update</span>(sno)<br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student<br><span class="hljs-keyword">from</span> user4;<br><span class="hljs-keyword">Copy</span><br><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">select</span><br><span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc<br><span class="hljs-keyword">from</span> public;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><ul><li>收回权限时, 将收回自己所级联授予出的权限</li><li>如果存在多重授予, (从不同用户处得到的相同权限, 则仍然具有该权限), 只收回自己级联授予的权限</li></ul><h2 id="3-视图机制"><a href="#3-视图机制" class="headerlink" title="3 | 视图机制"></a>3 | 视图机制</h2><p><a href="https://youpai.roccoshi.top/img/20201227102725.png"><img src="https://youpai.roccoshi.top/img/20201227102725.png" alt="image-20201227102725294"></a></p><p><a href="https://youpai.roccoshi.top/img/20201227102725.png">image-20201227102725294</a></p><h1 id="5-存储过程和触发器"><a href="#5-存储过程和触发器" class="headerlink" title="5. 存储过程和触发器"></a>5. 存储过程和触发器</h1><h2 id="1-存储过程"><a href="#1-存储过程" class="headerlink" title="1 | 存储过程"></a>1 | 存储过程</h2><p>创建存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span><br></code></pre></td></tr></table></figure><p>执行存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">PROCEDURE</span><br></code></pre></td></tr></table></figure><p>修改存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">PROCEDURE</span><br></code></pre></td></tr></table></figure><p>删除存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span><br></code></pre></td></tr></table></figure><h2 id="2-触发器"><a href="#2-触发器" class="headerlink" title="2 | 触发器"></a>2 | 触发器</h2><p>功能: 强化约束, 跟踪变化, 级联运行, 存储过程的调用</p><p>分类: 前触发器(<code>INSTEAD OF</code>), 后触发器 (<code>AFTER</code>)</p><p>创建:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <br><span class="hljs-keyword">ON</span><br><span class="hljs-keyword">FOR</span><br><span class="hljs-keyword">AS</span><br><br><span class="hljs-comment">-- 例子</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> reminder<br><span class="hljs-keyword">on</span> titles<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">insert</span>, <span class="hljs-keyword">update</span><br><span class="hljs-keyword">as</span> sql_statements<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>在触发器的执行过程中，系统会自动建立和管理两个逻辑表：插入表(inserted)和删除表(deleted)。这两个表与触发器所对应的基本表有着完全相同的结构，但为只读表，驻留于内存之中，直到触发器执行完毕，系统会自动删除。这两个表是事务回滚的重要依据。</p><h1 id="6-数据库设计"><a href="#6-数据库设计" class="headerlink" title="6. 数据库设计"></a>6. 数据库设计</h1><h2 id="1-数据库设计的流程"><a href="#1-数据库设计的流程" class="headerlink" title="1 | 数据库设计的流程"></a>1 | 数据库设计的流程</h2><table><thead><tr><th>1-需求分析</th><th>2-概念结构设计</th><th>3-逻辑结构设计</th><th>4-物理结构设计</th></tr></thead><tbody><tr><td></td><td>ER图</td><td>ER图-&gt;关系模型</td><td></td></tr></tbody></table><h2 id="2-ER图"><a href="#2-ER图" class="headerlink" title="2 | ER图"></a>2 | ER图</h2><p>三种表示</p><table><thead><tr><th></th><th>表示方式</th></tr></thead><tbody><tr><td>实体</td><td>矩形</td></tr><tr><td>属性</td><td>圆形</td></tr><tr><td>联系</td><td>菱形</td></tr></tbody></table><p>三种不同的联系</p><ul><li>一对一联系</li><li>一对多联系</li><li>多对多联系</li></ul><h2 id="3-ER图向关系模型的转换"><a href="#3-ER图向关系模型的转换" class="headerlink" title="3 | ER图向关系模型的转换"></a>3 | ER图向关系模型的转换</h2><table><thead><tr><th>联系</th><th>转换</th></tr></thead><tbody><tr><td>1 : 1</td><td>两实体<strong>任意一端添加另一端的主键</strong></td></tr><tr><td>1 : N</td><td>在<strong>N端添加另一端的主键</strong></td></tr><tr><td>N : M</td><td>将<strong>联系转化为实体</strong>, 并在实体中加入联系两端实体的主键</td></tr><tr><td>1 : 1 : N - N : M : P</td><td>同 1 : N - N : M (在N端添加另外两端主键 - 联系转化为实体添加三端实体主键)</td></tr></tbody></table><h1 id="7-关系数据理论"><a href="#7-关系数据理论" class="headerlink" title="7. 关系数据理论"></a>7. 关系数据理论</h1><p><strong>关系模式的简记</strong>: <code>R&lt;U, F&gt;</code></p><p>其中U表示属性集, F表示数据依赖</p><h2 id="1-关系数据理论"><a href="#1-关系数据理论" class="headerlink" title="1 | 关系数据理论"></a>1 | 关系数据理论</h2><p>不合适的数据依赖造成以下等问题</p><ul><li>数据冗余</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ul><h2 id="2-规范化"><a href="#2-规范化" class="headerlink" title="2 | 规范化"></a>2 | 规范化</h2><h3 id="2-1-函数依赖"><a href="#2-1-函数依赖" class="headerlink" title="2-1 | 函数依赖"></a>2-1 | 函数依赖</h3><p>函数依赖（Functional Dependencies）简写为FD</p><ul><li><p><strong>平凡函数依赖</strong>： (X→Y,Y⊆X) 平凡函数依赖没什么用, 不研究</p><p>例如(sno, cno)→sno</p></li><li><p><strong>非平凡函数依赖</strong>：(X→Y,Y⊈X) 如果不特别声明, 我们总是讨论非平凡函数依赖</p><p>例如(sno, cno)→grade</p><blockquote><p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反应新的语义，因此若不特别声明，我们总是讨论非平凡函数依赖。</p></blockquote></li><li><p><strong>完全函数依赖</strong>：在R(U)中，如果X→Y，并且对于X的任何一个真子集X‘，都有X‘/→Y</p></li><li><p><strong>部分函数依赖</strong>：若X→Y，但Y不完全函数依赖于X</p></li><li><p><strong>传递函数依赖</strong>：在R(U)中，X→Y，Y→Z，且Y/→X，则Z传递依赖于X, 如果Y→X则为直接函数依赖</p></li></ul><h3 id="2-2-码"><a href="#2-2-码" class="headerlink" title="2-2 | 码"></a>2-2 | 码</h3><blockquote><p>码是关系模式中的一个重要概念。在第二章关系数据库中已经给出了有关码的若干定义，这里用函数依赖的概念来定义码。</p></blockquote><p><strong>候选码</strong>：设K为R&lt;U,F&gt;中的属性或属性组合，若U完全函数依赖于K，则K为R的候选码。</p><p><strong>超码</strong>：如果U部分函数依赖于K，则K为超码</p><blockquote><p>候选码是最小的超码，即K的任何一个真子集都不是候选码</p><p>候选码是 一类特殊的超码，即候选码的超集一定是超码，候选码的任何真子集一定不是超码</p></blockquote><p><strong>主码</strong>：若关系模式R有多个候选码，则选定其中一个作为主码</p><p><strong>主属性</strong>：包含在任何一个候选码中的属性称为主属性</p><p><strong>非主属性</strong>：不包含在任何一个候选码中的属性称为非主属性或非码属性</p><p><strong>全码</strong>：整个属性组是码，称为全码</p><blockquote><p>例：关系模式R(P,W,A)中，属性P表示演奏者，W表示作品，A表示听众。假设一个演奏者可以演奏多个作品，某一个作品可以被多个演奏者演奏，听众也可以欣赏不同演奏者的不同作品，这个关系模式的码为(P,W,A)，即all-key。</p></blockquote><p><strong>外码</strong>：关系模式R&lt;U,F&gt;，U中属性或者属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码也称外码。</p><blockquote><p>主码与外码一起提供了表示关系间联系的手段</p></blockquote><h3 id="2-3-范式"><a href="#2-3-范式" class="headerlink" title="2-3 | 范式"></a>2-3 | 范式</h3><ul><li>范式：范式 是符合某一级别的关系模式的集合</li><li>关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。</li><li><strong>规范化</strong>：一个低一级范式的关系模式通过模式分解可以转换成为若干个高一级范式的关系模式的集合，这个过程就叫规范化。</li></ul><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p><strong>定义</strong>：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。</p><p>所有属性必须是原子的, 不允许表中套表</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p><strong>定义</strong>：若 R∈1NF，且每一个非主属性完全依赖于任何一个候选码，则R∈2NF。</p><p>满足1NF且不存在非主属性对候选码的部分函数依赖</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>满足2NF且不存在非主属性对候选码的传递函数依赖和部分函数依赖</p><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>修正的第三范式</p><p>没有任何属性对码的部分函数依赖和传递函数依赖</p><p>在关系模式R&lt;U,F&gt;中每一个决定因素都包含码，则R&lt;U,F&gt;∈BCNF</p><h2 id="3-数据库依赖的公理系统"><a href="#3-数据库依赖的公理系统" class="headerlink" title="3 | 数据库依赖的公理系统"></a>3 | 数据库依赖的公理系统</h2><h3 id="六条推理规则"><a href="#六条推理规则" class="headerlink" title="六条推理规则"></a>六条推理规则</h3><ul><li>自反律</li><li>增广律</li><li>传递律</li><li>合并规则</li><li>分解规则</li><li>伪传递规则</li></ul><p><a href="https://youpai.roccoshi.top/img/20210102192831.png"><img src="https://youpai.roccoshi.top/img/20210102192831.png" alt="img"></a></p><h3 id="函数依赖集的闭包"><a href="#函数依赖集的闭包" class="headerlink" title="函数依赖集的闭包"></a>函数依赖集的闭包</h3><p>在关系模式R中为F所逻辑蕴含的函数依赖的全体叫做F的闭包, 记为F+</p><p>注: F+一般超级多, 求F+属于NP完全问题</p><h3 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h3><p>设F为属性集U上的一组函数依赖, X⊆U, X关于函数依赖集F的闭包为XF+</p><p>能由根据公理导出XF+={A|X→A能由F根据Armstrong公理导出}</p><p>注: 即求X可以导出的所有属性集合</p><p><a href="https://youpai.roccoshi.top/img/20210102192832.png"><img src="https://youpai.roccoshi.top/img/20210102192832.png" alt="img"></a></p><h3 id="最小函数依赖集"><a href="#最小函数依赖集" class="headerlink" title="最小函数依赖集"></a>最小函数依赖集</h3><p>即用最少的函数依赖表示全部属性之间的依赖关系, 记为Fmin</p><p>最小函数依赖集的定义:</p><p><a href="https://youpai.roccoshi.top/img/20210102192833.png"><img src="https://youpai.roccoshi.top/img/20210102192833.png" alt="img"></a></p><h3 id="考点-最小函数依赖集的求解算法"><a href="#考点-最小函数依赖集的求解算法" class="headerlink" title="考点: 最小函数依赖集的求解算法"></a>考点: 最小函数依赖集的求解算法</h3><p>第一步: <strong>对每个函数依赖作右部属性分离</strong></p><p>第二步: <strong>去掉左部的冗余属性</strong></p><p>第三步: <strong>去除多余的函数依赖</strong></p><p>注意: 最小函数依赖集不是唯一的</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><a href="https://youpai.roccoshi.top/img/20210102192834.png"><img src="https://youpai.roccoshi.top/img/20210102192834.png" alt="img"></a></p><p>在第三步的时候可以采用「除本求包」的方法, 即除去正在考察的这个函数依赖, 看左部属性的闭包是否包含正在考察的函数依赖的右部属性, 如果包含则正在考察的这个函数依赖为多余的函数依赖, 例如上面的A-&gt;D, 除去A-&gt;D的这个函数依赖求A的闭包为{A, B, C, D, E}包含D, 则A-&gt;D为多余, 应该去除。</p><p><strong>正则覆盖</strong>: 将求出的最小函数依赖集左部属性相同的函数依赖合并(例如A-&gt;B A-&gt;C合并为A-&gt;BC)</p><h3 id="考点-候选码求解算法"><a href="#考点-候选码求解算法" class="headerlink" title="考点: 候选码求解算法"></a>考点: 候选码求解算法</h3><p>第一步: <strong>根据函数依赖集F将R的所有属性分为L类, R类, LR类和N类属性[<a href="https://blog.roccoshi.top/2021/%E8%A5%BF%E7%94%B5%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E5%A4%8D%E4%B9%A0/#fn:1">1]</a>, 令X为L, N类的集合, Y为LR类的集合</strong></p><p>第二步: <strong>如果XF+=U, 则X为R的唯一候选码, 结束, 否则到第三步</strong></p><p>第三步: <strong>逐一取Y中的单一属性A, 若(XA)F+=U, 则XA为候选码, 令Y = Y - {A}, 到第四步</strong></p><p>第四步: <strong>依次取Y中的两个, 三个…属性与X组成属性组XZ, 若XZ不包含已求得的候选码, 则求其关于F的闭包(XZ)F+</strong></p><p><strong>若(XZ)F+=U, 则XZ为候选码, 重复第四步直到所有Y中的属性取完为止, 算法结束</strong></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><a href="https://youpai.roccoshi.top/img/20210102192835.png"><img src="https://youpai.roccoshi.top/img/20210102192835.png" alt="img"></a></p><h2 id="4-模式分解"><a href="#4-模式分解" class="headerlink" title="4 | 模式分解"></a>4 | 模式分解</h2><p><a href="https://youpai.roccoshi.top/img/20210102192836.png"><img src="https://youpai.roccoshi.top/img/20210102192836.png" alt="img"></a></p><p>分解应该考虑的问题</p><ul><li>分解不能丢失信息</li><li>分解应该保持函数依赖</li><li>分解需要保持无损连接 (可以通过自然连接还原)</li></ul><h3 id="考点-模式的无损连接性判定算法"><a href="#考点-模式的无损连接性判定算法" class="headerlink" title="考点: 模式的无损连接性判定算法"></a>考点: 模式的无损连接性判定算法</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>R的一个分解为R1, R2</p><p><strong>若U1∩U2→U1−U2∈F+或者U1∩U2→U2−U1∈F+则分解R1, R2保持无损连接</strong> (<strong>充分必要条件</strong>, 用于一分为二模式的无损连接判断)</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>构造表</p><p><a href="https://youpai.roccoshi.top/img/20210102192837.png"><img src="https://youpai.roccoshi.top/img/20210102192837.png" alt="img"></a></p><h3 id="将模式分解为BCNF并保持无损连接"><a href="#将模式分解为BCNF并保持无损连接" class="headerlink" title="将模式分解为BCNF并保持无损连接"></a>将模式分解为BCNF并保持无损连接</h3><p><a href="https://youpai.roccoshi.top/img/20210102192838.png"><img src="https://youpai.roccoshi.top/img/20210102192838.png" alt="img"></a></p><h1 id="8-嵌入式SQL"><a href="#8-嵌入式SQL" class="headerlink" title="8. 嵌入式SQL"></a>8. 嵌入式SQL</h1><h2 id="1-主语言-SQLCA-主变量-游标"><a href="#1-主语言-SQLCA-主变量-游标" class="headerlink" title="1 | 主语言 SQLCA 主变量 游标"></a>1 | 主语言 SQLCA 主变量 游标</h2><p>主语言: C++, JAVA</p><p>SQLCA: sql communication area (SQL通信区)</p><p>主变量: sql使用主语言中的变量</p><p>游标: 一段缓冲区, 用于存放sql的执行结果</p><h3 id="数据库和源程序工作单元间的通信"><a href="#数据库和源程序工作单元间的通信" class="headerlink" title="数据库和源程序工作单元间的通信"></a>数据库和源程序工作单元间的通信</h3><ol><li>SQLCA向主语言传递SQL语句的执行信息(执行状态)</li><li>主语言通过主变量向SQL提供参数</li><li>主变量和游标将SQL语句查询数据库的结果交主语言处理</li></ol><h1 id="9-事务"><a href="#9-事务" class="headerlink" title="9. 事务"></a>9. 事务</h1><h2 id="1-事务的ACID特性"><a href="#1-事务的ACID特性" class="headerlink" title="1 | 事务的ACID特性"></a>1 | 事务的ACID特性</h2><ul><li>原子性Atomicity: 事务要么全做, 要么全不做</li><li>一致性Consistency: 事务让数据库从一个一致性状态—&gt;另一个一致性状态</li><li>隔离性Isolation: 事务的执行不能被其他事务干扰</li><li>持续性Durability: 事务提交后对数据库中数据的改变为永久性的</li></ul><h2 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2 | 并发控制"></a>2 | 并发控制</h2><p>几种并发冲突:</p><ol><li><strong>丢失修改</strong> (写-写冲突)</li><li><strong>不可重复读</strong> (读-写冲突)</li><li><strong>读“脏”数据</strong> (写-读冲突)</li></ol><h2 id="3-封锁机制"><a href="#3-封锁机制" class="headerlink" title="3 | 封锁机制"></a>3 | 封锁机制</h2><p><strong>X锁</strong>: 排他锁, 持有X锁的人能读写数据库</p><p><strong>S锁:</strong> 共享锁, 持有S锁的人能读不能写数据库</p><p>仅能有一个事务拥有X锁, 可以有多个事务同时拥有S锁</p><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p>修改数据之前先加X锁, 事务结束后释放</p><p>解决问题: <strong>丢失修改</strong></p><h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><p>在一级封锁协议基础上增加在读取数据前必须对数据加S锁, 读完后即可释放</p><p>解决问题: <strong>丢失修改和读“脏”数据</strong></p><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p>在一级封锁协议的基础上增加在读取数据前必须对数据加S锁, 在事务结束后才可释放</p><p>解决问题: <strong>丢失修改, 不可重复读, 读“脏”数据</strong></p><h2 id="4-并发调度的可串行性"><a href="#4-并发调度的可串行性" class="headerlink" title="4 | 并发调度的可串行性"></a>4 | 并发调度的可串行性</h2><p><strong>可串行化调度的定义:</strong></p><blockquote><p>定义: 多个并发事务的执行是正确的, 当且仅当其结果与按一定次序串行地执行这些事务时的结果相同</p></blockquote><p><strong>可串行性</strong>是并发事务正确调度的准则, 一个给定的并发调度当且仅当它是可串行化的才认为是正确的调度</p><p><strong>冲突可串行化调度:</strong></p><p>将并发调度保证冲突操作次序不变的情况下交换不冲突操作的次序得到另一个串行调度, 则称这个并发调度为冲突可串行化的调度, 如果一个调度是冲突可串行化的, 那么则一定是可串行化的调度。</p><p>注意: 冲突可串行化调度是可串行化调度的充分非必要条件</p><h2 id="5-两段锁协议"><a href="#5-两段锁协议" class="headerlink" title="5 | 两段锁协议"></a>5 | 两段锁协议</h2><p>两段锁协议:</p><blockquote><p>先统一加锁, 事务结束时统一释放锁</p></blockquote><ul><li>遵守两段锁协议也会发生死锁</li><li>遵守两段锁协议是可串行化调度的充分条件</li></ul><p>原博客转载于：<a href="https://blog.roccoshi.top/">https://blog.roccoshi.top/</a> + 本人增删修改</p>]]></content>
    
    
    <categories>
      
      <category>解忧杂货</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 240.搜索二维矩阵</title>
    <link href="/2022/04/06/LC%20240.%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/04/06/LC%20240.%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-240-搜索二维矩阵"><a href="#LC-240-搜索二维矩阵" class="headerlink" title="LC 240.搜索二维矩阵"></a>LC 240.搜索二维矩阵</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>C++ lower_bound()函数</p><blockquote><p>lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。它的底层实现采用的都是二分查找的方式。</p><p>注意：</p><p>1.因为函数底层实现采用的是二维数组，所以该函数仅适用于已排好序的序列。</p><p>2.迭代器遍历时，函数返回的是迭代器</p><p>详解见博客：<a href="http://m.biancheng.net/view/7521.html">http://m.biancheng.net/view/7521.html</a></p></blockquote><p>用for(const auto row : matrix)遍历时会超时的原因</p><blockquote><p>1.auto即for(auto x:range) 会拷贝一份range元素，不会改变range中的元素；<br>2.只读取range中的元素,使用const auto&amp;,如：for(const auto&amp;x:range),它不会进行拷贝，也不会修改range,效率会比用auto快一点。</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h5 id="方法1：二分查找"><a href="#方法1：二分查找" class="headerlink" title="方法1：二分查找"></a>方法1：二分查找</h5><blockquote><p>由于矩阵 matrix 中每一行的元素都是升序排列的，因此我们可以对每一行都使用一次二分查找，判断 target 是否在该行中，从而判断 target 是否出现。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; row : matrix)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(row.<span class="hljs-built_in">begin</span>(),row.<span class="hljs-built_in">end</span>(),target);<br>            <span class="hljs-keyword">if</span>(it != row.<span class="hljs-built_in">end</span>() &amp;&amp; *it == target)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用库函数</title>
    <link href="/2022/04/05/C++%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <url>/2022/04/05/C++%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="builtin-popcount"><a href="#builtin-popcount" class="headerlink" title="__builtin_popcount"></a>__builtin_popcount</h3><blockquote><p>__builtin_popcount()</p><p>该函数是C++自带的库函数，内部实现是用查表实现的。<br><strong>作用</strong>：统计数字在二进制下“1”的个数。</p><p>Note：是__builtin_popcount()，千万别写成 _builtin_popcount()</p></blockquote><p>待续……</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LC 设计哈希集合+设计哈希映射</title>
    <link href="/2022/03/31/LC%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88+%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/"/>
    <url>/2022/03/31/LC%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88+%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-705-设计哈希集合"><a href="#LC-705-设计哈希集合" class="headerlink" title="LC 705.设计哈希集合"></a>LC 705.设计哈希集合</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：<br>1.哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。<br>2.冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现冲突时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：<br>  链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。<br>  开放地址法：当发现哈希值 hh 处产生冲突时，根据某种策略，从 hh 出发找到下一个不冲突的位  置。例如，一种最简单的策略是，不断地检查 h+1,h+2,h+3,… 这些整数对应的位置。<br>  再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。<br>3.扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。  </p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 实现 MyHashSet 类： </p><p>void add(key) 向哈希集合中插入值 key 。 </p><p>bool contains(key) 返回哈希集合中是否存在这个值 key 。 </p><p>void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：链地址法</strong> </p><p>设哈希表的大小为 base，则可以设计一个简单的哈希函数：hash(x) = x mod base。 开辟一个大小为 base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。 由于使用整数除法作为哈希函数，为了尽可能避免冲突，应当将 base 取为一个质数。取 base=769。   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashSet</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; data;  <span class="hljs-comment">//定义一个数组base,数组的每一个位置是一个链表</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">769</span>;  <span class="hljs-comment">//定义哈希表的大小</span><br>    <span class="hljs-comment">//用链地址法设计一个哈希表</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> key % base;<br>    &#125;<br><br>    <span class="hljs-built_in">MyHashSet</span>():<span class="hljs-built_in">data</span>(base) &#123;&#125;<br><br>    <span class="hljs-comment">//插入</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);  <span class="hljs-comment">//找出key在哈希表中对应的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)  <span class="hljs-comment">//迭代法遍历key在哈希表中对应位置的链表</span><br>        &#123;<br>            <span class="hljs-comment">//如果插入元素存在 则返回空</span><br>            <span class="hljs-keyword">if</span>(*it == key)<br>            &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果元素不存在则插入元素</span><br>        data[h].<span class="hljs-built_in">push_back</span>(key);<br>    &#125;<br><br>    <span class="hljs-comment">//删除</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(*it == key)<br>            &#123;<br>                data[h].<span class="hljs-built_in">erase</span>(it);<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                    注意：data\[h\].erase(it) 这里的it不可写成\*it或者key</span><br><span class="hljs-comment">                    因为删除的是key在链表上的地址而不是值</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断key是否存在</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(*it == key)  <span class="hljs-comment">/* 注意：*it */</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><h2 id="LC-706-设计哈希映射"><a href="#LC-706-设计哈希映射" class="headerlink" title="LC 706.设计哈希映射"></a>LC 706.设计哈希映射</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p><em><strong>设计哈希映射</strong></em> 与 <em><strong>设计哈希集合</strong></em> 解法接近，唯一的区别在于哈希映射存储的不是 key 本身，而是键值对(key,value)。   </p><blockquote><p>哈希表增加键值对的函数：map1.insert(make_pair(n,1))<br>哈希表删除键值对的函数：data[h].erase(it)<br>哈希表使用迭代器遍历时：<br>i-&gt;first：表示键<br>i-&gt;second：表示值  </p></blockquote><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。 实现 MyHashMap 类： </p><p>MyHashMap() 用空映射初始化对象 </p><p>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。 </p><p>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。 </p><p>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashMap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; data;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">769</span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> key % base;<br>    &#125;<br><br>    <span class="hljs-built_in">MyHashMap</span>():<span class="hljs-built_in">data</span>(base) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;first == key)<br>            &#123;<br>                it-&gt;second = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(key,value));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;first == key)<br>            &#123;<br>                <span class="hljs-keyword">return</span> it-&gt;second;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=data[h].<span class="hljs-built_in">begin</span>(); it!=data[h].<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;first == key)<br>            &#123;<br>                data[h].<span class="hljs-built_in">erase</span>(it);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 15.三数之和</title>
    <link href="/2022/03/25/LC%2015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/03/25/LC%2015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-15-三数之和"><a href="#LC-15-三数之和" class="headerlink" title="LC 15.三数之和"></a>LC 15.三数之和</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>本题与LeetCode 1：两数之和类似，是非常经典的面试题，但是做法不尽相同。  </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：排序+双指针</strong> </p><blockquote><p>关键字：不可以包含重复<br>模式识别：利用排序避免重复答案<br>降低复杂度变成twoSum<br>利用双指针找到所有解<br>数组有序，和为定值的两个数一定可以通过头尾指针向中间移动获得。<br>关键去重，每次移动跳过与当前值相同的元素，枚举第三个元素也要跳过重复元素。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">//对数组进行排序方便去重</span><br>        <span class="hljs-comment">//枚举a</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>])  <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//去重，需要和上次遍历的元素不同</span><br>            <span class="hljs-type">int</span> target = <span class="hljs-number">0</span>-nums[i];  <span class="hljs-comment">//定义目标值target，转化为二元组问题target = b+c</span><br>            <span class="hljs-type">int</span> l = i+<span class="hljs-number">1</span>,r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;  <span class="hljs-comment">//定义首尾指针，通过首尾指针移动获取定值target</span><br>            <span class="hljs-keyword">while</span>(l&lt;r)  <span class="hljs-comment">//通过首尾指针获取定值target</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[l]+nums[r] == target)<br>                &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);  <span class="hljs-comment">//将符合的元组加入结果ans中</span><br>                    <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[l] == nums[l+<span class="hljs-number">1</span>])  l++;  <span class="hljs-comment">//去除重复的左指针元素</span><br>                    <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[r] == nums[r<span class="hljs-number">-1</span>])  r--;  <span class="hljs-comment">//去除重复的右指针元素</span><br>                    l++;  <span class="hljs-comment">//左指针向右移</span><br>                    r--;  <span class="hljs-comment">//右指针向左移</span><br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[l]+nums[r] &gt; target)<br>                &#123;<br>                    r--;  <span class="hljs-comment">//结果大于目标值，右指针向左移</span><br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    l++;  <span class="hljs-comment">//结果小于目标值，左指针向右移</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;  <span class="hljs-comment">//返回结果</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1Jq4y1A7u7?spm_id_from=333.337.search-card.all.click">B站视频讲解</a>  </p><h2 id="LC-1-两数之和"><a href="#LC-1-两数之和" class="headerlink" title="LC 1.两数之和"></a>LC 1.两数之和</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个整数数组 nums 和一个整数目标值 target ，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：暴力枚举</strong> </p><p><strong>方法2：哈希表</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map1;  <span class="hljs-comment">//键为nums[i] 值为数组下标i</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> it = map1.<span class="hljs-built_in">find</span>(target-nums[i]);<br>            <span class="hljs-keyword">if</span>(it  != map1.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                <span class="hljs-keyword">return</span> &#123;it-&gt;second,i&#125;;<br>            &#125;<br>            map1[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 136.只出现一次的数字</title>
    <link href="/2022/03/25/LC%20136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/03/25/LC%20136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-136-只出现一次的数字"><a href="#LC-136-只出现一次的数字" class="headerlink" title="LC 136.只出现一次的数字"></a>LC 136.只出现一次的数字</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>这道题 虽然是一道简单题，但是学到了很多东西。意识到大一学的C++其实有很多东西都没有学到，比如哈希表和集合的很多用法都不够了解。  </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：判断排序数组前后元素是否相等</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">2</span> &amp;&amp; nums[<span class="hljs-number">0</span>] !=  nums[<span class="hljs-number">1</span>])  <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">2</span> &amp;&amp; nums[n<span class="hljs-number">-1</span>] != nums[n<span class="hljs-number">-2</span>])  <span class="hljs-keyword">return</span> nums[n<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n<span class="hljs-number">-1</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != nums[i<span class="hljs-number">-1</span>] &amp;&amp; nums[i] != nums[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：集合</strong> </p><blockquote><p>set集合只能使用迭代器遍历，不能使用下标遍历。所以只能返回set1.begin()，而不能返回下标。 auto ans = set1.begin();  //这里只能用auto 而不能用<br>int return *ans;  //返回的必须是指针类型 因为set1.begin()是迭代器类型，所以 ans只能用auto定义，而不能用int类型定义。因此返回的值也必须是 指针类型的。  </p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(set1.<span class="hljs-built_in">count</span>(n))<br>            &#123;<br>                set1.<span class="hljs-built_in">erase</span>(n);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                set1.<span class="hljs-built_in">insert</span>(n);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> ans = set1.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">//这里只能用auto 而不能用int</span><br>        <span class="hljs-keyword">return</span> *ans;  <span class="hljs-comment">//返回的必须是指针类型</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法3：哈希表</strong> </p><blockquote><p>哈希表增加键值对的函数：map1.insert(make_pair(n,1));<br>哈希表使用迭代器遍历时： i-&gt;first：表示键 i-&gt;second：表示值  </p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(map1.<span class="hljs-built_in">find</span>(n) == map1.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(n,<span class="hljs-number">1</span>));  <span class="hljs-comment">//如果字典中不存在该key，则新增一个键值对(n,1)</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                map1[n]++;  <span class="hljs-comment">//如果字典中存在该key，则将值加1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=map1.<span class="hljs-built_in">begin</span>(); i!=map1.<span class="hljs-built_in">end</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i-&gt;second == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> i-&gt;first;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Note：相同类型的哈希表题目：</strong><a href="https://leetcode-cn.com/problems/majority-element/">LeetCode 169：多数元素</a>   </p><p><strong>方法4：位运算</strong> </p><p>这个方法太精妙了！   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>集合</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 653.两数之和IV-输入BST</title>
    <link href="/2022/03/22/LC%20653.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST/"/>
    <url>/2022/03/22/LC%20653.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-653-两数之和IV-输入BST"><a href="#LC-653-两数之和IV-输入BST" class="headerlink" title="LC 653.两数之和IV-输入BST"></a>LC 653.两数之和IV-输入BST</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个二叉搜索树 root 和一个目标结果 k ，如果 BST 中存在两个元素且它们的和等于 给定的目标结果，则返回 true 。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：深度优先搜索+哈希表</strong> </p><p>使用深度优先搜索的方式遍历整棵树，用哈希表记录遍历过的节点的值。 对于一个值为x的节点，我们检查哈希表中是否存在k-x即可。如果存在对应的元素，那么我们就可以在这棵树上找到两个节点的和为k，否则我们将x放入哈希表中。 如果遍历完整棵树都不存在对应的元素，那么该树上不存在两个和为k的节点   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; hashTable;  <span class="hljs-comment">//哈希表要定义在函数外面</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(hashTable.<span class="hljs-built_in">count</span>(k - root-&gt;val))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        hashTable.<span class="hljs-built_in">insert</span>(root-&gt;val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findTarget</span>(root-&gt;left,k)  <span class="hljs-built_in">findTarget</span>(root-&gt;right,k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：广度优先搜索+哈希表</strong> </p><p>使用广度优先搜索的方式遍历整棵树，用哈希表记录遍历过的节点的值。 </p><p>首先创建一个哈希表和一个队列，将根节点加入队列中，然后执行以下步骤： </p><p>1.从队列中取出队头，假设其值为 x </p><p>2.检查哈希表中是否存在 k - x，如果存在，返回 true </p><p>3.否则，将该节点的左右的非空子节点加入队尾 </p><p>4.重复以上步骤，直到队列为空 </p><p>5.如果队列为空，说明树上不存在两个和为 k的节点，返回 false   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; hashTable;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(hashTable.<span class="hljs-built_in">count</span>(k - node-&gt;val))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            hashTable.<span class="hljs-built_in">insert</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node-&gt;right != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><p><strong>方法3：深度优先搜索+中序遍历+双指针</strong>   </p><p><strong>方法4：迭代+中序遍历+双指针</strong>   </p><p><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/liang-shu-zhi-he-iv-shu-ru-bst-by-leetco-b4nl/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 98.验证二叉搜索树</title>
    <link href="/2022/03/20/LC%2098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/03/20/LC%2098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-98-验证二叉搜索树"><a href="#LC-98-验证二叉搜索树" class="headerlink" title="LC 98.验证二叉搜索树"></a>LC 98.验证二叉搜索树</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>有效二叉搜索树定义：<br>1.节点左子树只包含小于当前节点的数<br>2.节点右子树只包含大于当前节点的数<br>3.所有左子树和右子树自身必须也是二叉搜索树  </p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：递归法</strong> </p><p>定义一个函数bool helper(TreeNode*,long long int lower,long long int upper) 如果上界和下界存在，判断当前节点的值是否在界内，如果不在界内，返回false。将当前节点的值作为上界，继续对node-&gt;left进行递归；将当前节点作为下界，继续对node-&gt;right进行递归。   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> lower,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> upper)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//空节点是合理的二叉搜索树</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt;= lower  root-&gt;val &gt;= upper)  <span class="hljs-comment">//节点不为空，判断节点上的值是否在上下界内</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//更改上下界 递归遍历二叉树的左右子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root-&gt;left,lower,root-&gt;val) &amp;&amp; <span class="hljs-built_in">helper</span>(root-&gt;right,root-&gt;val,upper);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root,LONG_MIN,LONG_MAX);  <span class="hljs-comment">//从根节点开始，上下界都为空</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：中序遍历</strong> </p><p>根据二叉搜索树的性质，得知二叉搜索树中序遍历得到的值构成的序列一定是升序的，在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是。</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; stack;  <span class="hljs-comment">//定义栈stack来存储未拜访过的树节点</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> inorder = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)INT_MIN<span class="hljs-number">-1</span>;  <span class="hljs-comment">//inorder用来存储上一个遍历到的树节点的值</span><br>        <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>() || root != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">//不断将root的左子节点加入栈 直到没有剩余的左节点</span><br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                stack.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//将当前子树最左边的节点从stack中取出</span><br>            <span class="hljs-comment">//如果中序遍历得到的节点的值小于等于前一个inorder，说明不是二叉搜索树</span><br>            <span class="hljs-keyword">if</span> (root-&gt;val &lt;= inorder)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            inorder = root-&gt;val;  <span class="hljs-comment">//将inorder设为当前节点的值</span><br>            root = root-&gt;right;  <span class="hljs-comment">//将root设为当前节点的右子节点，继续循环</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 112.二叉树路径总和</title>
    <link href="/2022/03/19/LC%20112.%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2022/03/19/LC%20112.%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-112-二叉树路径总和"><a href="#LC-112-二叉树路径总和" class="headerlink" title="LC 112.二叉树路径总和"></a>LC 112.二叉树路径总和</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>本题核心思想是对树进行一次遍历，在遍历是记录从根节点到当前节点的路径总和，以防止重复计算。 </p><p> </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：广度优先搜索</strong> </p><p>使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。 这样我们可以使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和。   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//首先判断根节点是否存在</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que_node;  <span class="hljs-comment">//定义一个队列 用于存储将要遍历的结点</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; que_val;  <span class="hljs-comment">//定义一个队列 用于记录从根节点到当前节点路径和</span><br>        que_node.<span class="hljs-built_in">push</span>(root);  <span class="hljs-comment">//将根节点加入第一个队列</span><br>        que_val.<span class="hljs-built_in">push</span>(root-&gt;val);  <span class="hljs-comment">//将根节点的值加入第二个队列</span><br>        <span class="hljs-comment">//迭代循环队列 直到队列为空</span><br>        <span class="hljs-keyword">while</span>(!que_node.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* now = que_node.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-type">int</span> temp = que_val.<span class="hljs-built_in">front</span>();<br>            que_node.<span class="hljs-built_in">pop</span>();<br>            que_val.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(now-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; now-&gt;right == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//不存在左右节点 则为叶节点</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(temp == targetSum)  <span class="hljs-comment">//判断路径和与目标值是否相等</span><br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//不相等则迭代继续</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(now-&gt;left != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//存在左子节点</span><br>            &#123;<br>                que_node.<span class="hljs-built_in">push</span>(now-&gt;left);  <span class="hljs-comment">//将左子节点加入第一个队列</span><br>                que_val.<span class="hljs-built_in">push</span>(now-&gt;left-&gt;val + temp);<span class="hljs-comment">//将左子节点值与当前路径和相加加入第二个队列</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(now-&gt;right != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//存在右子节点</span><br>            &#123;<br>                que_node.<span class="hljs-built_in">push</span>(now-&gt;right);  <span class="hljs-comment">//将右子节点加入第一个队列</span><br>                que_val.<span class="hljs-built_in">push</span>(now-&gt;right-val + temp);<span class="hljs-comment">//将右子节点值与当前路径和相加加入第二个队列</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//没有满足条件的 返回false</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：递归</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> sum == root-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) <br>               <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 翻转二叉树+对称二叉树</title>
    <link href="/2022/03/17/LC%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91+%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/03/17/LC%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91+%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-226-翻转二叉树"><a href="#LC-226-翻转二叉树" class="headerlink" title="LC 226.翻转二叉树"></a>LC 226.翻转二叉树</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点root 的左右两颗子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以root 为根节点的整棵子树的翻转。</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode* left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        TreeNode* right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;left = right;<br>        root-&gt;right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><h2 id="LC-101-对称二叉树"><a href="#LC-101-对称二叉树" class="headerlink" title="LC 101.对称二叉树"></a>LC 101.对称二叉树</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。 </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：递归</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMirror</span><span class="hljs-params">(TreeNode* t1,TreeNode* t2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">nullptr</span> &amp;&amp; t2 == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">nullptr</span>  t2 == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t1-&gt;val == t2-&gt;val &amp;&amp; <span class="hljs-built_in">isMirror</span>(t1-&gt;left,t2-&gt;right) &amp;&amp; <span class="hljs-built_in">isMirror</span>(t1-&gt;right,t2-&gt;left);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isMirror</span>(root-&gt;left,root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2：迭代（利用队列）</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMirror</span><span class="hljs-params">(TreeNode* t1,TreeNode* t2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(t1);<br>        q.<span class="hljs-built_in">push</span>(t2);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            t1 = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            t2 = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">nullptr</span> &amp;&amp; t2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>((t1 == <span class="hljs-literal">nullptr</span>  t2 == <span class="hljs-literal">nullptr</span>)  t1-&gt;val != t2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            q.<span class="hljs-built_in">push</span>(t1-&gt;left);<br>            q.<span class="hljs-built_in">push</span>(t2-&gt;right);<br>            q.<span class="hljs-built_in">push</span>(t1-&gt;right);<br>            q.<span class="hljs-built_in">push</span>(t2-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isMirror</span>(root-&gt;left,root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 用栈实现队列+用队列实现栈</title>
    <link href="/2022/03/11/LC%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97+%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2022/03/11/LC%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97+%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-232-用栈实现队列"><a href="#LC-232-用栈实现队列" class="headerlink" title="LC 232.用栈实现队列"></a>LC 232.用栈实现队列</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>栈 队列 模拟  </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>请你仅使用两个栈实现先入先出队列,队列支持一般队列支持的所有操作（push、pop、peek、empty） 实现 MyQueue 类： </p><p>void push(int x) 将元素 x 推到队列的末尾 </p><p>int pop() 从队列的开头移除并返回元素 </p><p>int peek() 返回队列开头的元素 </p><p>boolean empty() 如果队列为空，返回 true ；否则，返回 false  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stIn;  <span class="hljs-comment">//创建一个栈stIn 用于进栈</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stOut; <span class="hljs-comment">//创建一个栈stOut 用于出栈</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stIn.<span class="hljs-built_in">push</span>(x);  <span class="hljs-comment">//将元素压入栈中</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stOut.<span class="hljs-built_in">empty</span>())  <span class="hljs-comment">//如果栈stOut为空 则将栈stIn中所有元素压入栈stOut中</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(!stIn.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                stOut.<span class="hljs-built_in">push</span>(stIn.<span class="hljs-built_in">top</span>());  <span class="hljs-comment">//将栈stIn栈顶元素压入栈stOut中</span><br>                stIn.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//栈顶元素压入栈stOut后将元素删除</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//当栈stOut不为空时 则直接弹出栈stOut栈顶元素</span><br>        <span class="hljs-type">int</span> res = stOut.<span class="hljs-built_in">top</span>();<br>        stOut.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//直接使用已有的pop函数获取栈顶元素</span><br>        stOut.<span class="hljs-built_in">push</span>(res);  <span class="hljs-comment">//因为pop函数弹出了元素res 所以再添加回去</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stIn.<span class="hljs-built_in">empty</span>() &amp;&amp; stOut.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">//当栈stIn和栈stOut都不为空时 队列才不为空</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>  <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/232-yong-zhan-shi-xian-dui-lie-liang-ge-zhan-lai-m/">LeetCode题解+动画演示</a>  </p><h2 id="LC-225-用队列实现栈"><a href="#LC-225-用队列实现栈" class="headerlink" title="LC 225.用队列实现栈"></a>LC 225.用队列实现栈</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>队列 栈 模拟  </p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、 pop 和 empty）。 实现 MyStack 类： </p><p>void push(int x) 将元素 x 压入栈顶。 </p><p>int pop() 移除并返回栈顶元素。 </p><p>int top() 返回栈顶元素。 </p><p>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：两个队列实现栈</strong> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue1;  <span class="hljs-comment">//创建一个队列queue1 用于存储所有入栈元素</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; queue2;  <span class="hljs-comment">//创建一个队列queue2 用于临时存储即将入栈的元素</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">//使用两个队列模拟元素入栈</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        queue2.<span class="hljs-built_in">push</span>(x);  <span class="hljs-comment">//将入栈元素插入临时队列queue2</span><br>        <span class="hljs-keyword">while</span>(!queue1.<span class="hljs-built_in">empty</span>())  <span class="hljs-comment">//将队列queue1中所有元素插入临时队列queue2</span><br>        &#123;<br>            queue2.<span class="hljs-built_in">push</span>(queue1.<span class="hljs-built_in">front</span>());  <span class="hljs-comment">//将队列queue1中头元素插入队列queue2中</span><br>            queue1.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//删除队列queue1头元素</span><br>        &#125;<br>        <span class="hljs-built_in">swap</span>(queue1,queue2);  <span class="hljs-comment">//为了避免打乱元素顺序 交换队列queue1和queue2</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = queue1.<span class="hljs-built_in">front</span>();<br>        queue1.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = queue1.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">//因为queue1包含了栈中所有元素 所以只需要检查queue1是否为空即可</span><br>        <span class="hljs-comment">//queue2作为临时队列 不永久存储栈中的元素</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法二：一个队列实现栈</strong></p><p>入栈操作时，首先获得入栈前的元素个数 n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>        q.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            q.<span class="hljs-built_in">push</span>(q.<span class="hljs-built_in">front</span>());<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> r = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> r = q.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 589.N叉树的前序遍历</title>
    <link href="/2022/03/10/LC%20589.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/03/10/LC%20589.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-589-N叉树的前序遍历"><a href="#LC-589-N叉树的前序遍历" class="headerlink" title="LC 589.N叉树的前序遍历"></a>LC 589.N叉树的前序遍历</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h4><blockquote><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p></blockquote><p> <a href="http://c.biancheng.net/view/6826.html">C++STL中emplace_back()和push_back()的区别</a>  </p><h4 id="C-const-关键字"><a href="#C-const-关键字" class="headerlink" title="C++ const 关键字"></a>C++ const 关键字</h4><blockquote><p>const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。 </p></blockquote><p><a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">菜鸟教程：C++ const 关键字小结</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个 n 叉树的根节点  root ，返回其节点值的前序遍历。 n 叉树在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-type">const</span> Node* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; ch : root-&gt;children) &#123;    <span class="hljs-comment">//auto 类型也是 C++11 新标准中的，用来自动获取变量的类型</span><br>            <span class="hljs-built_in">helper</span>(ch, res);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">helper</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 二叉树的遍历</title>
    <link href="/2022/03/06/LC%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2022/03/06/LC%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-144-二叉树的前序遍历"><a href="#LC-144-二叉树的前序遍历" class="headerlink" title="LC 144.二叉树的前序遍历"></a>LC 144.二叉树的前序遍历</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="参数传递时什么时候需要传入参数的引用-amp"><a href="#参数传递时什么时候需要传入参数的引用-amp" class="headerlink" title="参数传递时什么时候需要传入参数的引用&amp;"></a>参数传递时什么时候需要传入参数的引用&amp;</h4><p>当对参数的修改结果需要带回主函数时在传递参数时则需要在参数前加取地址符&amp; </p><p>CSDN博客：（易错点）什么时候要传入参数的引用“&amp;“：<a href="https://blog.csdn.net/dyw_666666/article/details/107823466">https://blog.csdn.net/dyw_666666/article/details/107823466</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根-&gt;左-&gt;右   </p><p><strong>方法一：递归法</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">AC代码：<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">preorder</span>(root-&gt;left,res);<br>        <span class="hljs-built_in">preorder</span>(root-&gt;right,res);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">preorder</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法二：迭代法</strong> </p><p>方法1中的递归函数可以用迭代的方法实现，迭代法利用栈来遍历二叉树</p><p>LeetCode题解+动画演示 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/">二叉树前序遍历 迭代法</a> </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        stack&lt;TreeNode*&gt; stk;<br>        TreeNode* node = root;<br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() || node != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(node-&gt;val);<br>                stk.<span class="hljs-built_in">emplace</span>(node);<br>                node = node-&gt;left;<br>            &#125;<br>            node = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            node = node-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><h2 id="LC-94-二叉树的中序遍历"><a href="#LC-94-二叉树的中序遍历" class="headerlink" title="LC 94.二叉树的中序遍历"></a>LC 94.二叉树的中序遍历</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：递归法</strong></p><p>左-&gt;根-&gt;右   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left,ans);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right,ans);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">inorder</span>(root,ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> <strong>方法2：迭代法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)  <span class="hljs-keyword">return</span> ans;<br>        stack&lt;TreeNode*&gt; stk;<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || root != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-145-二叉树的后序遍历"><a href="#LC-145-二叉树的后序遍历" class="headerlink" title="LC 145.二叉树的后序遍历"></a>LC 145.二叉树的后序遍历</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>左-&gt;右-&gt;根   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">postorder</span>(root-&gt;left,ans);<br>        <span class="hljs-built_in">postorder</span>(root-&gt;right,ans);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">postorder</span>(root,ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-102-二叉树的层序遍历"><a href="#LC-102-二叉树的层序遍历" class="headerlink" title="LC 102.二叉树的层序遍历"></a>LC 102.二叉树的层序遍历</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>二叉树 队列 广度优先搜索  </p><h4 id="二维vector容器的使用"><a href="#二维vector容器的使用" class="headerlink" title="二维vector容器的使用"></a>二维vector容器的使用</h4><p>res.push_back(vector&lt;int&gt;());  //向二维vector容器res中添加一行</p><p>res.back().push_back(node-&gt;val);  //向二维容器的最后一行插入一个元素node-&gt;val</p><p>其中res.back()是指二维容器res的最后一行</p><p>关于C++中vector&lt;vector&lt;int&gt; &gt;的使用：<a href="https://www.cnblogs.com/tyty-Somnuspoppy/p/9361821.html">https://www.cnblogs.com/tyty-Somnuspoppy/p/9361821.html</a></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><blockquote><p>用广度优先搜索+队列解决二叉树的层序遍历 我们可以用一种巧妙的方法修改广度优先搜索： 首先根元素入队 当队列不为空的时候 求当前队列的长度 currentLevelSize 依次从队列中取currentLevelSize个元素进行拓展，然后进入下一次迭代 它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取currentLevelSize个元素。在上述过程中的第 i 次迭代就得到了二叉树的第 i层的 currentLevelSize个元素。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;  <span class="hljs-comment">//定义二维vector容器res用来存储树中元素</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        queue&lt;TreeNode*&gt; q;  <span class="hljs-comment">//定义队列q临时存储树中元素</span><br>        q.<span class="hljs-built_in">push</span>(root);  <span class="hljs-comment">//将树的根节点插入队列</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> currentLevelSize = q.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">//定义队列的当前长度currentLevelSize</span><br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());  <span class="hljs-comment">//向二维vector容器res中添加一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=currentLevelSize; i++)<br>            &#123;<br>                <span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">//定义临时结点node为队列头结点</span><br>                q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//弹出队列头结点</span><br>                res.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(node-&gt;val);  <span class="hljs-comment">//将队列头结点元素的值存入res中</span><br>                <span class="hljs-comment">//将结点的左右儿子节点插入队列中</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left)<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node-&gt;right)<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++标准模板库（C++STL）</title>
    <link href="/2022/03/04/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88C++STL%EF%BC%89/"/>
    <url>/2022/03/04/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88C++STL%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-iterator迭代器"><a href="#1-iterator迭代器" class="headerlink" title="1.iterator迭代器"></a>1.iterator迭代器</h2><h3 id="1-定义和初始化"><a href="#1-定义和初始化" class="headerlink" title="1.定义和初始化"></a>1.定义和初始化</h3><p>每种容器都定义了自己的迭代器类型，如vector </p><p>vector<int>::iterator it;  //定义一个名为it的变量 </p><p>每种容器都定义了一对名为begin和end的函数，用于返回迭代器 </p><p>vector<int> ivec; </p><p>vector<int>::iterator it1 = ivec.begin();  //将迭代器it1指向ivec的第一个元素 </p><p>vector<int>::iterator it2 = ivec.end();  //将迭代器it2指向ivec容器的最后一个元素的下一个位置 end并不指向容器的任何元素  </p><h3 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2.常用操作"></a>2.常用操作</h3><p>vector<int>:: iterator it; </p><p>1.it +/- n; </p><p>2.it1 +/-= it2; </p><p>3.it1-it2; </p><p>4.&gt;,&gt;=,&lt;,&lt;=  </p><h2 id="2-vector容器"><a href="#2-vector容器" class="headerlink" title="2.vector容器"></a>2.vector容器</h2><h3 id="1-创建vector对象"><a href="#1-创建vector对象" class="headerlink" title="1.创建vector对象"></a>1.创建vector对象</h3><p>创建vector容器有三种形式 </p><p>1.不指定容器的个数：vector<int> v;</p><p>2.创建时指定容器的大小：vector<double> v(10);</p><p>3.创建一个具有n个元素的向量容器，每个元素具有指定的初始值 vector<double> v(10,8.6)  //v向量容器，共有10个元素，每个元素的初始值为8.6  </p><h3 id="2-尾部元素扩张"><a href="#2-尾部元素扩张" class="headerlink" title="2.尾部元素扩张"></a>2.尾部元素扩张</h3><p>v.push_back(num);  </p><h3 id="3-下标方式访问vector元素"><a href="#3-下标方式访问vector元素" class="headerlink" title="3.下标方式访问vector元素"></a>3.下标方式访问vector元素</h3><p>类似于数组的访问方式。对于vector对象，可以采用下标方式随意访问它的某个元素，也可以通过下标方式对某个元素重新赋值 </p><p>vector<int> v(3); </p><p>v[0]=2,v[1]=7,v[2]=9; </p><p>cout&lt;&lt;v[0]&lt;&lt;” “&lt;&lt;v[1]&lt;&lt;” “&lt;&lt;v[2]&lt;&lt;endl;  </p><h3 id="4-用迭代器访问vector容器"><a href="#4-用迭代器访问vector容器" class="headerlink" title="4.用迭代器访问vector容器"></a>4.用迭代器访问vector容器</h3><p>vector<int> v(3); </p><p>v[0]=2,v[1]=7,v[2]=9; </p><p>vector<int>::iterator it;  //定义迭代器 变量 </p><p>for(it=v.begin(); it!=v.end(); it++) </p><p>{ cout&lt;&lt;*it&lt;&lt;” “;  //输出迭代器上的元素值 }  </p><h3 id="5-插入元素"><a href="#5-插入元素" class="headerlink" title="5.插入元素"></a>5.插入元素</h3><p>insert()方法可以在vector对象的任意位置前插入一个新元素 </p><p>insert()方法要求插入的位置是元素的迭代器的位置，而不是元素的下标 </p><p>v.insert(v.begin(),8);  //在最前面插入新元素，元素值为8 </p><p>v.insert(v.begin()+2,1);  //在第2个元素前插入新元素1 </p><p>v.insert(v.end(),3);  //在向量末尾追加新元素3  </p><h3 id="6-元素的删除"><a href="#6-元素的删除" class="headerlink" title="6.元素的删除"></a>6.元素的删除</h3><p>erase()方法可以删除vector中迭代器所指向的一个元素或者一段区间中的所有元素 </p><p>v.erase(v.begin()+2);  //删除第二个元素，从0开始计数 </p><p>v.erase(v.begin()+1,v.begin()+5);  //删除迭代器第1到5区间的所有元素 </p><p>clear()方法则一次性删除vector中的所有元素 </p><p>v.clear();  //清空向量  </p><h3 id="7-使用reverse反向排列算法"><a href="#7-使用reverse反向排列算法" class="headerlink" title="7.使用reverse反向排列算法"></a>7.使用reverse反向排列算法</h3><p>reverse(v.begin(),v.end());  //反向排列向量从首到尾间的元素  </p><h3 id="8-使用sort算法对向量元素排序"><a href="#8-使用sort算法对向量元素排序" class="headerlink" title="8.使用sort算法对向量元素排序"></a>8.使用sort算法对向量元素排序</h3><p>sort(v.begin(),v.end());   自定义降序排列比较函数cmp bool cmp(const int &amp;a,const int &amp;b) { return a&gt;b; } sort(v.begin(),v.end(),cmp)  //按cmp函数比较规则排序  </p><h3 id="9-向量的大小"><a href="#9-向量的大小" class="headerlink" title="9.向量的大小"></a>9.向量的大小</h3><p>v.size()  //方法返回向量大小，即元素的个数 v.empty()  //方法返回向量是否为空  </p><h2 id="3-string容器"><a href="#3-string容器" class="headerlink" title="3.string容器"></a>3.string容器</h2><p> </p><h2 id="4-set容器"><a href="#4-set容器" class="headerlink" title="4.set容器"></a>4.set容器</h2><p> </p><h2 id="5-multiset容器"><a href="#5-multiset容器" class="headerlink" title="5.multiset容器"></a>5.multiset容器</h2><p> </p><h2 id="6-map容器"><a href="#6-map容器" class="headerlink" title="6.map容器"></a>6.map容器</h2><p> </p><h2 id="7-multimap容器"><a href="#7-multimap容器" class="headerlink" title="7.multimap容器"></a>7.multimap容器</h2><p> </p><h2 id="8-queue容器"><a href="#8-queue容器" class="headerlink" title="8.queue容器"></a>8.queue容器</h2><p> </p><h2 id="9-priority-queue容器"><a href="#9-priority-queue容器" class="headerlink" title="9.priority_queue容器"></a>9.priority_queue容器</h2><p> </p><h2 id="10-stack容器"><a href="#10-stack容器" class="headerlink" title="10.stack容器"></a>10.stack容器</h2><p> </p><h2 id="11-algorithm容器"><a href="#11-algorithm容器" class="headerlink" title="11.algorithm容器"></a>11.algorithm容器</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 350.两个数组的交集</title>
    <link href="/2022/02/27/LC%20350.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <url>/2022/02/27/LC%20350.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>刷LeetCode有所收获的第一天！  </p><h2 id="LC-350-两个数组的交集"><a href="#LC-350-两个数组的交集" class="headerlink" title="LC 350.两个数组的交集"></a>LC 350.两个数组的交集</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector 容器浅析</a>   </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1</strong></p><p>哈希表（不太会） 学习C++算法哈希（Hash） B站收藏   </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums1.<span class="hljs-built_in">size</span>()&gt;nums2.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersect</span>(nums2,nums1);<br>        &#125;<br>        unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums1)<br>        &#123;<br>            m[num]++;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; intersection;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(num))<br>            &#123;<br>                intersection.<span class="hljs-built_in">push_back</span>(num);<br>                m[num]--;<br>                <span class="hljs-keyword">if</span>(m[num] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    m.<span class="hljs-built_in">erase</span>(num);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intersection;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法2</strong> </p><p>排序+双指针（用到了C++ vector容器） </p><p>学习C++  STL标准库函数+vector 容器 </p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(),nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(),nums2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> length1 = nums1.<span class="hljs-built_in">size</span>(),length2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>,index2 = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(index1&lt;length1 &amp;&amp; index2&lt;length2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums1[index1]&gt;nums2[index2])<br>            &#123;<br>                index2++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[index1]&lt;nums2[index2])<br>            &#123;<br>                index1++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(nums1[index1]);<br>                index1++;<br>                index2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UPC疫情防控通自动提交脚本—云函数实现</title>
    <link href="/2022/02/23/upc%E7%96%AB%E6%83%85%E9%98%B2%E6%8E%A7%E9%80%9A%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC-%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/02/23/upc%E7%96%AB%E6%83%85%E9%98%B2%E6%8E%A7%E9%80%9A%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC-%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p> </p><h3 id="1、获取Server酱的API-Key实现微信推送"><a href="#1、获取Server酱的API-Key实现微信推送" class="headerlink" title="1、获取Server酱的API Key实现微信推送"></a>1、获取Server酱的API Key实现微信推送</h3><p>打开<a href="http://sc.ftqq.com/3.version">Server酱主页</a>，按照页面指示获取Key并绑定微信，复制Key备用。</p><p> </p><h3 id="2、代码文件准备"><a href="#2、代码文件准备" class="headerlink" title="2、代码文件准备"></a>2、代码文件准备</h3><p>下载本仓库的代码，修改Index.js中的代码，使用上述准备的内容替换对应内容即可，修改完后打包即可。</p><p> </p><h3 id="3、新建云函数"><a href="#3、新建云函数" class="headerlink" title="3、新建云函数"></a>3、新建云函数</h3><p>这里以腾讯云为例，进入<a href="https://console.cloud.tencent.com/scf">腾讯云函数页面</a>，点击侧栏的函数服务，新建一个函数。</p><p>如果需要Server酱通知，请不要选择广州地区，其他地区请自行测试</p><p>函数名称随意，运行环境选择Nodejs12.16，创建方式选择空白函数即可，点击完成。 选择函数代码标签，提交方法选择本地上传zip包，上传方式选择在线安装依赖，选择保存并测试。成功的话转下一步，失败的话请检查相关字符串是否正确。  </p><h3 id="4、设置触发器"><a href="#4、设置触发器" class="headerlink" title="4、设置触发器"></a>4、设置触发器</h3><p>选择左侧触发管理，创建一个新的触发器。选择定时触发，出发周期自定义，自己根据想要自动提交的时间输入Cron数据即可。推荐使用0 1 1,8 * * * *即可，该触发时间为每天的01:01和08:01，防止因为系统或某方面原因而失败。</p><p> </p><h3 id="5、数据配置"><a href="#5、数据配置" class="headerlink" title="5、数据配置"></a>5、数据配置</h3><p>如果需要修改表单数据，在自动提交之前手动通过提交一次数据即可，第二天将会自动修正数据。</p><p> </p><p>博客转载于：<a href="https://github.com/tienskowl/AutoReport">https://github.com/tienskowl/AutoReport</a></p>]]></content>
    
    
    <categories>
      
      <category>解忧杂货</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
