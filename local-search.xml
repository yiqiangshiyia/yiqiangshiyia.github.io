<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>链表归纳总结</title>
    <link href="/2022/05/22/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    <url>/2022/05/22/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h4><p> 链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p><p><img src="https://img.yiqiangshiyia.cn/blog/1774269-20191111002101989-1257105196.jpg" alt="img"></p><h4 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h4><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p><p>链表是一种插入和删除都比较快的数据结构，缺点是查找比较慢。除非需要频繁的通过下标来随机访问数据，否则在很多使用数组的地方都可以用链表代替。</p><h2 id="LeetCode-206题：反转链表"><a href="#LeetCode-206题：反转链表" class="headerlink" title="LeetCode 206题：反转链表"></a>LeetCode 206题：反转链表</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* pre &#x3D; nullptr;  &#x2F;&#x2F;定义一个当前节点的前一个节点 初始化为空        ListNode* cur &#x3D; head;  &#x2F;&#x2F;定义一个当前节点 初始化为头结点        while(cur !&#x3D; nullptr)  &#x2F;&#x2F;当前节点不为空        &#123;            ListNode* tmp &#x3D; cur-&gt;next;  &#x2F;&#x2F;定义一个tmp结点 用于保存当前节点的后序节点            cur-&gt;next &#x3D; pre;  &#x2F;&#x2F;反转链表 让cur节点指向pre节点            pre &#x3D; cur;  &#x2F;&#x2F;前序节点后移一位            cur &#x3D; tmp;  &#x2F;&#x2F;当前节点后移一位        &#125;        return pre;  &#x2F;&#x2F;返回新链表指向的头结点    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>B站反转链表讲解：<a href="https://www.bilibili.com/video/BV1KZ4y157Up/?spm_id_from=333.788">https://www.bilibili.com/video/BV1KZ4y157Up/?spm_id_from=333.788</a></p><p> </p><h2 id="LeetCode-21题：合并两个有序链表"><a href="#LeetCode-21题：合并两个有序链表" class="headerlink" title="LeetCode 21题：合并两个有序链表"></a>LeetCode 21题：合并两个有序链表</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>只会迭代法 递归法有点复杂  </p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        ListNode* preHead &#x3D; new ListNode(-1);  &#x2F;&#x2F;定义哨兵节点preHead        ListNode* prev &#x3D; preHead;        while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;            if (l1-&gt;val &lt; l2-&gt;val) &#123;                prev-&gt;next &#x3D; l1;                l1 &#x3D; l1-&gt;next;            &#125; else &#123;                prev-&gt;next &#x3D; l2;                l2 &#x3D; l2-&gt;next;            &#125;            prev &#x3D; prev-&gt;next;        &#125;        &#x2F;&#x2F; 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可        prev-&gt;next &#x3D; l1 &#x3D;&#x3D; nullptr ? l2 : l1;        return preHead-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>LeetCode题解合并两个有序链表动画演示非常nice！ </p><p>LeetCode题解：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</a>  </p><h2 id="LeetCode-203题：移除链表元素"><a href="#LeetCode-203题：移除链表元素" class="headerlink" title="LeetCode 203题：移除链表元素"></a>LeetCode 203题：移除链表元素</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val  的节点,并返回新的头结点。  </p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：迭代法</strong> </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        &#x2F;&#x2F;由于链表头结点Head可能需要被删除 创建哑结点preHead 令pre-&gt;next &#x3D; head        ListNode* preHead &#x3D; new ListNode(0,head);        ListNode* tmp &#x3D; preHead;  &#x2F;&#x2F;定义当前节点 初始化为preHead        while(tmp-&gt;next !&#x3D; nullptr)        &#123;            if(tmp-&gt;next-&gt;val &#x3D;&#x3D; val)            &#123;                tmp-&gt;next &#x3D; tmp-&gt;next-&gt;next;            &#125;            else            &#123;                tmp &#x3D; tmp-&gt;next;            &#125;        &#125;        return preHead-&gt;next;  &#x2F;&#x2F;返回删除操作后的头结点    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="LeetCode-2：两数相加"><a href="#LeetCode-2：两数相加" class="headerlink" title="LeetCode 2：两数相加"></a>LeetCode 2：两数相加</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><img src="https://img.yiqiangshiyia.cn/blog/addtwonumber1.jpg" alt="img"></p><blockquote><p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.</p></blockquote><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>力扣难度：中等 题目大致思路：模拟链表 注意进位即可</p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        ListNode* head &#x3D; new ListNode(-1);  &#x2F;&#x2F;定义链表头结点        ListNode* cur &#x3D; head;  &#x2F;&#x2F;定义节点cur指向链表头结点head        int add &#x3D; 0;        while(l1 !&#x3D; nullptr || l2 !&#x3D; nullptr)        &#123;            int n1 &#x3D; l1 ? l1-&gt;val : 0;            int n2 &#x3D; l2 ? l2-&gt;val : 0;            int sum &#x3D; n1+n2+add;            cur-&gt;next &#x3D; new ListNode(sum%10);            cur &#x3D; cur-&gt;next;            add &#x3D; sum&#x2F;10;            if(l1)  l1 &#x3D; l1-&gt;next;            if(l2)  l2 &#x3D; l2-&gt;next;        &#125;        if(add &gt; 0)        &#123;            cur-&gt;next &#x3D; new ListNode(add);        &#125;        return head-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="LeetCode-142：环形链表"><a href="#LeetCode-142：环形链表" class="headerlink" title="LeetCode 142：环形链表"></a>LeetCode 142：环形链表</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>解决环形链表问题的两种方法：</p><ul><li>哈希表</li><li>快慢指针</li></ul><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：哈希表</strong></p><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        unordered_set&lt;ListNode*&gt; seen;        while(head !&#x3D; nullptr)        &#123;            if(seen.count(head))            &#123;                return head;            &#125;            seen.insert(head);            head &#x3D; head-&gt;next;        &#125;        return nullptr;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>方法2：快慢指针</strong></p><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/">https://leetcode.cn/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/</a></p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        ListNode *slow &#x3D; head, *fast &#x3D; head;        while (fast !&#x3D; nullptr) &#123;            slow &#x3D; slow-&gt;next;            if (fast-&gt;next &#x3D;&#x3D; nullptr) &#123;                return nullptr;            &#125;            fast &#x3D; fast-&gt;next-&gt;next;            if (fast &#x3D;&#x3D; slow) &#123;                ListNode *ptr &#x3D; head;                while (ptr !&#x3D; slow) &#123;                    ptr &#x3D; ptr-&gt;next;                    slow &#x3D; slow-&gt;next;                &#125;                return ptr;            &#125;        &#125;        return nullptr;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树问题有关的深度优先搜索</title>
    <link href="/2022/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E6%9C%89%E5%85%B3%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E6%9C%89%E5%85%B3%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树问题有关的深度优先搜索"><a href="#二叉树问题有关的深度优先搜索" class="headerlink" title="二叉树问题有关的深度优先搜索"></a>二叉树问题有关的深度优先搜索</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>跟着Bilibili上别人总结的一些算法刷题模板和思路总结来刷题效率要高很多！Bilibili上有很多优质的算法视频同一类型的题目都放在一起讲，总结的也非常nice！🧐</p><h3 id="算法应用场景"><a href="#算法应用场景" class="headerlink" title="算法应用场景"></a>算法应用场景</h3><blockquote><p>深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次.</p></blockquote><ul><li>二叉树有关的问题</li><li>需要从根节点遍历到末尾叶子节点</li></ul><p>常见题型</p><p>满足（最大，最小，某种要求）的深度、路径、节点和……</p><h3 id="DFS思路"><a href="#DFS思路" class="headerlink" title="DFS思路"></a>DFS思路</h3><ol><li><p><strong>创建结果存储变量，初始化当前结果</strong></p></li><li><p><strong>设计递归函数</strong></p><p>函数执行过程：</p><ul><li>若到达结尾，则返回</li><li>若未到达结尾，则更新当前结果</li><li>若到达末尾叶子节点，进行最优结果更新</li><li>分别对当前节点的左/右叶子节点调用递归函数</li></ul></li><li><p><strong>开始调用递归函数</strong></p></li></ol><p>DFS代码模板（JS版）：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">dfsTemplate</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//存储最终结果</span>    <span class="token keyword">let</span> res<span class="token punctuation">;</span>    <span class="token comment">//初始化当前结果</span>    <span class="token keyword">let</span> start<span class="token punctuation">;</span>    <span class="token comment">//构造递归函数dfs,通常参数为当前节点和当前结果</span>    <span class="token keyword">let</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> currentResult</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//终止条件返回判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//更新当前结果currentResult</span>        <span class="token comment">//若到达末尾叶子结点，进行最优结果更新</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//update res</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//左右子树递归</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> currentResult<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> currentResult<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>相关题目：</p><ul><li>LeetCode 104：二叉树的最大深度</li><li>LeetCode 111：二叉树的最小深度</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长回文子串 动态规划</title>
    <link href="/2022/05/18/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/05/18/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-5：最长回子文串"><a href="#LeetCode-5：最长回子文串" class="headerlink" title="LeetCode 5：最长回子文串"></a>LeetCode 5：最长回子文串</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>动态规划的题目很少做，最近刷几道滑动窗口的题之后就去练动态规划的题目。</p><p>动态规划类的题目重点就是动态转移方程和边界条件。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：中心扩散法</strong></p><p><strong>方法2：动态规划</strong></p><p>定义二维数组dp[length][length]，如果dp[left][right]为true，则表示字符串从left到right是回文子串，如果dp[left][right]为false，则表示字符串从left到right不是回文子串。</p><p>如果dp[left+1][right-1]为true，我们判断s.[left]和s.[right]是否相等，如果相等，那么dp[left][right]肯定也是回文子串，否则dp[left][right]一定不是回文子串。</p><p>所以我们可以找出递推公式</p><p> dp[left][right]=s.[left]==s.[right]&amp;&amp;dp[left+1][right-1]</p><p>有了递推公式，还要确定边界条件：</p><p>如果s.[left]!=s.[right]，那么字符串从left到right是不可能构成子串的，直接跳过即可。</p><p>如果s.[left]==s.[right]，字符串从left到right能不能构成回文子串还需要进一步判断</p><ul><li>如果left==right，也就是说只有一个字符，我们认为他是回文子串。即dp[left][right]=true（left==right）</li><li>如果right-left&lt;=2，类似于”aa”，或者”aba”，我们认为他是回文子串。即dp[left][right]=true（right-left&lt;=2）</li><li>如果right-left&gt;2，我们只需要判断dp[left+1][right-1]是否是回文子串，才能确定dp[left][right]是否为true还是false。即dp[left][right]=dp[left+1][right-1]</li></ul><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string longestPalindrome(string s) &#123;        &#x2F;&#x2F;边界条件判断        if(s.size() &lt; 2)  return s;        int start &#x3D; 0;  &#x2F;&#x2F;最长回文串开始的位置        int maxlen &#x3D; 1; &#x2F;&#x2F;最长回文串的长度        int len &#x3D; s.size();        vector&lt;vector&lt;bool&gt;&gt; dp(len,vector&lt;bool&gt;(len));        for(int right&#x3D;1; right&lt;len; right++)        &#123;            for(int left&#x3D;0; left&lt;right; left++)            &#123;                &#x2F;&#x2F;如果两种字符不相同，肯定不能构成回文子串                if(s[left] !&#x3D; s[right])  continue;                                if(left &#x3D;&#x3D; right)&#123;                    dp[left][right] &#x3D; true;                &#125;else if(right-left &lt;&#x3D; 2)&#123;                    dp[left][right] &#x3D; true;                &#125;else if(dp[left+1][right-1])&#123;                    dp[left][right] &#x3D; true;                &#125;                if(dp[left][right] &amp;&amp; right-left+1 &gt; maxlen)                &#123;                    start &#x3D; left;                    maxlen &#x3D; right-left+1;                &#125;            &#125;        &#125;        &#x2F;&#x2F;截取最长的回文子串        return s.substr(start,maxlen);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾Java</title>
    <link href="/2022/05/16/%E9%87%8D%E6%8B%BEJava/"/>
    <url>/2022/05/16/%E9%87%8D%E6%8B%BEJava/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC与MySQL数据库"><a href="#JDBC与MySQL数据库" class="headerlink" title="JDBC与MySQL数据库"></a>JDBC与MySQL数据库</h1><h2 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1 | JDBC"></a>1 | JDBC</h2><h3 id="JDBC（Java-DataBase-Connectivity）"><a href="#JDBC（Java-DataBase-Connectivity）" class="headerlink" title="JDBC（Java DataBase Connectivity）"></a>JDBC（Java DataBase Connectivity）</h3><ul><li>是用于执行SQL语句的Java应用程序接口，由一组用Java语言编写的类与接口 组成，是一种底层API</li><li>使开发人员可以用纯Java语言编写完整的数据库应用程序</li><li>用JDBC写的程序能够自动地将SQL语句传送给几乎任何一种数据库管理系统 （DBMS）</li><li>是一种规范，它让各数据库厂商为Java程序员提供标准的数据库访问类和接口 ，这样就使得独立于DBMS的Java应用开发工具和产品成为可能</li><li>隔离了Java与不同数据库之间的对话，使得程序员只须写一遍程序就可让它在任何数据库管理系统平台上运</li><li>使用已有的SQL标准，并支持其它数据库连接标准，如与ODBC之间的桥接</li></ul><p><strong>使用 JDBC可以进行如下的操作</strong> </p><ul><li>与一个数据库建立连接</li><li>向已连接的数据库发送SQL语句 </li><li>处理SQL语句返回的结果值</li></ul><h3 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h3><ul><li>是一组由Java语言编写的类和接口，包含在java.sql和javax.sql两个包中<ul><li>java.sql为核心包，这个包包含于J2SE中</li><li>javax.sql包扩展了JDBC API的功能，成为了J2EE的一个基本组成部分</li></ul></li><li>可分为两个层次<ul><li>面向底层的JDBC Driver API：主要是针对数据库厂商开发数据库底层驱动程序使用</li><li>面向程序员的JDBC API</li></ul></li></ul><p><img src="http://img.yiqiangshiyia.cn/blog/QQ%E6%88%AA%E5%9B%BE20220517130904.png" alt="应用程序通过JDBC API和底层的JDBC Driver API打交道"></p><h3 id="ODBC（-Open-Database-Connectivity-）"><a href="#ODBC（-Open-Database-Connectivity-）" class="headerlink" title="ODBC（ Open Database Connectivity ）"></a>ODBC（ Open Database Connectivity ）</h3><ul><li>由微软公司提出，用于在数据库管理系统(DBMS)中存取数据</li><li>是一套用C语言实现的访问数据库的API</li><li>通过ODBC API，应用程序可以存取保存在多种不同数据库管理系统（DBMS） 中的数据，而不论每个DBMS使用了何种数据存储格式和编程接口</li><li>对于没有提供JDBC驱动的数据库，从Java程序调用本地的C程序访问数据库会 带来一系列安全性、完整性、健壮性等方面的问题，因而通过JDBC-ODBC桥 来访问没有提供JDBC接口的数据库是一个常用的方案</li></ul><h2 id="2-JDBC-API中重要的接口和类"><a href="#2-JDBC-API中重要的接口和类" class="headerlink" title="2 | JDBC API中重要的接口和类"></a>2 | JDBC API中重要的接口和类</h2><table><thead><tr><th align="left">名称</th><th align="center">功能</th></tr></thead><tbody><tr><td align="left">DriverManager</td><td align="center">调入驱动程序</td></tr><tr><td align="left">Connection</td><td align="center">代表了对特定数据库的连接</td></tr><tr><td align="left">Statement</td><td align="center">基于Connection执行SQL语句</td></tr><tr><td align="left">PreparedStatement</td><td align="center">基于Connection执行带参数的SQL语句</td></tr><tr><td align="left">ResultSet</td><td align="center">保存查询语句得到的结果集</td></tr></tbody></table><h2 id="3-使用JDBC访问数据库的步骤"><a href="#3-使用JDBC访问数据库的步骤" class="headerlink" title="3 | 使用JDBC访问数据库的步骤"></a>3 | 使用JDBC访问数据库的步骤</h2><ul><li>设置环境，引入相应的JDBC类</li><li>选择合适的JDBC驱动程序并加载</li><li>分配一个Connection对象</li><li>分配一个Statement对象</li><li>用该Statement对象进行查询等操作</li><li>若查询则从返回的ResultSet对象中获取数据</li><li>关闭连接</li></ul><h2 id="4-通过JDBC-ODBC访问数据库"><a href="#4-通过JDBC-ODBC访问数据库" class="headerlink" title="4 | 通过JDBC-ODBC访问数据库"></a>4 | 通过JDBC-ODBC访问数据库</h2><ol><li><h3 id="设置环境，引入相应的JDBC类"><a href="#设置环境，引入相应的JDBC类" class="headerlink" title="设置环境，引入相应的JDBC类"></a><strong>设置环境，引入相应的JDBC类</strong></h3><p>在Java程序中引入相应的类和包。访问数据库使用的JDBC API在 java.sql包中，因此需要将该包引入程序。 import java.sql.*;</p></li><li><h3 id="选择DBMS驱动程序"><a href="#选择DBMS驱动程序" class="headerlink" title="选择DBMS驱动程序"></a><strong>选择DBMS驱动程序</strong></h3><ul><li><p>用Class.forName方法显式装载驱动程序</p><p>Class.forName(“com.mysql.cj.jdbc.Driver”);</p></li><li><p>执行后自动创建一个驱动器类的实例，并自动调用驱动器管理器DriverManager类中的RegisterDriver方法来注册它</p></li><li><p>需要注意的是，如果驱动器类有可能不存在，使用此方法就可能会抛出 ClassNotFoundException异常，因此需要捕获这个异常</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ul></li><li><h3 id="创建一个Connection对象连接到数据库"><a href="#创建一个Connection对象连接到数据库" class="headerlink" title="创建一个Connection对象连接到数据库"></a>创建一个Connection对象连接到数据库</h3><ul><li><p>Connection对象代表了与指定数据库的连接，可以调用 DriverManager.getConnection()方法创建，例如：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Connection</span> connect <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>DriverManager类位于JDBC的管理层，作用于用户和驱动程序之间。它负责跟 踪在一个系统中所有可用的JDBC驱动程序，并在数据库和相应驱动程序之间 建立连接</p></li></ul></li><li><h3 id="创建一个Statement对象执行SQL语句"><a href="#创建一个Statement对象执行SQL语句" class="headerlink" title="创建一个Statement对象执行SQL语句"></a>创建一个Statement对象执行SQL语句</h3><p>建立数据库的连接后，就可以对数据库进行操作了，一般包括三个步骤：</p><ul><li>使用Connection对象创建Statement对象</li><li>使用Statement对象执行SQL命令</li><li>从上一步骤返回的ResultSet对象中提取执行结果</li></ul><p><strong>Connection类有3个方法可用来创建向数据库发送SQL语句的 Statement对象：</strong></p><ul><li>createStatement：创建向数据库发送SQL语句的Statement对象，用于简单的SQL语句 Statement stmt = conn.createStatement();</li><li>prepareStatement：创建向数据库发送SQL语句的PreparedStatement对象，用于带有一个或多个参数的SQL 语句。在SQL语句执行前，这些参数将被赋值</li><li>prepareCall：创建向数据库发送SQL语句的CallableStatement对象，用于调用数据库中的存储过程</li></ul></li><li><h3 id="使用Statement对象执行语句"><a href="#使用Statement对象执行语句" class="headerlink" title="使用Statement对象执行语句"></a>使用Statement对象执行语句</h3><p><strong>Statement 对象提供了三种执行 SQL 语句的方法，使用哪一个方法由 SQL 语 句所产生的内容决定</strong></p><ul><li><p>executeQuery：用于产生单个结果集的语句，例如 SELECT 语句 ResultSet rs = stmt.executeQuery(“select * from user”);</p></li><li><p>executeUpdate：用于执行 INSERT、UPDATE 或 DELETE 语句，以及 CREATE TABLE stmt.executeUpdate(“DELETE FROM Person WHERE Name=’李四’”);</p><p>返回值是一个整数，表示受影响的行数（即更新计数），比如修改了多少行、删除了多少行等。对 于 CREATE TABLE 等语句，因不涉及到行的操作，所以executeUpdate的返回值总为零</p></li><li><p>Execute：用于执行返回多个结果集（ResultSet 对象）、多个更新计数或二者组合的语句。例如执行某个已存 储过程或动态执行SQL，这时有可能出现多个结果的情</p></li></ul></li><li><h3 id="从返回的ResultSet对象中获取相应的数据"><a href="#从返回的ResultSet对象中获取相应的数据" class="headerlink" title="从返回的ResultSet对象中获取相应的数据"></a>从返回的ResultSet对象中获取相应的数据</h3><p>ResultSet中的内容类似二维表格，是以“流”的方式按行访问的</p><ul><li><p>使用next()方法访问行：ResultSet中有一个游标，指向当前访问的 行；方法next的功能是将游标下移一行。即：每次调用next方法后， 游标会自动下移一行。</p></li><li><p>使用get类型()方法访问列：使用相应类型的getXXX()方法可以从当 前行指定列中提取不同类型的数据。例如：提取文本类型数据时就 要用getString方法</p></li><li><p>允许使用列名或列序号作为方法的参数</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>“name”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//提取name列</span><span class="token class-name">String</span> s <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//提取第2列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li></ul></li><li><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a><strong>关闭连接</strong></h3><p>数据库连接资源是宝贵的，应当在操作数据库后及时释放。</p><ul><li>stat.close(); //关闭语句</li><li>conn.close(); //关闭连接</li></ul></li></ol><p>通过JDBC-ODBC访问数据库实例代码：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span> <span class="token comment">//①引入JDBC类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DBTest</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span><span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span><span class="token comment">//②加载驱动</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"sun.jdbc.odbc.JdbcOdbcDriver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//③创建连接</span><span class="token class-name">Connection</span> conn<span class="token operator">=</span><span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:odbc:StudentDB"</span><span class="token punctuation">,</span> <span class="token string">"admin"</span><span class="token punctuation">,</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//④创建Statment对象</span><span class="token class-name">Statement</span> stat <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//⑤执行SQL语句</span>stat<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token string">"insert into Students(id,name,age) values ('1','张三','16')"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stat<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token string">"insert into Students(id,name,age) values ('2','李四','16')"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stat<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token string">"insert into Students(id,name,age) values ('3','王五','16')"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stat<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token string">"DELETE FROM students WHERE name='李四'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stat<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token string">"update students set age='20' WHERE name='王五'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//⑥SQL查询</span><span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token string">"select id,name from students order by id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//遍历ResultSet</span><span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//⑦关闭连接</span>stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="5-用纯JDBC驱动程序访问数据库"><a href="#5-用纯JDBC驱动程序访问数据库" class="headerlink" title="5 | 用纯JDBC驱动程序访问数据库"></a>5 | 用纯JDBC驱动程序访问数据库</h2><ol><li><h3 id="引入JDBC类"><a href="#引入JDBC类" class="headerlink" title="引入JDBC类"></a>引入JDBC类</h3><p>在Java程序中引入相应的类和包。访问数据库使用的JDBC API在 java.sql包中，因此需要将该包引入程序。 import java.sql.*;</p></li><li><h3 id="加载DBMS驱动程序"><a href="#加载DBMS驱动程序" class="headerlink" title="加载DBMS驱动程序"></a>加载DBMS驱动程序</h3><ul><li><p>到数据库官网下载对应版本的数据库驱动程序包。</p></li><li><p>用Class.forName方法显式装载驱动程序</p><p>比如，Class.forName(“com.mysql.cj.jdbc.Driver”); </p><p>Class.forName(“oracle.jdbc.driver.OracleDriver”);</p></li></ul></li><li><h3 id="创建一个Connection对象连接到数据库-1"><a href="#创建一个Connection对象连接到数据库-1" class="headerlink" title="创建一个Connection对象连接到数据库"></a>创建一个Connection对象连接到数据库</h3><p>调用DriverManager.getConnection()方法创建Connection对象</p><p>例如：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>“jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>mydata<span class="token operator">?</span>user<span class="token operator">=</span>root<span class="token operator">&amp;</span>password<span class="token operator">=</span><span class="token number">123</span><span class="token operator">&amp;</span>useSSL<span class="token operator">=</span><span class="token boolean">false</span><span class="token operator">&amp;</span>serverTimezone<span class="token operator">=</span>UTC”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span>getConnection<span class="token punctuation">(</span><span class="token string">"jdbc:oracle:thin:@192.168.1.102:1521:orcl"</span><span class="token punctuation">,</span> <span class="token string">"spring"</span><span class="token punctuation">,</span> <span class="token string">"spring"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><h3 id="创建一个Statement对象执行SQL语句-1"><a href="#创建一个Statement对象执行SQL语句-1" class="headerlink" title="创建一个Statement对象执行SQL语句"></a>创建一个Statement对象执行SQL语句</h3><p>建立数据库的连接后，就可以对数据库进行操作了，一般包括三个步骤：</p><ul><li>使用Connection对象创建Statement对象</li><li>使用Statement对象执行SQL命令</li><li>从上一步骤返回的ResultSet对象中提取执行结果</li></ul><p><strong>Connection类有3个方法可用来创建向数据库发送SQL语句的 Statement对象：</strong></p><ul><li>createStatement：创建向数据库发送SQL语句的Statement对象，用于简单的SQL语句 Statement stmt = conn.createStatement();</li><li>prepareStatement：创建向数据库发送SQL语句的PreparedStatement对象，用于带有一个或多个参数的SQL 语句。在SQL语句执行前，这些参数将被赋值</li><li>prepareCall：创建向数据库发送SQL语句的CallableStatement对象，用于调用数据库中的存储过程</li></ul></li><li><h3 id="使用Statement对象执行语句-1"><a href="#使用Statement对象执行语句-1" class="headerlink" title="使用Statement对象执行语句"></a>使用Statement对象执行语句</h3><p><strong>Statement 对象提供了三种执行 SQL 语句的方法，使用哪一个方法由 SQL 语 句所产生的内容决定</strong></p><ul><li><p>executeQuery：用于产生单个结果集的语句，例如 SELECT 语句 ResultSet rs = stmt.executeQuery(“select * from user”);</p></li><li><p>executeUpdate：用于执行 INSERT、UPDATE 或 DELETE 语句，以及 CREATE TABLE stmt.executeUpdate(“DELETE FROM Person WHERE Name=’李四’”);</p><p>返回值是一个整数，表示受影响的行数（即更新计数），比如修改了多少行、删除了多少行等。对 于 CREATE TABLE 等语句，因不涉及到行的操作，所以executeUpdate的返回值总为零</p></li><li><p>Execute：用于执行返回多个结果集（ResultSet 对象）、多个更新计数或二者组合的语句。例如执行某个已存 储过程或动态执行SQL，这时有可能出现多个结果的情</p></li></ul></li><li><h3 id="关闭连接-1"><a href="#关闭连接-1" class="headerlink" title="关闭连接"></a><strong>关闭连接</strong></h3><p>数据库连接资源是宝贵的，应当在操作数据库后及时释放。</p><ul><li>conn.close(); //关闭连接</li></ul></li></ol><p>用纯JDBC驱动程序访问MySQL8.0数据库实例代码：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DatabaseAccess</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token class-name">Connection</span> <span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">String</span> url<span class="token operator">=</span>"jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>mydata<span class="token operator">?</span>user<span class="token operator">=</span>root<span class="token operator">&amp;</span>password<span class="token operator">=</span><span class="token number">123</span><span class="token operator">&amp;</span>useSSL<span class="token operator">=</span><span class="token boolean">false</span><span class="token operator">&amp;</span>serverTimezone<span class="token operator">=</span>UTC"<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>          <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> conn<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getStudentInfo</span><span class="token punctuation">(</span><span class="token class-name">String</span> sno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> sql <span class="token operator">=</span> “select <span class="token operator">*</span> from student where sno<span class="token operator">=</span><span class="token operator">?</span>"<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatabaseAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PreparedStatement</span> ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> sno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> ps<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span> rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>“sno”<span class="token punctuation">)</span> <span class="token operator">+</span>rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>“sname”<span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="6-使用预处理语句"><a href="#6-使用预处理语句" class="headerlink" title="6 | 使用预处理语句"></a>6 | 使用预处理语句</h2><ul><li>使用PreparedStatement类对象的prepareStatement(String sql)方 法对SQL语句进行预编译处理，生成该数据库底层的内部命令。</li><li>该用法支持带参数的SQL语句的执行，这给SQL语句的执行带来很大 的灵活性。</li><li>使用通配符?(英文的问号)，代替数据表字段的值。需要在SQL执行之 前设置通配符代表的具体值。</li><li>设置通配符?的值的常用方法：<ul><li>void setDate(int parameterIndex, Date x);</li><li>void setDouble(int parameterIndex, double x);</li><li>void setFloat(int parameterIndex, float x);</li><li>void setInt(int parameterIndex, int x);</li><li>void setLong(int parameterIndex, long x);</li><li>void setString(int parameterIndex, String x);</li></ul></li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ex7_9</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> <span class="token class-name">DBDriver</span><span class="token operator">=</span><span class="token string">"sun.jdbc.odbc.JdbcOdbcDriver"</span><span class="token punctuation">;</span><span class="token class-name">String</span> connectionStr<span class="token operator">=</span><span class="token string">"jdbc:odbc:studentDB"</span><span class="token punctuation">;</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token class-name">DBDriver</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Connection</span> con<span class="token operator">=</span><span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>connectionStr<span class="token punctuation">,</span>“admin<span class="token string">",“admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">" UPDATE person SET salary=? WHERE name=? "</span><span class="token punctuation">;</span> <span class="token comment">//设置了2个参数</span><span class="token class-name">PreparedStatement</span> pstmt<span class="token operator">=</span>con<span class="token punctuation">.</span> <span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span> <span class="token punctuation">;</span>pstmt<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//为第1个参数赋值，根据参数类型的不同调用不同方法</span>pstmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">//为第2个参数赋值</span>pstmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">//执行SQL语句</span>con<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭连接</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="7-事物"><a href="#7-事物" class="headerlink" title="7 | 事物"></a>7 | 事物</h2><ul><li><p>事务由一组SQL语句组成。事务处理指应用程序保证事务中的SQL语 句要么全部执行，要么一个都不执行。</p></li><li><p>JDBC事务处理步骤：</p><ul><li>用setAutoCommit(boolean b)方法关闭自动提交模式</li><li>用commit()方法处理事务</li><li>用rollback()方法处理事务回滚</li></ul></li><li><p>setAutoCommit(boolean b) 方法：</p><p>用Connection的对象调用该方法设置提交模式</p><ul><li>先关闭自动提交模式 ： conn.setAutoCommit(false);</li><li>然后获取Statement对象st： st=conn.createStatement();</li></ul></li><li><p>commit()方法处理事务</p><p>用Connection的对象调用该方法让事务中的全部SQL语句生效 </p><ul><li>conn.commit();</li></ul></li><li><p>rollback()方法进行事务回滚</p><p>用Connection的对象调用该方法撤销事务中已经成功执行的对数据库进行更新 操作的SQL语句，将数据恢复到commit()方法执行之前的状态。</p><ul><li>conn.rollback();</li></ul></li></ul><h1 id="Swing与AWT"><a href="#Swing与AWT" class="headerlink" title="Swing与AWT"></a>Swing与AWT</h1><h2 id="1-Swing的特点和概念"><a href="#1-Swing的特点和概念" class="headerlink" title="1| Swing的特点和概念"></a>1| Swing的特点和概念</h2><ul><li><h4 id="Swing-GUI-组件"><a href="#Swing-GUI-组件" class="headerlink" title="Swing GUI 组件"></a>Swing GUI 组件</h4><ul><li>javax.swing包</li><li>源于AWT（package java.awt）的组件</li><li>包括外观和感觉 <ul><li>外观以及用户如何和程序交互</li></ul></li><li>轻量级组件<ul><li>完全用Java写成，不是用当前平台的GUI功</li></ul></li></ul></li><li><h4 id="绝大多数Swing组件的继承层次"><a href="#绝大多数Swing组件的继承层次" class="headerlink" title="绝大多数Swing组件的继承层次"></a>绝大多数Swing组件的继承层次</h4><p>javax.swing.JComponent→java.awt.Container→java.awt.Component→java.lang.Object</p></li><li><h4 id="JComponent类是除了顶层容器以外所有Swing组件的基类，根据继承关系，我-们可以在每个基类中找到大多数GUI组件的常见操作"><a href="#JComponent类是除了顶层容器以外所有Swing组件的基类，根据继承关系，我-们可以在每个基类中找到大多数GUI组件的常见操作" class="headerlink" title="JComponent类是除了顶层容器以外所有Swing组件的基类，根据继承关系，我 们可以在每个基类中找到大多数GUI组件的常见操作"></a>JComponent类是除了顶层容器以外所有Swing组件的基类，根据继承关系，我 们可以在每个基类中找到大多数GUI组件的常见操作</h4><ul><li>Component 类<ul><li>包含paint、repaint方法，可以在屏幕上绘制组件</li><li>大多数GUI组件直接或间接扩展Component</li></ul></li><li>Container 类<ul><li>容纳相关组件</li><li>包括add方法，用来添加组件</li><li>包括setLayout方法，这个方法可用来设置布局，以帮助Container对象对其中的组件进行定位和设 置组件大小</li></ul></li><li>JComponent 类——多数Swing组件的超类<ul><li>可抽换的外观和感觉，即可根据需求定制外观和感觉。 </li><li>快捷键 (通过键盘直接访问GUI组件) </li><li>一般的事件处理功能</li></ul></li></ul></li></ul><h2 id="2-Swing的组件和容器层次"><a href="#2-Swing的组件和容器层次" class="headerlink" title="2| Swing的组件和容器层次"></a>2| Swing的组件和容器层次</h2><h3 id="通常将javax-swing包里的Swing组件归为三个层次"><a href="#通常将javax-swing包里的Swing组件归为三个层次" class="headerlink" title="通常将javax.swing包里的Swing组件归为三个层次"></a>通常将javax.swing包里的Swing组件归为三个层次</h3><ul><li>顶层容器</li><li>中间层容器</li><li>原子组件</li></ul><h3 id="顶层容器"><a href="#顶层容器" class="headerlink" title="顶层容器"></a>顶层容器</h3><ul><li>Swing提供三个顶层容器的类 <ul><li>JFrame 实现单个主窗口 </li><li>JDialog 实现一个二级窗口(对话框) </li><li>JApplet 在浏览器窗口中实现一个applet显示区域 </li></ul></li><li>必须和操作系统打交道，所以都是重量级组件</li><li>每个使用Swing组件的Java程序都必须至少有一个顶层容器，别的组件都必须放在这个顶层容器上才能显现出来</li></ul><h3 id="中间层容器"><a href="#中间层容器" class="headerlink" title="中间层容器"></a>中间层容器</h3><ul><li>其存在的目的仅仅是为了容纳别的组件</li><li>分为两类<ul><li>一般用途的<ul><li>JPanel</li><li>JScrollPane</li><li>JSplitPane</li><li>JTabbedPane</li><li>JToolBar</li></ul></li><li>特殊用途的<ul><li>JInternalFrame</li><li>JRootPane</li></ul></li></ul></li><li>可以直接从顶层容器中获得一个JRootPane对象来直接使用，而别的中间容 器使用的时候需要新建一个对象</li></ul><h3 id="原子组件"><a href="#原子组件" class="headerlink" title="原子组件"></a>原子组件</h3><ul><li>通常是在图形用户界面中和用户进行交互的组件</li><li>基本功能是和用户交互信息，而不像前两种组件那样是用来容纳别的组件的</li><li>根据功能的不同，可被分为三类<ul><li>显示不可编辑信息的JLabel、JProgressBar、JToolTip</li><li>有控制功能、可以用来输入信息的JButton、JCheckBox、JRadioButton、JComboBox、JList、 JMenu、JSlider、JSpinner、JTexComponent等</li><li>能提供格式化的信息并允许用户选择的JColorChooser、JFileChooser、JTable、JTree</li></ul></li></ul><p>三层容器结构示例代码：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>swing<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ex8_7</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">JFrame</span><span class="token punctuation">.</span><span class="token function">setDefaultLookAndFeelDecorated</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">JFrame</span> frame<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JFrame</span><span class="token punctuation">(</span><span class="token string">"Swing Frame"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Container</span> contentPane<span class="token operator">=</span>frame<span class="token punctuation">.</span><span class="token function">getContentPane</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">JPanel</span> panel<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> panel<span class="token punctuation">.</span><span class="token function">setBorder</span><span class="token punctuation">(</span><span class="token class-name">BorderFactory</span><span class="token punctuation">.</span><span class="token function">createLineBorder</span><span class="token punctuation">(</span><span class="token class-name">Color</span><span class="token punctuation">.</span>black<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>panel<span class="token punctuation">.</span><span class="token function">setLayout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GridLayout</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">JLabel</span> label<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JLabel</span><span class="token punctuation">(</span><span class="token string">"Label"</span><span class="token punctuation">,</span><span class="token class-name">SwingConstants</span><span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">JButton</span> button<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JButton</span><span class="token punctuation">(</span><span class="token string">"Button"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>panel<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span> panel<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>button<span class="token punctuation">)</span><span class="token punctuation">;</span>contentPane<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>panel<span class="token punctuation">)</span><span class="token punctuation">;</span>frame<span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对组件进行排列</span>frame<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示</span>frame<span class="token punctuation">.</span><span class="token function">setDefaultCloseOperation</span><span class="token punctuation">(</span><span class="token class-name">JFrame</span><span class="token punctuation">.</span>EXIT_ON_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>程序说明</p><ul><li>首先创建一个JFrame类顶级容器</li><li>然后获得顶级容器的内容面板contentPane，只有通过它才能加入其他组件。 </li><li>然后创建一个JPanel类的中间容器panel，并设置边框以及布局</li><li>然后创建原子组件Label，button，并将它们添加到中间容器上</li><li>然后将中间容器通过内容面板添加到顶层容器上，并对组件进行排列</li></ul><h2 id="3-布局管理"><a href="#3-布局管理" class="headerlink" title="3 | 布局管理"></a>3 | 布局管理</h2><p>如果使用绝对坐标对组件定位，那么不仅不灵活，而且在 窗口改变、跨平台时很容易出现问题。因此要用到布局管理器。</p><ul><li>布局管理器可以将下级组件有秩序地摆在上一级容器中</li><li>当改变窗口大小时，它还会自动更新版面来配合窗口的大小，不 必担心版面会因此混乱</li><li>容器对象可以调用方法“setLayout(某布局对象)”来设置自己的 布局。</li><li>布局方式有很多种，常用的有：<ul><li>FlowLayout </li><li>BorderLayout </li><li>CardLayout </li><li>GridLayout </li><li>BoxLayout</li></ul></li></ul><h3 id="FlowLayout布局"><a href="#FlowLayout布局" class="headerlink" title="FlowLayout布局"></a>FlowLayout布局</h3><p>Panel容器的默认布局（即如果不专门为其指定布局，则它们的布局就是FlowLayout）</p><p>特点：组件按照加入的先后顺序从左向右排列，一行排满之后自动换行</p><h3 id="BorderLayout布局"><a href="#BorderLayout布局" class="headerlink" title="BorderLayout布局"></a>BorderLayout布局</h3><p>Window型容器（如：Frame、Dialog等）的默认布局</p><p>特点：容器空间简单地划分为东、西、南、北、中五个区域，中 间的区域最大。</p><h3 id="CardLayout-布局"><a href="#CardLayout-布局" class="headerlink" title="CardLayout 布局"></a>CardLayout 布局</h3><p>特点：多个组件“叠放”在一起，同一时刻容器只能从这些组件中 选出一个来显示，就像“一叠扑克牌”每次只能显示最上面一张一 样。</p><h3 id="GridLayout布局"><a href="#GridLayout布局" class="headerlink" title="GridLayout布局"></a>GridLayout布局</h3><p>特点：把容器划分成若干行乘若干列的网格区域，组件就位于这些 划分出来的小格中；每个网格都是相同大小并且强制组件与网格的 大小相同。</p><h3 id="BoxLayout布局"><a href="#BoxLayout布局" class="headerlink" title="BoxLayout布局"></a>BoxLayout布局</h3><p>特点：将组件放在单一的行或列中。</p><p>和FlowLayout不同的是，它考虑到组件的对齐方式、最大、最小、 优选尺寸，并且组件再多也不会换行/列，始终紧缩在一行/列。</p><h2 id="4-事件处理"><a href="#4-事件处理" class="headerlink" title="4 | 事件处理"></a>4 | 事件处理</h2><h3 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h3><p>GUI是由事件驱动的，一些常见的事件包括：</p><ul><li>移动鼠标、左/右键单/双击鼠标</li><li>按下键盘某键</li><li>在文本字段输入</li><li>在菜单中选择菜单项</li><li>在组合框中选择、单选和多选</li><li>关闭窗口</li></ul><h3 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h3><h4 id="编写事件处理程序时，要注意三个概念："><a href="#编写事件处理程序时，要注意三个概念：" class="headerlink" title="编写事件处理程序时，要注意三个概念："></a>编写事件处理程序时，要注意三个概念：</h4><ul><li><p>事件源</p><ul><li>与用户进行交互的GUI组件，表示事件来自于哪个组件或对象</li><li>比如要对“点击按钮”这个事件编写处理程序，按钮就是事件源</li></ul></li><li><p>事件监听器</p><ul><li>负责监听事件并做出响应</li><li>一旦它监视到事件发生，就会自动调用相应的事件处理程序作出响应</li></ul></li><li><p>事件对象</p><ul><li>封装了有关已发生的事件的信息</li><li>例如“点击按钮”事件，当用户按下按钮时，就会产生一个事件对象， 其中包含事件和事件源的信息</li></ul></li></ul><h4 id="常用事件对象有："><a href="#常用事件对象有：" class="headerlink" title="常用事件对象有："></a>常用事件对象有：</h4><ul><li>ActionEvent：点击按钮、选择了某个菜单、在文本框中按下回 车键</li><li>ItemEvent：发生在具有多个选项的组件上，如JCheckBox、 JComboBox</li><li>ChangeEvent：用在可设定数值的拖拽杆上，例如JSlider、 JProgressBar等</li><li>WindowEvent：处理窗口的操作</li><li>MouseEvent：鼠标的操作</li></ul><h4 id="ActionEvent事件："><a href="#ActionEvent事件：" class="headerlink" title="ActionEvent事件："></a>ActionEvent事件：</h4><ul><li>事件源：文本框、按钮、菜单项、密码框、单选按钮都可以触发 ActionEvent事件。</li><li>注册监视器：以上组件对象调用addActionListener( ActionListener listen)  方法将监视器对象注册为该事件源的监视器。</li><li>对监视事件的处理：事件源触发ActionEvent事件后，监视器调用 actionPerformed( ActionEvent e)方法对事件做出处理。</li><li>ActionEvent类的方法： public Object getSource( )：返回事件源对象</li></ul><h4 id="要实现事件处理，程序员应完成的两项任务："><a href="#要实现事件处理，程序员应完成的两项任务：" class="headerlink" title="要实现事件处理，程序员应完成的两项任务："></a>要实现事件处理，程序员应完成的两项任务：</h4><ul><li>为事件源注册一个事件监听器</li><li>实现事件的处理方法</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*第一步：注册监听器本例中在整个窗口注册一个监听器，然后每个按钮共享该监听器第二步：判断事件来源于哪个按钮，响应处理*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMainFrame</span> <span class="token keyword">extends</span> <span class="token class-name">Jframe</span> <span class="token keyword">implements</span> <span class="token class-name">ActionListener</span> <span class="token punctuation">&#123;</span>……                                      <span class="token comment">//implements ActionListener为窗口监听器</span><span class="token keyword">public</span> <span class="token class-name">MyMainFrame</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//每个按钮增加监听器</span>start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JButton</span><span class="token punctuation">(</span><span class="token string">"开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>start<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>preview <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JButton</span><span class="token punctuation">(</span><span class="token string">"预览"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>preview<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>……<span class="token punctuation">&#125;</span>    <span class="token comment">//判断时间来源并处理</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">JButton</span> button<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">JButton</span><span class="token punctuation">)</span> e<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>button <span class="token operator">==</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>……<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>button <span class="token operator">==</span> preview<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>……<span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>button <span class="token operator">==</span> set<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>……<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="5-常用的Swing组件"><a href="#5-常用的Swing组件" class="headerlink" title="5 | 常用的Swing组件"></a>5 | 常用的Swing组件</h2><h2 id="6-窗体程序的开发步骤"><a href="#6-窗体程序的开发步骤" class="headerlink" title="6 | 窗体程序的开发步骤"></a>6 | 窗体程序的开发步骤</h2><h4 id="用Java开发Windows程序的一般步骤："><a href="#用Java开发Windows程序的一般步骤：" class="headerlink" title="用Java开发Windows程序的一般步骤："></a>用Java开发Windows程序的一般步骤：</h4><ol><li>创建窗体Frame并选择布局</li><li>为窗体添加组件</li><li>设置组件的布局</li><li>设置各个组件的属性</li><li>为需要触发事件的组件增加事件监听器</li><li>编写事件处理程序</li></ol><h1 id="泛型与集合框架"><a href="#泛型与集合框架" class="headerlink" title="泛型与集合框架"></a>泛型与集合框架</h1><h2 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1 | 泛型"></a>1 | 泛型</h2><ul><li>泛型（Generics）是在JDK1.5中推出的，其主要目的是可以 建立具有类型安全的集合框架，如链表、散列映射等数据结 构。</li><li>“泛型”规定了集合内元素的类型，从而在编译时进行严格 的类型检查，消除了绝大多数的类型转换。</li></ul><h3 id="泛型类声明"><a href="#泛型类声明" class="headerlink" title="泛型类声明"></a>泛型类声明</h3><h4 id="系统提供的泛型类"><a href="#系统提供的泛型类" class="headerlink" title="系统提供的泛型类"></a>系统提供的泛型类</h4><p>在java.util包中有集合类的泛型类，比如：Collection、Map。</p><h4 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h4><p>语法结构：class 类名&lt;泛型列表&gt;</p><p>比如：class People&lt;E&gt;</p><p>其中People是泛型类的名称，E是其中的泛型，也就是说我们并没有 指定E是何种类型的数据，它可以是任何类的对象或接口，但不能是基 本类型数据。</p><p>例如：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Cone</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">double</span> height<span class="token punctuation">;</span><span class="token class-name">E</span> bottom<span class="token punctuation">;</span> <span class="token comment">//用泛型类E声明对象bottom</span><span class="token keyword">public</span> <span class="token class-name">Cone</span> <span class="token punctuation">(</span><span class="token class-name">E</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>bottom<span class="token operator">=</span>b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="使用泛型类声明对象"><a href="#使用泛型类声明对象" class="headerlink" title="使用泛型类声明对象"></a>使用泛型类声明对象</h3><p>用泛型类声明和创建对象时，类名后多了一对“&lt;&gt;”， 而且必须要用具体的类型替换“&lt;&gt;”中的泛型。</p><p>比如：Cone&lt;Circle&gt; coneone; </p><p>​            coneone=new Cone&lt;Circle&gt;(new Circle());</p><p>例如：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token punctuation">&#123;</span><span class="token keyword">double</span> area<span class="token punctuation">,</span>radius<span class="token punctuation">;</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token keyword">double</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>radius<span class="token operator">=</span>r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>area<span class="token operator">=</span>radius<span class="token operator">*</span>radius<span class="token operator">*</span><span class="token class-name">Math</span><span class="token punctuation">.</span>PI<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token operator">+</span>area<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example9_1</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Circle</span> circle<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Cone</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Circle</span><span class="token punctuation">></span></span> coneOne<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Cone</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Circle</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>circle<span class="token punctuation">)</span><span class="token punctuation">;</span>coneOne<span class="token punctuation">.</span><span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>coneOne<span class="token punctuation">.</span><span class="token function">computerVolume</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Rect</span> rect<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Rect</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Cone</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Rect</span><span class="token punctuation">></span></span> coneTwo<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Cone</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Rect</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>rect<span class="token punctuation">)</span><span class="token punctuation">;</span>coneTwo<span class="token punctuation">.</span><span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token number">98</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>coneTwo<span class="token punctuation">.</span><span class="token function">computerVolume</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2 | 集合"></a>2 | 集合</h2><ul><li>要实现存储一组对象，通过之前的学习，可以使用对象数组， 但数组长度一旦固定就不可更改。</li><li>集合框架中的类克服了数组的缺点，其容量可以动态改变， 并且不同类型的集合类具有各自的特点。</li></ul><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><h4 id="对象数组-1"><a href="#对象数组-1" class="headerlink" title="对象数组"></a>对象数组</h4><ul><li>数组元素是类的对象，每个元素都是一个对象的引用</li><li>所有元素具有相同的类型</li><li>在Java提供的存储及随机访问对象序列的各种方法中，数组是效率最高的一种</li></ul><h4 id="对象数组初始化"><a href="#对象数组初始化" class="headerlink" title="对象数组初始化"></a>对象数组初始化</h4><ul><li><p>静态初始化：在声明和定义数组的同时对数组元素进行初始化</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Point</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pointArray <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>动态初始化：分两步走：首先为数组分配空间，然后初始化 其中的每个对象</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Point</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pointArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>point<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ul><h4 id="数组的优点"><a href="#数组的优点" class="headerlink" title="数组的优点"></a>数组的优点</h4><p>随机访问对象时最快</p><h4 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h4><p>大小自创建以后就固定了</p><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="1、集合框架"><a href="#1、集合框架" class="headerlink" title="1、集合框架"></a>1、集合框架</h3><ul><li>Java中有很多与集合有关的接口及类，它们被组织在以Collection及 Map接口为根的层次结构中，称为集合框架。</li><li>集合框架中定义了一组可直接使用的具体类，如ArrayList等，它们 各有各自的特点。</li></ul><h3 id="2、集合框架中的接口"><a href="#2、集合框架中的接口" class="headerlink" title="2、集合框架中的接口"></a>2、集合框架中的接口</h3><ul><li>声明了对各种集合类型执行的一般操作</li><li>包括Collection、Set、List、SortedSet、Map、SortedMap</li></ul><h3 id="3、链表"><a href="#3、链表" class="headerlink" title="3、链表"></a>3、链表</h3><h3 id="4、堆栈"><a href="#4、堆栈" class="headerlink" title="4、堆栈"></a>4、堆栈</h3><h3 id="5、散列集"><a href="#5、散列集" class="headerlink" title="5、散列集"></a>5、散列集</h3><h3 id="6、散列映射"><a href="#6、散列映射" class="headerlink" title="6、散列映射"></a>6、散列映射</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Eclipse连接MySQL数据库</title>
    <link href="/2022/05/16/%E4%BD%BF%E7%94%A8Eclipse%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/05/16/%E4%BD%BF%E7%94%A8Eclipse%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="使用Eclipse连接MySQL数据库"><a href="#使用Eclipse连接MySQL数据库" class="headerlink" title="使用Eclipse连接MySQL数据库"></a>使用Eclipse连接MySQL数据库</h2><h3 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h3><h3 id="Eclipse项目-gt-构建路径-gt-库-gt-添加外部JAR"><a href="#Eclipse项目-gt-构建路径-gt-库-gt-添加外部JAR" class="headerlink" title="Eclipse项目 -&gt; 构建路径 -&gt; 库 -&gt; 添加外部JAR"></a>Eclipse项目 -&gt; 构建路径 -&gt; 库 -&gt; 添加外部JAR</h3><blockquote><p>外部JAR为刚刚下载驱动mysql-connector-java-8.0.27中的mysql-connector-java-8.0.27.jar文件</p></blockquote><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/QQ%E6%88%AA%E5%9B%BE20220516103228.png?raw=true" alt="QQ截图20220516103228.png"></p><h3 id="新建数据库-gt-新建表"><a href="#新建数据库-gt-新建表" class="headerlink" title="新建数据库-&gt;新建表"></a>新建数据库-&gt;新建表</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试代码：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*测试Eclipse与MySQL数据库的连接 */</span><span class="token keyword">package</span> <span class="token namespace">student</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Connection</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">DriverManager</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">ResultSet</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Statement</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> testMysqlConnection <span class="token punctuation">&#123;</span><span class="token comment">//url中localhost:3306后面要加的是自己所要连接的数据库名</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student_manage?serverTimezone=GMT"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Connection</span> connect <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Statement</span> stmt <span class="token operator">=</span> connect<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token string">"select * from user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"id:"</span><span class="token operator">+</span>rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"name:"</span><span class="token operator">+</span>rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"pwd:"</span><span class="token operator">+</span>rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>测试成功：输出数据库中的内容</p><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/QQ%E6%88%AA%E5%9B%BE20220516103834.png?raw=true" alt="QQ截图20220516103834.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Java实现简单的区块链</title>
    <link href="/2022/05/14/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <url>/2022/05/14/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。所谓共识机制是区块链系统中实现不同节点之间建立信任、获取权益的数学算法 。</p></blockquote><h2 id="用Java创建区块链"><a href="#用Java创建区块链" class="headerlink" title="用Java创建区块链"></a>用Java创建区块链</h2><p>实现功能</p><ul><li>有很多区块组成用来存储数据</li><li>有数字签名让你的区块链链接在一起</li><li>需要挖矿的工作量证明新的区块</li><li>可以用来检查数据是否是有效的同时是未经篡改的</li></ul><h3 id="创建区块链"><a href="#创建区块链" class="headerlink" title="创建区块链"></a>创建区块链</h3><p>区块链就是一串或者是一系列区块的集合，类似于链表的概念，每个区块都指向于后面一个区块，然后顺序的连接在一起。在区块链中的每一个区块都存放了很多很有价值的信息，区块中内容主要包括三个部分：自己的数字签名，上一个区块的数字签名，还有一切需要加密的数据（这些数据在比特币中就相当于是交易的信息，它是加密货币的本质）。每个数字签名不但证明了自己是特有的一个区块，而且指向了前一个区块的来源，让所有的区块在链条中可以串起来，而数据就是一些特定的信息，可以按照业务逻辑来保存业务数据。</p><p><img src="https://raw.githubusercontent.com/longfeizheng/longfeizheng.github.io/master/images/qukuai/qukuai01.png" alt="区块链示意图"></p><p>这里的hash指的就是数字签名</p><p>所以每一个区块不仅包含前一个区块的hash值，同时包含自身的一个hash值，自身的hash值是通过之前的hash值和数据data通过hash计算出来的。如果前一个区块的数据一旦被篡改了，那么前一个区块的hash值也会同样发生变化（因为数据也被计算在内），这样也就导致了所有后续的区块中的hash值。所以计算和比对hash值会让我们检查到当前的区块链是否是有效的，也就避免了数据被恶意篡改的可能性，因为篡改数据就会改变hash值并破坏整个区块链。</p><p><strong>定义区块链的类快</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Block</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token class-name">String</span> hash<span class="token punctuation">;</span>  <span class="token comment">//当前区块的hash</span><span class="token keyword">public</span> <span class="token class-name">String</span> previousHash<span class="token punctuation">;</span>  <span class="token comment">//前一个区块的hash</span><span class="token keyword">private</span> <span class="token class-name">String</span> data<span class="token punctuation">;</span> <span class="token comment">//当前区块的数据</span><span class="token keyword">private</span> <span class="token keyword">long</span> timeStamp<span class="token punctuation">;</span> <span class="token comment">//区块构造</span><span class="token keyword">public</span> <span class="token class-name">Block</span><span class="token punctuation">(</span><span class="token class-name">String</span> data<span class="token punctuation">,</span><span class="token class-name">String</span> previousHash <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>previousHash <span class="token operator">=</span> previousHash<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>timeStamp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>基本块包含String hash，它将保存我们的数字签名。变量previoushash保存前一个块的hash和String data来保存我们的块数据</p><h3 id="创建数字签名"><a href="#创建数字签名" class="headerlink" title="创建数字签名"></a>创建数字签名</h3><p>区块链存储数据的优点在于数据的加密性，Java方式可以实现的加密方式有很多，如BASE、MD、RSA、SHA等等。选用了SHA256这种加密方式，SHA（Secure Hash Algorithm）安全散列算法，因为这种算法的特点是数据的少量更改会在Hash值中产生不可预知的大量更改，hash值用作表示大量数据的固定大小的唯一值，而SHA256算法的hash值大小为256位。之所以选用SHA256是因为它的大小正合适，一方面产生重复hash值的可能性很小，另一方面在区块链实际应用过程中，有可能会产生大量的区块，而使得信息量很大，那么256位的大小就比较恰当了。</p><p>创建一个StringUtil方法来方便调用SHA256算法</p><blockquote><p>所有的输入调用此方法后均会生成一个独一无二的hash值（数字签名），而这个hash值在区块链中是非常重要的。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">MessageDigest</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringUtil</span> <span class="token punctuation">&#123;</span><span class="token comment">//将Sha256应用于字符串并返回结果</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">applySha256</span><span class="token punctuation">(</span><span class="token class-name">String</span> input<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">MessageDigest</span> digest <span class="token operator">=</span> <span class="token class-name">MessageDigest</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"SHA-256"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将sha256应用到我们的输入</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hash <span class="token operator">=</span> digest<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">StringBuffer</span> hexString <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这将包含哈希十六进制</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> hash<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> hex <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span><span class="token number">0xff</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>hex<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> hexString<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hexString<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>hex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> hexString<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>在Block类中应用 方法 applySha256 方法，其主要的目的就是计算hash值，我们计算的hash值应该包括区块中所有我们不希望被恶意篡改的数据，在我们上面所列的Block类中就一定包括previousHash，data和timeStamp。</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">public String calculateHash() &#123;String calculatedhash &#x3D; StringUtil.applySha256( previousHash +Long.toString(timeStamp) +data );return calculatedhash;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>然后把这个方法加入到Block的构造函数中去</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Block</span><span class="token punctuation">(</span><span class="token class-name">String</span> data<span class="token punctuation">,</span><span class="token class-name">String</span> previousHash <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>previousHash <span class="token operator">=</span> previousHash<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>timeStamp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> <span class="token function">calculateHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//确保我们在设置其他值之后执行此操作</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在主方法中让我们创建一些区块，并把其hash值打印出来。</p><p>第一个块称为创世纪区块，因为它是头区块，所以我们只需输入“0”作为前一个块的previous hash。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockChainTest</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Block</span> genesisBlock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Block</span><span class="token punctuation">(</span><span class="token string">"Hi im the first block"</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hash for block 1 : "</span> <span class="token operator">+</span> genesisBlock<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Block</span> secondBlock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Block</span><span class="token punctuation">(</span><span class="token string">"Yo im the second block"</span><span class="token punctuation">,</span>genesisBlock<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hash for block 2 : "</span> <span class="token operator">+</span> secondBlock<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Block</span> thirdBlock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Block</span><span class="token punctuation">(</span><span class="token string">"Hey im the third block"</span><span class="token punctuation">,</span>secondBlock<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hash for block 3 : "</span> <span class="token operator">+</span> thirdBlock<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/*打印结果值：Hash for block 1: 3d7404e05d96d8060feac1c554db5e06fcf7de65d6926698172f8e63e1c349c0Hash for block 2: afbab7ab1e6c643581378312a4f83a021d0c2a9aa278e9bab83ce8e6eab5c220Hash for block 3: 236206ef1a6534d8e53daaa33b9b6895cdbfbbc3b31fa2a52920207840f44984*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>每一个区块都必须要有自己的数据签名即hash值，这个hash值依赖于自身的信息（data）和上一个区块的数字签名（previousHash），但这个还不是区块链，下面存储区块到数组中，引入gson包，目的是可以用json方式查看整个一条区块链结构。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span></span><span class="token class-name">GsonBuilder</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NoobChain</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Block</span><span class="token punctuation">></span></span> blockchain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Block</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//add our blocks to the blockchain ArrayList:</span>blockchain<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Block</span><span class="token punctuation">(</span><span class="token string">"Hi im the first block"</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>blockchain<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Block</span><span class="token punctuation">(</span><span class="token string">"Yo im the second block"</span><span class="token punctuation">,</span>blockchain<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>blockchain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> blockchain<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Block</span><span class="token punctuation">(</span><span class="token string">"Hey im the third block"</span><span class="token punctuation">,</span>blockchain<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>blockchain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> blockchainJson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPrettyPrinting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>blockchain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockchainJson<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>这样的输出结构就是我们想要的区块链了</p><h3 id="检查区块链的完整性"><a href="#检查区块链的完整性" class="headerlink" title="检查区块链的完整性"></a>检查区块链的完整性</h3><p><strong>检测原因</strong></p><p>我们就在一个主函数中创建区块链中的区块，所以不存在被修改的可能性，但是区块链中的一个核心概念就是去中心化，每一个区块可能是在网络中的某一个节点中产生的，所以很有可能某个节点把自己节点中的数据修改了，那么根据上述的理论数据改变会导致整个区块链的破裂，也就是区块链就无效了。</p><p><strong>检测方法</strong></p><p>在主方法中增加一个isChainValid()方法，目的是循环区块链中的所有区块并且比较hash值，这个方法用来检查hash值是否是于计算出来的hash值相等，同时previousHash值是否和前一个区块的hash值相等。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Boolean</span> <span class="token function">isChainValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Block</span> currentBlock<span class="token punctuation">;</span> <span class="token class-name">Block</span> previousBlock<span class="token punctuation">;</span><span class="token comment">//通过区块链循环检查哈希值</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> blockchain<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>currentBlock <span class="token operator">=</span> blockchain<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>previousBlock <span class="token operator">=</span> blockchain<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//比较注册哈希和计算哈希</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>currentBlock<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>currentBlock<span class="token punctuation">.</span><span class="token function">calculateHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current Hashes not equal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//比较以前的散列和已注册的以前的散列</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>previousBlock<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>currentBlock<span class="token punctuation">.</span>previousHash<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Previous Hashes not equal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>任何区块链中区块的改变都会导致这个函数返回false，也就证明了区块链无效了。</p><h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><p>这里我们要求挖矿者做工作量证明，具体的方式是在区块中尝试不同的参数值直到它的hash值是从一系列的0开始的。让我们添加一个名为nonce的int类型以包含在我们的calculatehash（）方法中，以及需要的mineblock（）方法。</p><p><strong>挖矿结果</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Trying</span> <span class="token keyword">to</span> <span class="token class-name">Mine</span> block <span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token class-name">Block</span> <span class="token class-name">Mined</span><span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span> <span class="token operator">:</span> <span class="token number">00000d</span>c50c2b12ab2a8e73b61289098d9c360292920b66f80989fa8b9d1d0521<span class="token class-name">Trying</span> <span class="token keyword">to</span> <span class="token class-name">Mine</span> block <span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token class-name">Block</span> <span class="token class-name">Mined</span><span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span> <span class="token operator">:</span> <span class="token number">0000093</span>a60840937825f338ff864c8b15106bdb8ea238b41aed80d75b2b51aa1<span class="token class-name">Trying</span> <span class="token keyword">to</span> <span class="token class-name">Mine</span> block <span class="token number">3.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token class-name">Block</span> <span class="token class-name">Mined</span><span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span> <span class="token operator">:</span> <span class="token number">0000000</span>b531c080dcdced198df76b9830dcf77cac4e237346f336f0383e0713a<span class="token class-name">Blockchain</span> is <span class="token class-name">Valid</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>    <span class="token string">"hash"</span><span class="token operator">:</span> <span class="token string">"00000dc50c2b12ab2a8e73b61289098d9c360292920b66f80989fa8b9d1d0521"</span><span class="token punctuation">,</span>    <span class="token string">"previousHash"</span><span class="token operator">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span>    <span class="token string">"data"</span><span class="token operator">:</span> <span class="token string">"first"</span><span class="token punctuation">,</span>    <span class="token string">"timeStamp"</span><span class="token operator">:</span> <span class="token number">1652526937377</span><span class="token punctuation">,</span>    <span class="token string">"nonce"</span><span class="token operator">:</span> <span class="token number">824286</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    <span class="token string">"hash"</span><span class="token operator">:</span> <span class="token string">"0000093a60840937825f338ff864c8b15106bdb8ea238b41aed80d75b2b51aa1"</span><span class="token punctuation">,</span>    <span class="token string">"previousHash"</span><span class="token operator">:</span> <span class="token string">"00000dc50c2b12ab2a8e73b61289098d9c360292920b66f80989fa8b9d1d0521"</span><span class="token punctuation">,</span>    <span class="token string">"data"</span><span class="token operator">:</span> <span class="token string">"second"</span><span class="token punctuation">,</span>    <span class="token string">"timeStamp"</span><span class="token operator">:</span> <span class="token number">1652526938380</span><span class="token punctuation">,</span>    <span class="token string">"nonce"</span><span class="token operator">:</span> <span class="token number">1073541</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    <span class="token string">"hash"</span><span class="token operator">:</span> <span class="token string">"0000000b531c080dcdced198df76b9830dcf77cac4e237346f336f0383e0713a"</span><span class="token punctuation">,</span>    <span class="token string">"previousHash"</span><span class="token operator">:</span> <span class="token string">"0000093a60840937825f338ff864c8b15106bdb8ea238b41aed80d75b2b51aa1"</span><span class="token punctuation">,</span>    <span class="token string">"data"</span><span class="token operator">:</span> <span class="token string">"third"</span><span class="token punctuation">,</span>    <span class="token string">"timeStamp"</span><span class="token operator">:</span> <span class="token number">1652526939678</span><span class="token punctuation">,</span>    <span class="token string">"nonce"</span><span class="token operator">:</span> <span class="token number">1844033</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="用Java创建可交易的区块链"><a href="#用Java创建可交易的区块链" class="headerlink" title="用Java创建可交易的区块链"></a>用Java创建可交易的区块链</h2><p>实现功能</p><ul><li>创建一个简单的钱包</li><li>使用我们的区块链发送带签名的交易</li></ul><blockquote><p>创建一个基本的区块链后，但在区块链中存放的是一些无用的信息。用交易取代这些信息（我们的区块将能够保存多个交易），创建一个非常简单的加密货币,货币名字NoobCoin。</p><ul><li>导入 bounceycastle和GSON</li></ul></blockquote><h3 id="准备一个钱包"><a href="#准备一个钱包" class="headerlink" title="准备一个钱包"></a>准备一个钱包</h3><p>在加密货币中，在区块链作为交易时，货币所有权可以进行转移，每个参与者都有一个自己私有的地址来发送或者是收取货币。钱包可以存储这些地址。因此钱包就是可以在区块链上进行新交易的软件。类似于微信支付。</p><p><img src="https://raw.githubusercontent.com/longfeizheng/longfeizheng.github.io/master/images/qukuai/qukuai02.png"></p><p>创建一个钱包类来保存公钥和私钥：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">package noobchain;import java.security.*;public class Wallet &#123;public PrivateKey privateKey;public PublicKey publicKey;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>公钥和私钥究竟是起到什么作用呢，其实公钥的作用就是地址，你可以分享你的公钥给别人以此来获取付款，而你的私钥的作用是为了对交易进行签名，这样其他人就不可以花费你的金额除非它拥有你的私钥，所以对于每个人而言我们必须保护好我们的私钥，不能透露我们的私钥信息给其他人。同时在我们进行交易的时候我们也会同时发送我们的公钥由此来验证我们的签名是有效的而且没有数据被篡改。（可以理解为收款码和付款码）</p></blockquote><p>我们在密钥对KeyPair生成私有和公钥。我们将使用椭圆曲线加密来生成我们的密钥对KeyPair。让我们将generateKeyPair()方法添加到我们的钱包类中，并在构造函数中调用它:</p><blockquote><p>私钥用于签署我们不想被篡改的数据。公钥用于验证签名。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">noobchain</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wallet</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token class-name">PrivateKey</span> privateKey<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">PublicKey</span> publicKey<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Wallet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">generateKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">generateKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">KeyPairGenerator</span> keyGen <span class="token operator">=</span> <span class="token class-name">KeyPairGenerator</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"ECDSA"</span><span class="token punctuation">,</span><span class="token string">"BC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SecureRandom</span> random <span class="token operator">=</span> <span class="token class-name">SecureRandom</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"SHA1PRNG"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ECGenParameterSpec</span> ecSpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ECGenParameterSpec</span><span class="token punctuation">(</span><span class="token string">"prime192v1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化密钥生成器并生成KeyPair</span>keyGen<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span>ecSpec<span class="token punctuation">,</span> random<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//256字节提供了可接受的安全级别</span>        <span class="token class-name">KeyPair</span> keyPair <span class="token operator">=</span> keyGen<span class="token punctuation">.</span><span class="token function">generateKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 从keyPair设置公钥和私钥</span>        privateKey <span class="token operator">=</span> keyPair<span class="token punctuation">.</span><span class="token function">getPrivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        publicKey <span class="token operator">=</span> keyPair<span class="token punctuation">.</span><span class="token function">getPublic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="交易和数字签名"><a href="#交易和数字签名" class="headerlink" title="交易和数字签名"></a>交易和数字签名</h3><p>每笔交易将携带一定以下信息：</p><ol><li>资金付款人的公匙信息。</li><li>资金收款人的公匙信息。</li><li>被转移资金的金额。</li><li>输入，它是对以前的交易的引用，证明发送者有资金发送。</li><li>输出，显示交易中收款方相关地址数量。(这些输出被引用为新交易的输入)</li><li>一个加密签名，证明该交易是由地址的发送者是发送的，并且数据没有被更改。(阻止第三方机构更改发送的数量)</li></ol><p>创建这个新的交易类：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token class-name">String</span> transactionId<span class="token punctuation">;</span> <span class="token comment">// 包含事物的哈希</span><span class="token keyword">public</span> <span class="token class-name">PublicKey</span> sender<span class="token punctuation">;</span> <span class="token comment">// 付款人地址/公钥</span><span class="token keyword">public</span> <span class="token class-name">PublicKey</span> reciepient<span class="token punctuation">;</span> <span class="token comment">// 收款人地址/公钥</span><span class="token keyword">public</span> <span class="token keyword">float</span> value<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> signature<span class="token punctuation">;</span> <span class="token comment">// 防止其他人花我们钱包里的钱</span><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TransactionInput</span><span class="token punctuation">></span></span> inputs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TransactionInput</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TransactionOutput</span><span class="token punctuation">></span></span> outputs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TransactionOutput</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> sequence <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 生成了多少事务的粗略统计</span><span class="token comment">// 构造: </span><span class="token keyword">public</span> <span class="token class-name">Transaction</span><span class="token punctuation">(</span><span class="token class-name">PublicKey</span> from<span class="token punctuation">,</span> <span class="token class-name">PublicKey</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">float</span> value<span class="token punctuation">,</span>  <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TransactionInput</span><span class="token punctuation">></span></span> inputs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>sender <span class="token operator">=</span> from<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>reciepient <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>inputs <span class="token operator">=</span> inputs<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 计算事务散列(将用作其Id)</span><span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">calulateHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sequence<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//增加序列以避免两个相同的事务具有相同的散列</span><span class="token keyword">return</span> <span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">applySha256</span><span class="token punctuation">(</span><span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">getStringFromKey</span><span class="token punctuation">(</span>sender<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">getStringFromKey</span><span class="token punctuation">(</span>reciepient<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">+</span> sequence<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="测试钱包和签名"><a href="#测试钱包和签名" class="headerlink" title="测试钱包和签名"></a>测试钱包和签名</h3><p>简单的进行一些测试，在主方法中增加了一些新的变量也替换了之前在主方法中的一些内容。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">Security</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Base64</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span></span><span class="token class-name">GsonBuilder</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NoobChain</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Block</span><span class="token punctuation">></span></span> blockchain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Block</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> difficulty <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Wallet</span> walletA<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Wallet</span> walletB<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//将block添加到区块链数组列表中</span><span class="token class-name">Security</span><span class="token punctuation">.</span><span class="token function">addProvider</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>bouncycastle<span class="token punctuation">.</span>jce<span class="token punctuation">.</span>provider<span class="token punctuation">.</span></span>BouncyCastleProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建钱包A和B</span>walletA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Wallet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>walletB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Wallet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//测试公钥和私钥</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Private and public keys:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">getStringFromKey</span><span class="token punctuation">(</span>walletA<span class="token punctuation">.</span>privateKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">getStringFromKey</span><span class="token punctuation">(</span>walletA<span class="token punctuation">.</span>publicKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个从A钱包到B钱包交易的测试</span><span class="token class-name">Transaction</span> transaction <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transaction</span><span class="token punctuation">(</span>walletA<span class="token punctuation">.</span>publicKey<span class="token punctuation">,</span> walletB<span class="token punctuation">.</span>publicKey<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>transaction<span class="token punctuation">.</span><span class="token function">generateSignature</span><span class="token punctuation">(</span>walletA<span class="token punctuation">.</span>privateKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//验证签名工作，并从公钥验证它</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Is signature verified"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>transaction<span class="token punctuation">.</span><span class="token function">verifiySignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>接下来我们将创建并验证输入和输出，并把交易保存到区块链中去。</p><h3 id="输入和输出1：如何验证货币是你的"><a href="#输入和输出1：如何验证货币是你的" class="headerlink" title="输入和输出1：如何验证货币是你的"></a>输入和输出1：如何验证货币是你的</h3><p>如果你拥有1比特币，你必须前面就得接收1比特币。比特币的账本不会在你的账户中增加一个比特币也不会从发送者那里减去一个比特币，发送者只能指向他/她之前收到过一个比特币，所以一个交易输出被创建用来显示一个比特币发送给你的地址（交易的输入指向前一个交易的输出）。</p><p><strong>你的钱包余额是所有未使用的交易输出的总和</strong></p><p>创建TransactionInput 类：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionInput</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token class-name">String</span> transactionOutputId<span class="token punctuation">;</span> <span class="token comment">//Reference to TransactionOutputs -> transactionId</span><span class="token keyword">public</span> <span class="token class-name">TransactionOutput</span> UTXO<span class="token punctuation">;</span> <span class="token comment">//Contains the Unspent transaction output</span><span class="token keyword">public</span> <span class="token class-name">TransactionInput</span><span class="token punctuation">(</span><span class="token class-name">String</span> transactionOutputId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>transactionOutputId <span class="token operator">=</span> transactionOutputId<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>这个类将用于引用尚未使用的transactionoutput。transactionOutputId将用于查找相关的TransactionOutput，允许矿工检查您的所有权。</p></blockquote><p>创建TransactionOutputs类：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">PublicKey</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionOutput</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token class-name">String</span> id<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">PublicKey</span> reciepient<span class="token punctuation">;</span> <span class="token comment">//钱的接收者</span><span class="token keyword">public</span> <span class="token keyword">float</span> value<span class="token punctuation">;</span> <span class="token comment">//拥有钱的数量</span><span class="token keyword">public</span> <span class="token class-name">String</span> parentTransactionId<span class="token punctuation">;</span> <span class="token comment">//创建此输出的事务的id</span><span class="token comment">//构造</span><span class="token keyword">public</span> <span class="token class-name">TransactionOutput</span><span class="token punctuation">(</span><span class="token class-name">PublicKey</span> reciepient<span class="token punctuation">,</span> <span class="token keyword">float</span> value<span class="token punctuation">,</span> <span class="token class-name">String</span> parentTransactionId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>reciepient <span class="token operator">=</span> reciepient<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>parentTransactionId <span class="token operator">=</span> parentTransactionId<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">applySha256</span><span class="token punctuation">(</span><span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">getStringFromKey</span><span class="token punctuation">(</span>reciepient<span class="token punctuation">)</span><span class="token operator">+</span><span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token operator">+</span>parentTransactionId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//检查钱是否属于你</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMine</span><span class="token punctuation">(</span><span class="token class-name">PublicKey</span> publicKey<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>publicKey <span class="token operator">==</span> reciepient<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>交易输出类将显示从交易中发送给每一方的最终金额。这些作为新交易中的输入参考，作为证明你可以发送的金额数量。</p><h3 id="输入和输出2：处理交易"><a href="#输入和输出2：处理交易" class="headerlink" title="输入和输出2：处理交易"></a>输入和输出2：处理交易</h3><p>区块链可能会收到很多交易，而区块链可能会非常长，因为必须查找并检查其输入，所以可能需要非常长的时间来处理新的交易。为了解决这个问题，我们保存了一个额外的集合称之为为使用的交易作为可用的输入,所以在主函数中增加一个集合称为UTXO。</p><p>在交易类中增加一个processTransaction方法，这个方法是把一切放在一起用来处理交易。</p><p>通过这种方法，我们执行一些检查以确保交易有效，然后收集输入并生成输出。最重要的是，最后，我们抛弃了输入在我们的UTXO列表，这就意味着一个可以使用的交易输出必须之前一定是输入，所以输入的值必须被完全使用，所以付款人必须改变它们自身的金额状态。</p><h3 id="添加交易到区块中"><a href="#添加交易到区块中" class="headerlink" title="添加交易到区块中"></a>添加交易到区块中</h3><p>现在已经有了一个有效的交易系统，需要把交易加入到我们的区块链中。把交易列表替换我们块中无用的数据，但是在一个单一的区块中可能存放了1000个交易，这就会导致大量的hash计算，在这里我们使用了交易的merkle root，增加一个帮助方法来创建merkle root在StringUtils类中。</p><p>在StringUtils类中创建getMerkleRoot方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getMerkleRoot</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Transaction</span><span class="token punctuation">></span></span> transactions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> count <span class="token operator">=</span> transactions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> previousTreeLayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Transaction</span> transaction <span class="token operator">:</span> transactions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>previousTreeLayer<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>transaction<span class="token punctuation">.</span>transactionId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> treeLayer <span class="token operator">=</span> previousTreeLayer<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>treeLayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> previousTreeLayer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>treeLayer<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">applySha256</span><span class="token punctuation">(</span>previousTreeLayer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> previousTreeLayer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>count <span class="token operator">=</span> treeLayer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>previousTreeLayer <span class="token operator">=</span> treeLayer<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">String</span> merkleRoot <span class="token operator">=</span> <span class="token punctuation">(</span>treeLayer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> treeLayer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">return</span> merkleRoot<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>修改Block类，需要注意的是还更新了Block构造函数，因为我们不再需要传递字符串数据，并将merkle root包含在计算哈希方法中。addTransaction方法用来增加交易，只有满足条件下才可以成功的在区块中增加交易。</p><p>实现了一个可交易的区块链。</p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>应该测试从钱包发送货币，更新区块链并进行有效性检查。但首先需要一种将新硬币引入混合的方法。有很多方法来创建新的硬币。在比特币区块链上，有很多方法可以创造新的比特币:矿工可以将交易包括在内，作为对每个矿工挖矿的奖励。但在这里我们只希望在创世纪区块中释放货币。就像比特币中一下，所以我们修改我们的主函数以达到下面的目的。</p><ol><li>创世纪区块发布100个货币给walletA</li><li>一个更新的链有效性检查，考虑到交易。</li><li>测试交易看是否一切正常。</li></ol><p>交易结果：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Creating</span> and <span class="token class-name">Mining</span> <span class="token class-name">Genesis</span> block<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token class-name">Transaction</span> <span class="token class-name">Successfully</span> added <span class="token keyword">to</span> <span class="token class-name">Block</span><span class="token class-name">Block</span> <span class="token class-name">Mined</span><span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span> <span class="token operator">:</span> <span class="token number">0002</span>eb314ecaaeeb77ffd7f83d90ce7dc197dadd2ca5484bebd225bf6b81d3fc<span class="token class-name">WalletA</span>'s balance is<span class="token operator">:</span> <span class="token number">100.0</span><span class="token class-name">WalletA</span> is <span class="token class-name">Attempting</span> <span class="token keyword">to</span> <span class="token namespace">send</span> funds <span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token keyword">to</span> <span class="token class-name">WalletB</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token class-name">Transaction</span> <span class="token class-name">Successfully</span> added <span class="token keyword">to</span> <span class="token class-name">Block</span><span class="token class-name">Block</span> <span class="token class-name">Mined</span><span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span> <span class="token operator">:</span> <span class="token number">000</span>a29ee3221960020a4f382e728b08b02f1dcf6707bcc8a1499e29c3c03adf8<span class="token class-name">WalletA</span>'s balance is<span class="token operator">:</span> <span class="token number">60.0</span><span class="token class-name">WalletB</span>'s balance is<span class="token operator">:</span> <span class="token number">40.0</span><span class="token class-name">WalletA</span> <span class="token class-name">Attempting</span> <span class="token keyword">to</span> <span class="token namespace">send</span> more funds <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> than it has<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>#<span class="token class-name">Not</span> <span class="token class-name">Enough</span> funds <span class="token keyword">to</span> <span class="token namespace">send</span> <span class="token class-name"><span class="token namespace">transaction<span class="token punctuation">.</span></span> Transaction</span> <span class="token class-name">Discarded<span class="token punctuation">.</span>Block</span> <span class="token class-name">Mined</span><span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span> <span class="token operator">:</span> <span class="token number">0008917</span>b5fc51ea7eb74dd6295c20b744cd8d4f90db2fb4fd627c6c47eb7583a<span class="token class-name">WalletA</span>'s balance is<span class="token operator">:</span> <span class="token number">60.0</span><span class="token class-name">WalletB</span>'s balance is<span class="token operator">:</span> <span class="token number">40.0</span><span class="token class-name">WalletB</span> is <span class="token class-name">Attempting</span> <span class="token keyword">to</span> <span class="token namespace">send</span> funds <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">to</span> <span class="token class-name">WalletA</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token class-name">Transaction</span> <span class="token class-name">Successfully</span> added <span class="token keyword">to</span> <span class="token class-name">Block</span><span class="token class-name">WalletA</span>'s balance is<span class="token operator">:</span> <span class="token number">80.0</span><span class="token class-name">WalletB</span>'s balance is<span class="token operator">:</span> <span class="token number">20.0</span><span class="token class-name">Blockchain</span> is valid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>现在钱包能够安全地在您的区块链上发送金额，只要他们有金额发送。这意味着你有你自己的本地加密货币.</p><h3 id="完整的可以进行交易的区块链"><a href="#完整的可以进行交易的区块链" class="headerlink" title="完整的可以进行交易的区块链"></a>完整的可以进行交易的区块链</h3><p>成功地创建了自己的加密货币。完整的可以进行交易的区块链功能实现：</p><ul><li>允许用户创建钱包</li><li>使用椭圆曲线加密方式为钱包提供公钥和私钥</li><li>通过使用数字签名算法证明所有权，确保资金转移</li><li>允许用户在区块链上进行交易</li></ul><p>参考博客：</p><ul><li><a href="https://niocoder.com/2018/03/10/%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE-part1/">https://niocoder.com/2018/03/10/%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE-part1/</a></li><li><a href="https://niocoder.com/2018/03/11/%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE-part2/">https://niocoder.com/2018/03/11/%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE-part2/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2022/05/12/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/05/12/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>滑动窗口是一种基于双指针的一种思想，两个指针指向的元素之间形成一个窗口。</p><p><strong>分类：</strong>窗口有两类，一种是固定大小类的窗口，一类是大小动态变化的窗口。</p><p><strong>应用：</strong>什么情况可以用滑动窗口来解决实际问题呢？</p><ul><li>一般给出的数据结构是数组或者字符串</li><li>求取某个子串或者子序列最长最短等最值问题或者求某个目标值时</li><li>该问题本身可以通过暴力求解</li></ul><h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><p><strong>窗口的形成</strong></p><p>在具体使用之前，我们知道窗口实际是两个指针之间形成的区域，那关键就是这两个指针是如何移动的。</p><ol><li>初始时，左右指针left,right都指向第0个元素，窗口为[left,right)，注意这里是左闭右开，因此初始窗口[0,0)区间没有元素，符合我们的初始定义</li><li>开始循环遍历整个数组元素，判断当前right指针是否超过整个数组的长度，是退出循环，否则执行第3步</li><li>然后right指针开始向右移动一个长度，并更新窗口内的区间数据</li><li>当窗口区间的数据满足我们的要求时，右指针right就保持不变，左指针left开始移动，直到移动到一个不再满足要求的区间时，left不再移动位置</li><li>执行第2步</li></ol><p>这中间，窗口的更新与维护是很重要的一环，新元素加入窗口，旧元素移出窗口，都需要及时地更新与这个窗口范围相关的数据。</p><p>上述说明主要是两个while循环，可以简单抽象成一个模板如下：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int left &#x3D; 0,right &#x3D;0;while(right指针未越界)&#123;  char ch &#x3D; arr[right++];  &#x2F;&#x2F;右指针移动，更新窗口  ...    &#x2F;&#x2F;窗口数据满足条件 对于固定窗口而言，就是窗口的大小&gt;&#x3D;固定值；对于动态窗口，就是从left出发，窗口不断扩充，第一次满足题意的位置  while(窗口数据满足条件)&#123;   &#x2F;&#x2F;记录或者更新全局数据   ...      &#x2F;&#x2F;右指针不动，左指针开始移动一位   char tmp &#x3D; arr[left++];      &#x2F;&#x2F;左指针移动，窗口缩小，更新窗口数据   ...  &#125;  &#x2F;&#x2F;返回结果  ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/422908736">https://zhuanlan.zhihu.com/p/422908736</a></li><li><a href="https://zhuanlan.zhihu.com/p/63239291">https://zhuanlan.zhihu.com/p/63239291</a></li><li><a href="https://zhuanlan.zhihu.com/p/110241099">https://zhuanlan.zhihu.com/p/110241099</a></li></ul><p>相关题目：</p><ul><li>LeetCode 3：无重复字符的最长子串（难度：中等 已做）</li><li>LeetCode 209：长度最小的子数组（难度：中等 已做）</li></ul><h2 id="Bilibili滑动窗口学习笔记"><a href="#Bilibili滑动窗口学习笔记" class="headerlink" title="Bilibili滑动窗口学习笔记"></a>Bilibili滑动窗口学习笔记</h2><h4 id="算法应用场景："><a href="#算法应用场景：" class="headerlink" title="算法应用场景："></a>算法应用场景：</h4><p>关键字：</p><p>满足XXX条件（计算结果，出现次数，同时包含）</p><p>最长/最短</p><p>子串/子数组/子序列</p><p>例如：长度最小的子数组</p><h4 id="滑动窗口使用思路（寻找最长）"><a href="#滑动窗口使用思路（寻找最长）" class="headerlink" title="滑动窗口使用思路（寻找最长）"></a>滑动窗口使用思路（寻找最长）</h4><p>核心：左右双指针（L，R）在起始点，R向右逐位滑动循环</p><p>每次滑动过程中</p><ul><li>如果窗内元素满足条件，R向右扩大窗口，并更新最优结果</li><li>如果窗内元素不满足条件，L向右缩小窗口</li></ul><p>直至R到达结尾</p><p>代码模板</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;最长模板&#x2F;&#x2F;初始化left right result bestResultwhile(右指针没有到达结尾)&#123;    窗口扩大，加入right对应元素，更新当前result    while(result不满足要求)    &#123;        窗口缩小，移除left对应元素，left右移    &#125;    更新最优结果bestResult    right++;&#125;返回bestResult;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="滑动窗口使用思路（寻找最短）"><a href="#滑动窗口使用思路（寻找最短）" class="headerlink" title="滑动窗口使用思路（寻找最短）"></a>滑动窗口使用思路（寻找最短）</h4><p>核心：左右双指针（L，R）在起始点，R向右逐位滑动循环</p><p>每次滑动过程中</p><ul><li>如果窗内元素满足条件，L向右缩小窗口 ，并更新最优结果</li><li>如果窗内元素不满足条件，R向右扩大窗口</li></ul><p>直至R到达结尾</p><p>代码模板：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;最短模板&#x2F;&#x2F;初始化left right result bestResultwhile(右指针没有到达结尾)&#123;    窗口扩大，加入right对应元素，更新当前result    while(result满足要求)    &#123;        更新最优结果bestResult        窗口缩小，移除left对应元素，left右移    &#125;    right++;&#125;返回bestResult;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="LeetCode-713：乘积小于-K-的子数组"><a href="#LeetCode-713：乘积小于-K-的子数组" class="headerlink" title="LeetCode 713：乘积小于 K 的子数组"></a>LeetCode 713：乘积小于 K 的子数组</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>这道题是一道典型的滑动窗口问题。</p><blockquote><p>溢出问题：</p><p>double与int类型的存储机制不同，long int的8个字节全部都是数据位，⽽double是以尾数，底数，指数的形式表⽰的，类似科学计数法，<br>因此double⽐int能表⽰的数据范围更⼴。double的范围也是要大于long long int的范围的。</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。</p><blockquote><p>输入：nums = [10,5,2,6], k = 100<br>输出：8<br>解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。<br>需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123;        int ans &#x3D; 0;        int l &#x3D; 0,r &#x3D; 0;        int cur &#x3D; 1;        while(l&lt;&#x3D;r &amp;&amp; r&lt;nums.size())        &#123;            cur &#x3D; cur*nums[r];            while(l &lt;&#x3D; r &amp;&amp; cur &gt;&#x3D; k)            &#123;                cur &#x3D; cur&#x2F;nums[l];                l++;            &#125;            ans &#x3D; ans+(r-l+1);            r++;        &#125;        return ans;    &#125;&#125;;&#x2F;*[10][10,5] [5][5,2] [2][5,2,6] [2,6] [6]*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>待续……..</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.11每日一题</title>
    <link href="/2022/05/11/5-11%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <url>/2022/05/11/5-11%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-449：序列化和反序列化二叉搜索树"><a href="#LeetCode-449：序列化和反序列化二叉搜索树" class="headerlink" title="LeetCode 449：序列化和反序列化二叉搜索树"></a>LeetCode 449：序列化和反序列化二叉搜索树</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>差点AC代码（62个测试样例过了61个 最后一个测试样例超时了🤣）</p><p>改了好久都不理解为什么代码最后一个测试样例会超时（代码的复杂度也不高啊！！！题目给的数据也不大诶）</p><p>算算了 代码不重要 重要的是理解这题的思路和解法</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p>示例1：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [2,1,3]输出：[2,1,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题就是二叉搜索树转换来转换去最后又转换回二叉搜索树，大致过程如下：</p><ol><li>二叉搜索树利用队列转化成字符串string</li><li>string转换成vector容器</li><li>vector容器利用队列重新建成二叉搜索树</li></ol><p>差点AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Codec &#123;public:    &#x2F;&#x2F; Encodes a tree to a single string.    string serialize(TreeNode* root) &#123;        string ans &#x3D; &quot;&quot;;        if(root &#x3D;&#x3D; nullptr)  return ans;        queue&lt;TreeNode*&gt; q;        q.push(root);        while(!q.empty())        &#123;            auto node &#x3D; q.front();            q.pop();            if(node &#x3D;&#x3D; nullptr)            &#123;                ans &#x3D; ans+&quot;null,&quot;;            &#125;else&#123;                ans &#x3D; ans+to_string(node-&gt;val)+&quot;,&quot;;                q.push(node-&gt;left);                q.push(node-&gt;right);            &#125;        &#125;        return ans;    &#125;    &#x2F;&#x2F; Decodes your encoded data to tree.    TreeNode* deserialize(string data) &#123;        if(data &#x3D;&#x3D; &quot;&quot;)  return nullptr;        vector&lt;string&gt; temp &#x3D; split(data);        TreeNode* root &#x3D; new TreeNode(stoi(temp[0]));  &#x2F;&#x2F;TreeNode(int)        queue&lt;TreeNode*&gt; q;        q.push(root);        int index &#x3D; 1;        while(!q.empty())        &#123;            auto node &#x3D; q.front();            q.pop();            if(temp[index] !&#x3D; &quot;null&quot;)            &#123;                node-&gt;left &#x3D; new TreeNode(stoi(temp[index]));                q.push(node-&gt;left);            &#125;            index++;            if(temp[index] !&#x3D; &quot;null&quot;)            &#123;                node-&gt;right &#x3D; new TreeNode(stoi(temp[index]));                q.push(node-&gt;right);            &#125;            index++;        &#125;        return root;    &#125;    vector&lt;string&gt; split(string data)    &#123;        vector&lt;string&gt; ans;        int from &#x3D; 0;        for(int i&#x3D;0; i&lt;data.size(); i++)        &#123;            if(data[i] &#x3D;&#x3D; &#39;,&#39;)            &#123;                ans.push_back(data.substr(from,i-from));  &#x2F;&#x2F;Note:第二个参数为复制长度而不是字符串结束位置                from &#x3D; i+1;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补5.3每日一题 字符串排序</title>
    <link href="/2022/05/10/%E8%A1%A55-3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/10/%E8%A1%A55-3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-937：重新排列日志文件"><a href="#LeetCode-937：重新排列日志文件" class="headerlink" title="LeetCode 937：重新排列日志文件"></a>LeetCode 937：重新排列日志文件</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>力扣难度：简单 写简单题题解是因为通过这道题补了很多知识。C++匿名函数，C++稳定排序，自定义排序函数。</p></blockquote><h4 id="C-匿名函数"><a href="#C-匿名函数" class="headerlink" title="C++匿名函数"></a>C++匿名函数</h4><p><strong>匿名函数</strong></p><p>C++中的匿名函数，类似于python的lambda函数，也就是在句中定义和声明的一个临时函数，仅在调用时才会创建函数对象，无需在头文件中声明。</p><p><strong>函数形式</strong></p><p>[capture](parameters)-&gt;return-type{body} </p><p>捕获列表-&gt;返回类型-{函数主体}</p><p>capture：捕获列表</p><ul><li>[]    //捕获列表为空。在函数内无法使用外部变量。</li><li>[a]   //捕获列表为按值传递形式。在函数内仅能使用传递的变量值，无法改变变量。值在匿名函数生成时便已经确定，后续修改不会影响函数内的变量值。</li><li>[&amp;a]  //按应用传递。可改变变量。</li></ul><p>return-type：返回类型</p><p>一般情况下编译器可以推断出返回类型，可以用auto而不指定返回类型。但有多个return语句时需要指定返回类型。</p><p><strong>函数例子</strong></p><p>1.与sort()函数等参数中可传入函数的方法等搭配（也就是该题目中用的）</p><blockquote><p>匿名函数：格式[](){}，可以理解为中括号里面是函数名  [&amp;]代表没有名字，小括号里面是传入的参数。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;pair&lt;int,int&gt;&gt; costs;&#x2F;&#x2F;costs的每个元素是由价值与编号组成的pairsort(costs.begin(), costs.end(), [&amp;](const auto &amp; a, const auto &amp; b)    &#123;        if (a.first !&#x3D; b.first)            return a.first &gt; b.first;&#x2F;&#x2F;价值不同时，价值大的优先        else            return a.second &lt; b.second;&#x2F;&#x2F;价值相同时，标号小的优先    &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>这种方法等价于</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;pair&lt;int,int&gt;&gt; costs;auto compare &#x3D; [&amp;](const auto&amp; a,const auto&amp; b )&#123;        if (a.first !&#x3D; b.first)            return a.first &gt; b.first;&#x2F;&#x2F;价值不同时，价值大的优先        else            return a.second &lt; b.second;&#x2F;&#x2F;价值相同时，标号小的优先&#125;sort(costs.begin(),costs.end(),compare);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>2.直接写在main函数中，与inline函数相似。</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int main()&#123;    int x&#x3D;1,y&#x3D;2,z&#x3D;0;    auto add &#x3D; [&amp;z](auto x,auto y)&#123;z&#x3D;x+y;return z;&#125;;    auto res &#x3D; add(x,y);    cout&lt;&lt;res&lt;&lt;z&lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="C-稳定排序"><a href="#C-稳定排序" class="headerlink" title="C++稳定排序"></a>C++稳定排序</h4><p>C++ 稳定排序函数：stable_sort()</p><ul><li><p>当指定范围内包含多个相等的元素时，sort() 排序函数无法保证不改变它们的相对位置。那么，如果既要完成排序又要保证相等元素的相对位置，该怎么办呢？可以使用 stable_sort() 函数。</p></li><li><p>stable_sort() 函数完全可以看作是 sort() 函数在功能方面的升级版。换句话说，stable_sort() 和 sort() 具有相同的使用场景，就连语法格式也是相同的，只不过前者在功能上除了可以实现排序，还可以保证不改变相等元素的相对位置。</p></li><li><p> sort() 函数一样，实现 stable_sort() 的函数模板也位于&lt;algorithm&gt;头文件中</p></li><li><p>table_sort() 函数的用法也有 2 种，其语法格式和 sort() 函数完全相同（仅函数名不同）</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;对 [first, last) 区域内的元素做默认的升序排序void stable_sort ( RandomAccessIterator first, RandomAccessIterator last );&#x2F;&#x2F;按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序void stable_sort ( RandomAccessIterator first, RandomAccessIterator last, Compare comp );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>first 和 last 都为随机访问迭代器，它们的组合 [first, last) 用来指定要排序的目标区域</p></li></ul><h4 id="自定义排序函数"><a href="#自定义排序函数" class="headerlink" title="自定义排序函数"></a>自定义排序函数</h4><p> <strong>C++中sort自定义排序</strong></p><ul><li><p><strong>sort简介</strong></p><ul><li>用于C++中，对给定区间所有元素进行排序</li><li>使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)，执行效率较高</li><li>头文件 #include &lt;algorithm&gt;</li></ul></li><li><p><strong>sort使用方法</strong></p><p>sort函数有三个参数</p><p>sort(first,last,cmp);</p><p>其中，first是元素的起始地址，last是结束地址，cmp是排序的方式。对[first，last)（一定要注意这里的区间是左闭又开）区间内数据根据cmp的方式进行排序。也可以不写第三个参数，此时按默认排序，从小到大进行排序。</p></li><li><p><strong>自定义排序</strong></p><ul><li><p>自定义比较函数cmp</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool  cmp(int a,int b)&#123;        return b&lt;a;&#125;sort(a,a+n,cmp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>传入的参数类型和需要排序的数据类型一致，如果认为第一个参数比第二个小，也就是第一个参数需要排在第二个参数前面时返回true，反之返回 false。系统默认a&lt;b时返回true，于是从小到大排。而上面的例子是当b小于a时，认为a小于b。所以排序的结果就是将元素按从大到小的顺序排序。</p></li><li><p>重载比较运算符”&lt;”</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool operator&lt; (const Student&amp; s1, const Student&amp; s2)&#123;        if(s1.age&#x3D;&#x3D;s2.age)                return s1.name &lt;s2.name;&#x2F;&#x2F;年龄相同时，按姓名小到大排        else  return s1.age &gt; s2.age; &#x2F;&#x2F;从年龄大到小排序&#125;sort(a,a+n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>Note：参数类型如果是自定义类型，比如自己定义的结构体、类，尽管sort函数默认是从小到大排列，但是这里必须要重载比较运算符”&lt;”</p><p>和cmp函数同理，如果认为第一个参数比第二个小就返回true，反之返回 false。</p></li><li><p>声明比较类</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct cmp&#123;       bool operator() (const Student&amp; s1, const Student&amp; s2)       &#123;              if(s1.age&#x3D;&#x3D;s2.age)                     return s1.name &lt;s2.name;              else  return s1.age &lt; s2.age;        &#125;&#125;;sort(a,a+n,cmp());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>还是同理，如果认为第一个参数比第二个小就返回true，反之返回 false。</p></li></ul></li></ul><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode.cn/problems/reorder-data-in-log-files/">https://leetcode.cn/problems/reorder-data-in-log-files/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先对日志文件进行预处理，将字母日志和数字日志分别存储在容器digit和容器alpha中，再用匿名函数对字母日志进行排序。再将排序后的日志文件合并，返回结果。</p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;string&gt; reorderLogFiles(vector&lt;string&gt;&amp; logs) &#123;        vector&lt;string&gt; digit;        vector&lt;string&gt; alpha;        for(const auto str : logs)        &#123;            char c &#x3D; str.back();  &#x2F;&#x2F;返回字符串最后一个字符            if(isdigit(c))  digit.push_back(str);            else  alpha.push_back(str);        &#125;        sort(alpha.begin(),alpha.end(),[&amp;](const string &amp;log1,const string &amp;log2)&#123;  &#x2F;&#x2F;lambda匿名函数            int pos1 &#x3D; log1.find(&#39; &#39;);  &#x2F;&#x2F;返回第一次出现&#39; &#39;的位置下标            int pos2 &#x3D; log2.find(&#39; &#39;);            string s1 &#x3D; log1.substr(pos1);  &#x2F;&#x2F;从下标pos1处开始复制字符串log1            string s2 &#x3D; log2.substr(pos2);            if(s1 !&#x3D; s2)            &#123;                return s1&lt;s2;            &#125;            return log1&lt;log2;  &#x2F;&#x2F;s1&#x3D;&#x3D;s2 只有前面的标识符不同 所以直接比较整个字符串相当于比较标识符        &#125;);        vector&lt;string&gt; ans;        for(auto str : alpha)  ans.push_back(str);        for(auto str : digit)  ans.push_back(str);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补5.7每日一题 BFS</title>
    <link href="/2022/05/09/%E8%A1%A55-7%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-BFS/"/>
    <url>/2022/05/09/%E8%A1%A55-7%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-BFS/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-433-最小基因变化"><a href="#LeetCode-433-最小基因变化" class="headerlink" title="LeetCode 433 最小基因变化"></a>LeetCode 433 最小基因变化</h2><blockquote><p>由于复习数据库和PHP考试好几天没刷题了，今天补了三道题。</p></blockquote><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>力扣难度：中等 </p><p>经典BFS问题 BFS利用队列实现</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode.cn/problems/minimum-genetic-mutation/">https://leetcode.cn/problems/minimum-genetic-mutation/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>解题思路没有完全按照力扣官方给出的解法，但是大体思想是一样的只有一些小的细节不太一样，都是用了广度优先搜索的方法解题的。</p><p>解题思路：首先定义一个队列q用于存储变化后的gene序列和哈希表mp防止重复遍历gene序列进入死循环。只要队列不为空或者gene != end，则遍历队列中的元素（有点类似于层序遍历），利用判断条件distance(str,gene) == 1 &amp;&amp; mp[str] == false找出所有未遍历的在基因库bank中且与当前遍历gene只差一个字符的基因并将其插入队列尾部。distance()函数为判断两个不同基因序列所差字符个数的函数。每做完一层遍历之后 ans++，表示基因变化了一次</p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int distance(string str,string gene)    &#123;        int cnt &#x3D; 0;        for(int i&#x3D;0; i&lt;str.size(); i++)        &#123;            if(str[i] !&#x3D; gene[i])  cnt++;        &#125;        return cnt;    &#125;    int minMutation(string start, string end, vector&lt;string&gt;&amp; bank) &#123;        int ans &#x3D; 0;        queue&lt;string&gt; q;        unordered_map&lt;string,bool&gt; mp;        q.push(start);        mp[start] &#x3D; true;        while(!q.empty())        &#123;            int n &#x3D; q.size();            for(int i&#x3D;0; i&lt;n; i++)            &#123;                auto gene &#x3D; q.front();                q.pop();                if(gene &#x3D;&#x3D; end)  return ans;                for(auto str : bank)                &#123;                    if(distance(str,gene) &#x3D;&#x3D; 1 &amp;&amp; mp[str] &#x3D;&#x3D; false)                    &#123;                        q.push(str);                        mp[str] &#x3D; true;                    &#125;                &#125;            &#125;            ans++;        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库常用命令操作</title>
    <link href="/2022/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<ul><li><p>启动数据库</p><p>net start mysql</p></li><li><p>关闭数据库</p><p>net  stop mysql</p></li><li><p>连接数据库</p><p>mysql -u root -p</p></li></ul><h4 id="管理数据库的命令"><a href="#管理数据库的命令" class="headerlink" title="管理数据库的命令"></a>管理数据库的命令</h4><ul><li><p><strong>USE 数据库名;</strong></p><p>选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。</p></li><li><p><strong>SHOW DATABASES;</strong></p><p>列出 MySQL 数据库管理系统的数据库列表。</p></li><li><p><strong>SHOW TABLES;</strong></p><p>显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。</p></li><li><p><strong>CREATE DATABASE 数据库名;</strong></p><p>创建数据库：CREATE DATABASE stu;  （注意MySQL语法要求大写）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「PHP」期末复习</title>
    <link href="/2022/05/05/%E3%80%8CPHP%E3%80%8D%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/05/05/%E3%80%8CPHP%E3%80%8D%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>愿世间再无不让打印的半开卷考试，整理了一天终于把PHP的内容整理完了，明天开始抄！</p><p>不过感觉这样整理的效果还挺好的，一边整理一边学比正常学的效率还要高。考完数据库和PHP再把Java整理一下，重拾Java，Java的语法啥的都快忘完了！！！</p></blockquote><h1 id="第1、2章-PHP入门-HTML和CSS简介"><a href="#第1、2章-PHP入门-HTML和CSS简介" class="headerlink" title="第1、2章 PHP入门 HTML和CSS简介"></a>第1、2章 PHP入门 HTML和CSS简介</h1><p>……</p><h1 id="第3章-数据与变量"><a href="#第3章-数据与变量" class="headerlink" title="第3章 数据与变量"></a>第3章 数据与变量</h1><h2 id="3-1-PHP数据类型"><a href="#3-1-PHP数据类型" class="headerlink" title="3-1 | PHP数据类型"></a>3-1 | PHP数据类型</h2><h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><ul><li><p>布尔型</p><p>用print或echo输出布尔型数据时，true被转换成字符串“1”，false被转换成空串。</p></li><li><p>整型</p></li><li><p>浮点型</p></li><li><p>字符串型</p><p>转义字符</p></li></ul><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><ul><li><p>数组</p><ul><li><p>在PHP中，数组是有序的映射。一个数组由若干元素组成，每个元素是一个键-值对。</p></li><li><p>键用于索引数组元素，一个数组不能有重复的键。键可以是整数也可以是字符串。</p></li><li><p>值也称为数组元素的值，可以是任意类型。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">//例子：创建数组。</span><span class="token variable">$arr1</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">=></span> <span class="token string double-quoted-string">"浙江"</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">=></span> <span class="token string double-quoted-string">"江苏"</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">=></span> <span class="token string double-quoted-string">"广东"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$arr2</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"浙江"</span> <span class="token operator">=></span> <span class="token string double-quoted-string">"杭州"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"江苏"</span> <span class="token operator">=></span> <span class="token string double-quoted-string">"南京"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"广东"</span> <span class="token operator">=></span> <span class="token string double-quoted-string">"广州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过一个具体的键可以访问对应的值，比如：</span><span class="token keyword">echo</span> <span class="token variable">$arr1</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 输出：浙江</span><span class="token keyword">Echo</span> <span class="token variable">$arr2</span><span class="token punctuation">[</span>“浙江”<span class="token punctuation">]</span>       <span class="token comment">// 输出：杭州</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ul></li><li><p>对象</p></li></ul><h4 id="NULL类型"><a href="#NULL类型" class="headerlink" title="NULL类型"></a>NULL类型</h4><p>NULL类型的唯一值是NULL，代表无值，不区分大小写。</p><p>一个变量在下面情况下具有NULL值</p><ul><li>被赋予常量NULL</li><li>不存在</li><li>被unset复原</li></ul><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token keyword">unset</span><span class="token punctuation">(</span><span class="token keyword type-hint">mixed</span> <span class="token variable">$var1</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword type-hint">mixed</span> <span class="token variable">$var2</span><span class="token punctuation">]</span><span class="token operator">*</span> <span class="token punctuation">)</span><span class="token comment">//unset用以销毁指定的一个或多个变量</span><span class="token keyword type-declaration">bool</span> <span class="token function">is_null</span><span class="token punctuation">(</span><span class="token keyword type-hint">mixed</span> <span class="token variable">$var</span><span class="token punctuation">)</span><span class="token keyword type-declaration">bool</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token keyword type-hint">mixed</span> <span class="token variable">$var1</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword type-hint">mixed</span> <span class="token variable">$var2</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token comment">//检测指定变量是否设置</span><span class="token keyword type-declaration">bool</span> <span class="token keyword">empty</span><span class="token punctuation">(</span><span class="token keyword type-hint">mixed</span> <span class="token variable">$var</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="3-2-类型转换"><a href="#3-2-类型转换" class="headerlink" title="3-2 | 类型转换"></a>3-2 | 类型转换</h2><p>PHP是弱类型的编程语言，在引入变量时，并不需要明确声明其类型。当给它赋一个字符串时，变量的类型就是字符串；如果再给它赋一个整数，那么变量的类型就变为整型的。</p><ul><li><p>自动类型转换</p><p>有时候在计算表达式时，PHP会根据上下文自动将一些数据转换成合适的类型来参与运算。</p></li><li><p>强制类型转换</p><p>语法：在要转换的变量（或表达式）之前加上用括号括起来的目标类型。</p></li></ul><h2 id="3-3-变量与常量"><a href="#3-3-变量与常量" class="headerlink" title="3-3 | 变量与常量"></a>3-3 | 变量与常量</h2><p>PHP变量总是以美元符号$开头，然后是变量名。</p><p>PHP是一种弱类型语言，或者动态类型语言。在PHP中，变量不需要显式声明，也没有固定的类型。变量的类型由赋给变量的值确定。</p><h4 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h4><ul><li><p>值赋值</p></li><li><p>引用赋值</p><p>引用赋值是指将源变量（右侧）的引用赋给目标变量（左侧），其结果是目标变量与源变量引用相同的内存单元。在源变量名前加上一个&amp;符号将实现按引用赋值。</p></li></ul><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul><li>全局变量</li><li>局部变量</li><li>静态变量</li><li>超全局变量</li></ul><h1 id="第4章-运算符与流程控制"><a href="#第4章-运算符与流程控制" class="headerlink" title="第4章 运算符与流程控制"></a>第4章 运算符与流程控制</h1><h2 id="4-1-运算符"><a href="#4-1-运算符" class="headerlink" title="4-1 | 运算符"></a>4-1 | 运算符</h2><ul><li><p>算术运算符</p></li><li><p>字符串运算符</p><p>字符串运算符是指字符串连接运算符（.），用于将两个字符串连接成一个新的字符串返回。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"abc"</span><span class="token punctuation">;</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"xyz"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$a</span><span class="token operator">.</span><span class="token string double-quoted-string">"123"</span><span class="token operator">.</span><span class="token variable">$b</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span>php<span class="token operator">></span><span class="token comment">//输出：abc123xyz</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>比较运算符</p><p>=== 全等（值和类型均相同）</p></li><li><p>逻辑运算符</p></li><li><p>位运算符</p></li><li><p>赋值运算符</p></li><li><p>三目条件运算符</p></li></ul><h2 id="4-2-流程控制"><a href="#4-2-流程控制" class="headerlink" title="4-2 | 流程控制"></a>4-2 | 流程控制</h2><ul><li>选择结构</li><li>循环结构</li><li>跳转语句</li></ul><h2 id="4-3-包含文件"><a href="#4-3-包含文件" class="headerlink" title="4-3 | 包含文件"></a>4-3 | 包含文件</h2><ul><li>include语句</li><li>require语句</li><li>include_once语句</li><li>require_once语句</li></ul><h1 id="第5章-PHP函数"><a href="#第5章-PHP函数" class="headerlink" title="第5章 PHP函数"></a>第5章 PHP函数</h1><h2 id="5-1-函数的声明与调用"><a href="#5-1-函数的声明与调用" class="headerlink" title="5-1 | 函数的声明与调用"></a>5-1 | 函数的声明与调用</h2><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>函数声明应该出现在PHP开始标记和结束标记之间。</p><p>语法格式：</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">function</span> <span class="token operator">&lt;</span>function_name<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token variable">$arg</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token variable">$arg</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 要执行的代码;</span><span class="token punctuation">&#125;</span><span class="token comment">//函数体可以是任何合法的PHP代码。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>函数名的命名规则：</p><p>(1) 函数名不能和已有的函数重名。</p><p>(2) 函数名称只能包含字母、数字和下划线。</p><p>(3) 函数名称不能以数字开头。</p><p>(4) 长度不限，对<strong>大小写不敏感</strong>。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>函数只有在被调用时才会执行，格式：</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token operator">&lt;</span>functin_name<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>exp<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>exp<span class="token operator">></span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h2 id="5-2-函数参数"><a href="#5-2-函数参数" class="headerlink" title="5-2 | 函数参数"></a>5-2 | 函数参数</h2><h4 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h4><p>函数形参被定义在函数名之后，括号内部。一个函数的形参数目不限，两个形参之间用逗号分隔。函数形参类似于在函数内定义的局部变量，在函数内有效。</p><p>当调用包含形参的函数时，应提供相应的参数值，通常称为实参。实参是表达式，两个表达式之间用逗号分隔。</p><h4 id="PHP参数传递的方式"><a href="#PHP参数传递的方式" class="headerlink" title="PHP参数传递的方式"></a>PHP参数传递的方式</h4><ul><li><p>按值传递参数</p><p>默认情况下，函数的参数是按值传递的。这意味着，即使实参是变量，当函数对形参的值进行改变后，也不会影响函数外部实参的取值。</p></li><li><p>引用传递参数</p><p>要实现按引用传递：</p><p>(1) 形参名前加上&amp;符号，如&amp;$arg。</p><p>(2) 实参是变量。</p></li></ul><h4 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h4><p>在声明函数时，可以为形参指定默认值。形参默认值必须是常量表达式，通过运算符“=”给相应的形参赋值。</p><p>具有默认值的形参可以有多个，但必须放置在其他形参后面。当调用函数时，对不具有默认值的形参必须指定相应的实参，对具有默认值的形参，可以指定实参，也可以没有。</p><h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><ul><li>可变长形参<ul><li>PHP支持可变长参数。</li><li>可变长形参通过在形参名前加符号“…”实现。可变长形参必须是形参表中最后一个形参。</li><li>可变长形参可以接收零个或多个实参值，此时这些参数值将被组织成一个数组赋给该形参。</li></ul></li><li>可变长实参<ul><li>可变长实参在实参前加符号“…”实现。可变长实参的类型应该是数组。可变长实参必须是实参表中的最后一个实参。</li><li>当传递参数时，实参数组中的各元素将被自动取出并一一赋给对应的形参。</li></ul></li></ul><h2 id="5-3-函数返回值"><a href="#5-3-函数返回值" class="headerlink" title="5-3 | 函数返回值"></a>5-3 | 函数返回值</h2><p>表达式可以是任意类型的，所以一个函数可以返回数值、字符串等标量类型的值，也可以返回数组、对象等复合类型的值。</p><p>函数可以返回一个值，也可以返回一个引用。</p><p>要让函数返回一个引用，需要：</p><p>(1) 在函数声明时，函数名前使用&amp;；</p><p>(2) return语句所带的表达式是变量；</p><p>(3) 调用函数时，函数名前使用&amp;。</p><h2 id="5-4-变量函数"><a href="#5-4-变量函数" class="headerlink" title="5-4 | 变量函数"></a>5-4 | 变量函数</h2><h2 id="5-5-匿名函数"><a href="#5-5-匿名函数" class="headerlink" title="5-5 | 匿名函数"></a>5-5 | 匿名函数</h2><ul><li><p>匿名函数作为变量值</p><p>可以把匿名函数作为一个表达式赋给一个变量，然后就可以通过该变量来调用匿名函数了。</p><p>在内部处理中，PHP系统会自动把匿名函数转换成内置类Closure的一个实例对象，然后再把该实例对象赋给变量。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token comment">//给变量$green赋一个匿名函数</span>    <span class="token variable">$greet</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"hello"</span><span class="token punctuation">,</span><span class="token variable">$name</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//函数末尾需要分号</span><span class="token variable">$greet</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$greet</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span>//输出：hello world//    hello php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>用作回调类型参数的值</p><p>用于接收函数的形参被称为回调类型参数，传递给这种参数的函数被称为回调函数。</p><p>回调函数可以是正常的函数，也可以是匿名函数。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">function</span> <span class="token function-definition function">myFunc</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">,</span><span class="token variable">$func</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$func</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function-definition function">display</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"hello"</span><span class="token punctuation">,</span><span class="token variable">$str</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"world"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"display"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ul><h2 id="5-6-日期时间函数"><a href="#5-6-日期时间函数" class="headerlink" title="5-6 | 日期时间函数"></a>5-6 | 日期时间函数</h2><ol><li><h4 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h4><p>int time(void)</p><p>返回自从Unix纪元（格林威治时间1970年1月1日00:00:00）到当前时间经过的秒数。</p></li><li><h4 id="mktime函数"><a href="#mktime函数" class="headerlink" title="mktime函数"></a>mktime函数</h4><p>int mktime([ int $hour [, int $minute [, int $second [, int $month [, int $day [, int $year]]]]]] )</p><p>函数返回与指定日期时间信息相应的时间戳，即从Unix纪元到指定时间的秒数。</p></li><li><h4 id="date函数"><a href="#date函数" class="headerlink" title="date函数"></a>date函数</h4><p>string date(string $format [, int $timestamp ])</p><p>按照指定的格式串$format对指定的时间戳$timestamp进行格式化，返回格式化产生的字符串。如果缺省$timestamp，就使用当前的Unix时间戳，即time()的返回值。</p><p>格式串由格式符和普通文本组成。格式符描述了需要包含的相应的日期时间文本，普通文本则会原样保留在返回的字符串。</p></li><li><h4 id="getdate函数"><a href="#getdate函数" class="headerlink" title="getdate函数"></a>getdate函数</h4><p>array getdate([ int $timestamp = time() ])</p><p>返回一个根据指定时间戳$timestamp得出的包含有日期信息的关联数组。</p></li><li><h4 id="date-default-timezone-set"><a href="#date-default-timezone-set" class="headerlink" title="date_default_timezone_set"></a><strong>date_default_timezone_set</strong></h4><p>bool date_default_timezone_set(string $timezone_identifier)</p><p>函数为当前脚本中所有日期时间函数设置一个默认时区。如果参数值有效，函数返回true，否则返回false。</p><p>中国大陆的时区标识符可用PRC。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">date_default_timezone_set</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"PRC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$time1</span> <span class="token operator">=</span> <span class="token function">mktime</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">2016</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据日期时间信息获取时间戳$time1</span><span class="token variable">$dt</span> <span class="token operator">=</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Y-m-d H:i:s"</span><span class="token punctuation">,</span> <span class="token variable">$time1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 根据时间戳获得日期时间信息的字符串</span><span class="token keyword">echo</span> <span class="token variable">$dt</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"&lt;br />"</span><span class="token punctuation">;</span><span class="token variable">$time2</span> <span class="token operator">=</span> <span class="token function">mktime</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">2016</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据日期时间信息获取时间戳$time2</span><span class="token variable">$wday</span> <span class="token operator">=</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"w"</span><span class="token punctuation">,</span> <span class="token variable">$time2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 获得指定时间戳属于星期几</span><span class="token keyword">echo</span> <span class="token variable">$wday</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"&lt;br />"</span><span class="token punctuation">;</span><span class="token variable">$lastday</span> <span class="token operator">=</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"t"</span><span class="token punctuation">,</span> <span class="token variable">$time2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 获得指定时间戳所在月份的天数</span><span class="token keyword">echo</span> <span class="token variable">$lastday</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"&lt;br />"</span><span class="token punctuation">;</span><span class="token variable">$days</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$time2</span> <span class="token operator">-</span> <span class="token variable">$time1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 计算两个指定时间相差的天数</span><span class="token keyword">echo</span> <span class="token punctuation">(</span><span class="token keyword type-casting">int</span><span class="token punctuation">)</span><span class="token variable">$days</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span>/*输出：    2016-01-20 15:10:28    5    29    22    */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h1 id="第6章-处理字符串"><a href="#第6章-处理字符串" class="headerlink" title="第6章 处理字符串"></a>第6章 处理字符串</h1><h2 id="6-1-长度与去空"><a href="#6-1-长度与去空" class="headerlink" title="6-1 | 长度与去空"></a>6-1 | 长度与去空</h2><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><p>1.字节长度</p><p>int strlen(string $str)</p><p>①返回字符串的长度，即字节个数。</p><p>②若str为空串或NULL，返回0。</p><p>2.字符长度</p><p>mixed mb_strlen(string $str [, string $encoding])</p><p>①返回字符串长度，即字符个数。字符串$str采用指定的字符集$encoding。</p><p>②若$str为空串或NULL，函数返回0。</p><p>③如果$encoding指定的不是一个字符集名称，函数产生一个警告信息，并返回false。</p><p>④如果$encoding指定的字符集与字符串实际采用的字符集不一致，函数返回的结果可能不正确。</p><h4 id="去空"><a href="#去空" class="headerlink" title="去空"></a>去空</h4><p>string trim($str [, $charlist])    //去除首尾端空白符号或指定字符</p><p>string ltrim($str[, $charlist])    //去除开头的空白符号或指定字符</p><p>string rtrim($str [, $charlist])    //去除尾部的空白符号或指定字符</p><p>①从字符串($str)的开始处和(或)结尾处去除空白符号(默认)或指定字符($charlist)，然后返回结果字符串。</p><p>②空白符号包括:换行符和回车符(\n和\r)、水平和垂直制表符(\t和\x0B)、空字符(\0)、空格。</p><p>③$charlist可以简单列出所有要过滤的字符，也可以使用..指定一个字符范围，如\x61..\x7a，表示所有的小写字母。</p><h2 id="6-2-大小写转换与比较"><a href="#6-2-大小写转换与比较" class="headerlink" title="6-2 | 大小写转换与比较"></a>6-2 | 大小写转换与比较</h2><h4 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h4><p><strong>1.</strong> <strong>小写转大写</strong></p><p>string strtoupper(string $string)    //将$string中所有的小写字母转换为大写并返回。</p><p><strong>2.</strong> <strong>大写转小写</strong></p><p>string strtolower(string $string)    //将$string中所有的大写字母转换为小写并返回。</p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p><strong>1.</strong> <strong>按字典顺序比较</strong></p><p>int strcmp(string $str1, string $str2)</p><p>int strcasecmp(string $str1, string $str2)</p><p>①按字典顺序比较。若str1大于str2，返回&gt;0；若str1小于str2，返回&lt;0；若str1等于str2，返回0。</p><p>②函数strcmp比较时区分大小写，函数strcasecmp比较时不区分大小写。</p><p><strong>2.</strong> <strong>按自然顺序比较</strong> </p><p>int strnatcmp(string $str1, string $str2)</p><p>int strnatcasecmp(string $str1, string $str2)</p><p>①按自然顺序比较，若str1大于str2，返回&gt;0；若str1小于str2，返回&lt;0；若str1等于str2，返回0。</p><p>②函数strnatcmp比较时区分大小写，函数strnatcasecmp比较时不区分大小写。</p><h2 id="6-3-子串处理"><a href="#6-3-子串处理" class="headerlink" title="6-3 | 子串处理"></a>6-3 | 子串处理</h2><h4 id="访问单个字符"><a href="#访问单个字符" class="headerlink" title="访问单个字符"></a>访问单个字符</h4><p>可以通过方括号或花括号访问字符串中的某单个字符：</p><p><strong>&lt;$string&gt;[&lt;$index&gt;]</strong>  </p><p>或</p><p><strong>&lt;$string&gt; {&lt;$index&gt;}</strong></p><p>可以返回指定索引位上的字符，类型为字符串。</p><p>如果指定的索引$index无效，那么PHP系统将产生一条注意（Notice）信息，式子返回空串。</p><h4 id="获取子串"><a href="#获取子串" class="headerlink" title="获取子串"></a>获取子串</h4><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">string</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$str</span><span class="token punctuation">,</span> <span class="token keyword type-hint">int</span> <span class="token variable">$start</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword type-hint">int</span> <span class="token variable">$length</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword type-declaration">string</span> <span class="token function">mb_substr</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$str</span><span class="token punctuation">,</span> <span class="token keyword type-hint">int</span> <span class="token variable">$start</span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token keyword type-hint">int</span> <span class="token variable">$length</span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token keyword type-hint">string</span> <span class="token variable">$encoding</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>①函数substr以字节为单位；函数mb_substr以字符为单位，$encoding指定字符串采用的字符集的名称。</p><p>②若$start为非负整数，则子串的起始位置是字符串中下标为$start的字符，字符串的首字符下标为0。若指定的子串起始位置超出了字符串的最后一个字符，函数返回false。 </p><p>③若$start为负整数，则子串的起点位置是字符串的倒数第-$start个字符，字符串最后一个字符的位置是-1。若指定子串的起始位置超出了字符串的首字符，子串的起始位置从首字符开始。</p><p>④若忽略$length，则子串从起始位置一直取到字符串的最后一个字符。若$length为0或false，则函数返回空串。</p><p>⑤若$length为正整数，则其指定返回子串的字符个数；若该值太大，则取至最后一个字符。</p><p>⑥若$length为负整数，则子串从起始位置取至倒数第-$length个字符前的一个字符为止，即保留字符串末尾的-$length个字符。</p><p>若-$length大于字符串的长度，则函数返回false；</p><p>若要保留的字符中最左边第1个字符正好是起始位置字符，则函数返回空串；</p><p>若要保留的字符越过了起始位置字符且$start为负整数，则函数返回空串；</p><p>若要保留的字符越过了起始位置字符且$start为非负整数，则函数返回false。</p><p>⑦在函数substr中，若$length为NULL，则函数返回空串。在函数mb_substr中，当$length为NULL时，则子串从起始位置一直取至字符串尾部。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">echo</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abcdef"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span>          <span class="token comment">// 输出: f</span><span class="token keyword">echo</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abcdef"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span>          <span class="token comment">// 输出: ef</span><span class="token keyword">echo</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abcdef"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span>       <span class="token comment">// 输出: d</span><span class="token keyword">echo</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abcdef"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span>       <span class="token comment">// 输出: abcde</span><span class="token keyword">echo</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abcdef"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span>       <span class="token comment">// 输出: cde</span><span class="token keyword">echo</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abcdef"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span>      <span class="token comment">// 输出: de</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abcdef"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 输出: string(0) ""</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abcdef"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 输出: bool(false) </span><span class="token variable">$str</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"PHP语言"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span>            <span class="token comment">// 输出: 语</span><span class="token keyword">echo</span> <span class="token function">mb_substr</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 输出: 语言</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="查找子串"><a href="#查找子串" class="headerlink" title="查找子串"></a>查找子串</h4><ul><li><p><strong>strpos</strong>函数</p><p>mixed strpos(string $haystack, mixed $needle [,int $offset ])</p><p>①返回子串$needle在字符串$haystack中第1次出现的位置。若没有发现子串，函数返回false。</p><p>②$offset指定搜索子串的起始位置，只能是非负整数，默认值为0。</p></li><li><p><strong>strrpos</strong>函数</p><p>①返回子串$needle在字符串$haystack中最后一次出现的位置。若没有发现子串，函数返回false。</p><p>②此函数的$offset可以是非负整数，也可以是负整数，默认值是0。若是非负整数，则从下标为$offset的字符开始查找，直至最后一个字符；若是负整数，则从首字符开始查找，直到倒数第-$offset个字符为止（只要子串的首字符在此位置上即可）。</p></li><li><p><strong>stripos</strong>函数</p><p>mixed stripos(string $haystack, mixed $needle [,int $offset ])</p><p>与strpos不同的是，stripos搜索时不区分大小写。</p></li><li><p><strong>strripos</strong>函数</p><p>mixed strripos(string $haystack, mixed $needle [,int $offset ])</p><p>与strrpos不同的是，strripos搜索时不区分大小写。</p></li></ul><h4 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h4><ul><li><p><strong>str_replace</strong>函数</p><p>mixed str_replace(mixed $search , mixed $replace, mixed $subject [, int &amp;$count ])</p><p>函数用$replace替换$subject中出现的所有$search，返回替换后的结果字符串。</p><p>①如果$search和$replace都是数组，那么就对$search中每个元素依次做替换操作，期间把$replace中的对应元素作为替换值。如果$replace的元素比$search的元素少，那么用空串作为$search中多余元素的替换值。</p><p>②如果$search是数组，而$replace是字符串，那么$replace被用作$search中的每个元素的替换值。</p><p>③如果$subject是一个数组，则上述替换操作将依次执行于$subject数组的每个元素，函数返回一个数组。</p><p>④如果指定$count变量，返回执行替换操作的次数。</p></li><li><p><strong>substr_replace</strong>函数</p><p>mixed substr_replace(mixed $str, mixed $replacement, mixed $start[, mixed $length])</p><p>函数用$replacement替换$str中从$start开始、长度为$length的子串，返回替换后的结果字符串。</p><p>①参数$start指定要被替换的子串的起始位置。若$start为非负整数，起始位置是下标为$start的字符；若$start为负整数，起始位置是倒数第-$start个字符。</p><p>②参数$length指定要被替换的子串的长度。</p><p>若$length为正整数，表示被替换的字符个数；</p><p>若$length为负整数，则子串从起始位置取至倒数第-$length个字符前的一个字符为止；</p><p>若$length为0，此函数的功能是插入;</p><p>若缺省$length，则被替换的子串是从$start开始至最后一个字符。</p><p>③若$str是数组，则$replacement、$start和$length会应用于$str的每个元素。如果$replacement、$start和$length也可以是数组，那么包括$str在内的各数组对应元素分别进行替换操作。函数返回一个数组。</p></li></ul><h2 id="6-4-分割和连接字符串"><a href="#6-4-分割和连接字符串" class="headerlink" title="6-4 | 分割和连接字符串"></a>6-4 | 分割和连接字符串</h2><ul><li><p><strong>explode</strong>函数</p><p>array explode(string $delimiter , string $string [, int $limit ])</p><p>依据定界字符串delimiter将字符串string分割成若干子串，并保存在一个数组中返回。</p><p>①若指定$limit为正整数，则返回的数组最多包含$limit个元素，最后一个元素包含$string的剩余部分；</p><p>②若指定$limit为0，被当做1处理，此时返回数组仅包含1个元素，即字符串$string本身； </p><p>③若指定$limit为负整数，则返回除了最后-limit个元素外的所有元素，可能会不包含任何元素。</p><p>④若$delimiter是空串，会给出一个警告（Warning）信息，函数返回false。</p></li><li><p><strong>implode</strong>函数</p><p>string implode([string $glue ,] array $pieces)</p><p>将数组pieces中的各元素连接成一个字符串返回，两个元素之间用glue连接。glue的默认值是空串。</p></li></ul><h2 id="6-5-格式化输出"><a href="#6-5-格式化输出" class="headerlink" title="6-5 | 格式化输出"></a>6-5 | 格式化输出</h2><p><strong>printf</strong>函数</p><p>int printf(string $format [, mixed $args [, mixed $… ]])</p><p>①根据格式化模板$format产生一个字符串输出，函数返回格式化产生的字符串的长度(字节数)。</p><p>②格式化模板由普通字符和格式符组成。普通字符原样出现在结果中，格式符通过应用于相应的参数出现在结果中。</p><p>③格式符的一般语法格式如下：%[+][‘&lt;填充符&gt;][-][&lt;宽度&gt;][.&lt;精度&gt;]&lt;类型&gt;</p><p>④类型指明该格式符如何应用于参数数据</p><p><strong>2.</strong> <strong>sprintf</strong>函数</p><p>string sprintf(string $format [, mixed $args [, mixed $… ]])</p><p>与printf不同，sprintf不产生输出，只是根据格式化模板format产生一个字符串并返回</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$num</span> <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span><span class="token variable">$location</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'tree'</span><span class="token punctuation">;</span><span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"There are %d monkeys in the %s&lt;br />"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token variable">$format</span><span class="token punctuation">,</span> <span class="token variable">$num</span><span class="token punctuation">,</span> <span class="token variable">$location</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$price</span> <span class="token operator">=</span> <span class="token number">12.567</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"The price is %5.2f"</span><span class="token punctuation">,</span> <span class="token variable">$price</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="6-6-字符串特殊处理"><a href="#6-6-字符串特殊处理" class="headerlink" title="6-6 | 字符串特殊处理"></a>6-6 | 字符串特殊处理</h2><ul><li><p><strong>nl2br</strong>函数</p><p>string nl2br(string $string)</p><p>将参数串中每个新行符(\n，\r，\n\r，\r\n)转换为HTML换行符(&lt;br /&gt;)。</p></li><li><p><strong>将字符转换成HTML实体</strong></p><p>string htmlspecialchars(string $string [, int $quotestyle [, string $encoding [, bool $double_encode]]] )</p><p>①将字符串中的特殊字符转换成HTML实体。</p><p>②参数string：要被转换的字符串。</p><p>③参数quotestyle：指定引号的转换</p><p>④参数encoding：指定字符串所用的字符编码。</p><p>⑤double_encode：指定是否转换已有的HTML实体，默认值为true，即要转换。</p></li><li><p><strong>addslashes</strong>函数</p><p>string addslashes(string $str)</p><p>①函数在参数字符串$str中的特殊字符前加上反斜杠（\）产生一个新的字符串返回。特殊字符包括：单引号（’）、双引号（”）、反斜线（\）与空字符（NUL）。</p><p>②这一功能有时在构建数据库的SQL语句时是有用的。</p></li><li><p><strong>urlencode函数</strong></p><p>string urlencode(string $str )</p><p>①函数可以对作为URL中查询参数值的字符串进行相应的编码并返回，以便作为URL的一部分。</p><p>②通常，URL只能包含字母数字以及-和_字符，对其他字符都要进行相应的编码。</p></li></ul><h2 id="6-7-正则表达式"><a href="#6-7-正则表达式" class="headerlink" title="6-7 | 正则表达式"></a>6-7 | 正则表达式</h2><ul><li><p>字符类</p><p>一个字符类在目标字符串中匹配一个单独的字符。</p><ul><li><p>一般字符 </p><p>一般字符类由一对方括号表示，可以使用-和^：[…]  [^…]  [a-z]  [^0-9]</p><table><thead><tr><th>一般字类</th><th>含义</th></tr></thead><tbody><tr><td>[…]</td><td>字符集合。匹配所包含的任意一个字符。例如，’[abc]’  可以匹配 “plain” 中的  ‘a’。</td></tr><tr><td>[^…]</td><td>反向字符集合。匹配未包含的任意字符。例如，’[^abc]’  可以匹配 “plain” 中的’p’。</td></tr><tr><td>[char1-char2]</td><td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td>[^char1-char2]</td><td>排除式字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr></tbody></table></li><li><p>特殊字符</p><table><thead><tr><th>特殊字符类</th><th align="left">含义</th></tr></thead><tbody><tr><td>.</td><td align="left">出现在方括号外，匹配除 “\n” 之外的任何单个字符。如‘a.c’匹配abc、awc、a9c、a#c等。</td></tr><tr><td>\w</td><td align="left">匹配包括下划线的任何单词字符，等价于[A-Za-z0-9_]。</td></tr><tr><td>\W</td><td align="left">匹配任何非单词字符，等价于[^A-Za-z0-9_]。</td></tr><tr><td>\d</td><td align="left">匹配一个数字字符，等价于[0-9]。</td></tr><tr><td>\D</td><td align="left">匹配一个非数字字符，等价于[^0-9]。</td></tr><tr><td>\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等，等价于[\n\r\f\t ]。说明：最后包含一个空格，但不包括\v。</td></tr><tr><td>\S</td><td align="left">匹配任何非空白字符。等价于[^\n\r\f\t ]。</td></tr></tbody></table></li></ul></li><li><p>元字符类与转义字符</p></li><li><p>选项模式与子模式</p></li><li><p>量词</p><p>量词用于指定重复次数，出现在要重复的对象后面。可以重复的对象包括：单独字符、字符类、转义字符、后向引用、子模式</p><table><thead><tr><th>*</th><th>匹配0次或更多次。例如，’xy*z’可以匹配”xz”、”xyz”、”xyyz”等。*等价于{0,}。</th></tr></thead><tbody><tr><td>+</td><td>匹配1次或更多次。例如，’xy+z’可以匹配”xyz”、”xyyz”、”xyyyz”等。+等价于{1,}。</td></tr><tr><td>?</td><td>匹配0次或1次。例如，’do(es)?’可以匹配”do”和”does”。?等价于{0,1}。</td></tr><tr><td>{<em>n}</em></td><td>严格匹配n次。 例如，’xy{2}z’可以匹配”xyyz”。</td></tr><tr><td>{<em>n,}</em></td><td>至少匹配n次。 例如，’xy{2,}z’可以匹配”xyyz”、”xyyyz”、”xyyyyz”等。</td></tr><tr><td>{<em>n,m}</em></td><td>至少匹配n次、最多匹配m次。例如，’xy{2,3}z’可以匹配”xyyz”、”xyyyz”。</td></tr></tbody></table></li><li><p>断言</p></li></ul><h2 id="6-8-PHP模式匹配函数"><a href="#6-8-PHP模式匹配函数" class="headerlink" title="6-8 | PHP模式匹配函数"></a>6-8 | PHP模式匹配函数</h2><ul><li><strong>preg_match函数（模式匹配及子模式匹配</strong>）</li><li><strong>preg_match_all</strong>函数</li><li><strong>preg_split</strong>函数</li></ul><h1 id="第8章-PHP访问数据库"><a href="#第8章-PHP访问数据库" class="headerlink" title="第8章 PHP访问数据库"></a>第8章 PHP访问数据库</h1><blockquote><p>PHP应用通常利用PHP的MySQLi扩展和PDO扩展访问数据库。</p><p>MySQLi扩展主要提供MySQLi、MySQLi_RESULT和MySQLi_STMT三个类，程序员可以使用这些类建立与MySQL数据库的连接、访问MySQL数据库以及处理查询结果。</p><p>PDO是一种数据访问抽象层，它为PHP程序员提供了一个轻量级的一致的编程接口。PDO扩展提供的应用程序编程接口主要包括PDO、PDOStatement和PDOException类。</p></blockquote><h2 id="8-1-使用MySQLi访问数据库"><a href="#8-1-使用MySQLi访问数据库" class="headerlink" title="8-1 | 使用MySQLi访问数据库"></a>8-1 | 使用MySQLi访问数据库</h2><h4 id="建立与MySQL服务器的连接"><a href="#建立与MySQL服务器的连接" class="headerlink" title="建立与MySQL服务器的连接"></a>建立与MySQL服务器的连接</h4><ul><li><p><strong>实例化</strong>MySQLi</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token function">construct</span> <span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$host</span><span class="token punctuation">,</span> <span class="token keyword type-hint">string</span> <span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token keyword type-hint">string</span> <span class="token variable">$passwd</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword type-hint">string</span> <span class="token variable">$dbname</span> <span class="token operator">=</span> <span class="token string double-quoted-string">""</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword type-hint">int</span> <span class="token variable">$port</span> <span class="token operator">=</span> <span class="token function">ini_get</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"mysqli.default_port"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p><strong>连接错误码和错误信息</strong></p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">int</span> <span class="token variable">$connect_errno</span>                   <span class="token comment">// 错误码，连接出错时非零</span><span class="token keyword type-declaration">string</span> <span class="token variable">$connect_error</span>               <span class="token comment">// 错误信息</span><span class="token comment">//例：如$mysqli->connect_errno</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li><li><p><strong>关闭连接</strong></p><p>bool close()                         // 关闭与数据库服务器的连接</p></li></ul><p>例：</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Content-type:text/html;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>@ <span class="token variable">$mysqli</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">mysqli</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"root"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">""</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"elective_manage"</span><span class="token punctuation">,</span> <span class="token number">3306</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token property">connect_errno</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"不能连接到数据库&lt;br/>"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">print</span> <span class="token string double-quoted-string">"成功连接至数据库！"</span><span class="token punctuation">;</span><span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="访问MySQL数据库"><a href="#访问MySQL数据库" class="headerlink" title="访问MySQL数据库"></a>访问MySQL数据库</h4><ul><li><strong>设置字符集</strong></li><li><strong>选择数据库</strong></li><li><strong>执行sql语句</strong></li><li><strong>获取受影响行数</strong></li></ul><p>例：</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Content-type:text/html;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>@ <span class="token variable">$mysqli</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">mysqli</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"root"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">""</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"elective_manage"</span><span class="token punctuation">,</span> <span class="token number">3306</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token property">connect_errno</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"不能连接到数据库&lt;br/>"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"SET NAMES 'utf8'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"INSERT INTO opencourse VALUES(null, '2015-2016-1', '0901011008', '1011', default),"</span>        <span class="token operator">.</span> <span class="token string double-quoted-string">"(null, '2015-2016-1', '0901011008', '1016', default)"</span><span class="token punctuation">;</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token function">query</span><span class="token punctuation">(</span><span class="token variable">$sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$result</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"SQL语句执行失败！"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"插入的行数："</span><span class="token punctuation">,</span> <span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token property">affected_rows</span><span class="token punctuation">;</span><span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="处理查询结果（MySQLi-RESULT）"><a href="#处理查询结果（MySQLi-RESULT）" class="headerlink" title="处理查询结果（MySQLi_RESULT）"></a>处理查询结果（MySQLi_RESULT）</h4><ul><li><strong>获取行数和列数</strong></li><li><strong>移动游标</strong></li><li><strong>返回查询结果的一行</strong></li><li><strong>释放查询结果</strong></li></ul><p>例：</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Content-type:text/html;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>@ <span class="token variable">$mysqli</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">mysqli</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"root"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">""</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"elective_manage"</span><span class="token punctuation">,</span> <span class="token number">3306</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token property">connect_errno</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"不能连接到数据库&lt;br/>"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"SET NAMES 'utf8'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$query</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"SELECT sn, sname, birthday FROM student WHERE gender='男'"</span><span class="token punctuation">;</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token function">query</span><span class="token punctuation">(</span><span class="token variable">$query</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$result</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"SQL语句执行失败！"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"共"</span> <span class="token operator">.</span> <span class="token variable">$result</span><span class="token operator">-></span><span class="token property">num_rows</span> <span class="token operator">.</span> <span class="token string double-quoted-string">"行：&lt;br />"</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$row</span> <span class="token operator">=</span> <span class="token variable">$result</span><span class="token operator">-></span><span class="token function">fetch_array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'sn'</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token string double-quoted-string">" "</span> <span class="token operator">.</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'sname'</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token string double-quoted-string">" "</span> <span class="token operator">.</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'birthday'</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token string double-quoted-string">"&lt;br />"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*foreach($result as $row) &#123;    echo $row->sn . " " . $row->sname . " " . $row->birthday . "&lt;br />";&#125;*/</span><span class="token variable">$result</span><span class="token operator">-></span><span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$mysqli</span><span class="token operator">-></span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="事务管理（MySQLi）"><a href="#事务管理（MySQLi）" class="headerlink" title="事务管理（MySQLi）"></a>事务管理（MySQLi）</h4><ul><li><p><strong>初始化一个事务</strong></p><p>bool <strong>begin_transaction</strong>(void)</p></li><li><p><strong>提交事务</strong></p><p>bool <strong>commit</strong>(void)</p></li><li><p><strong>回滚事务</strong></p><p>bool <strong>rollback</strong>(void)</p></li></ul><h2 id="8-2-使用预处理语句"><a href="#8-2-使用预处理语句" class="headerlink" title="8-2 | 使用预处理语句"></a>8-2 | 使用预处理语句</h2><h4 id="创建预处理语句"><a href="#创建预处理语句" class="headerlink" title="创建预处理语句"></a>创建预处理语句</h4><ul><li>初始化语句对象</li><li>准备SQL语句</li></ul><h4 id="执行预处理语句"><a href="#执行预处理语句" class="headerlink" title="执行预处理语句"></a>执行预处理语句</h4><ul><li>绑定参数</li><li>执行</li><li>产生缓存结果集</li><li>获取受影响的行数</li></ul><h4 id="处理查询结果"><a href="#处理查询结果" class="headerlink" title="处理查询结果"></a>处理查询结果</h4><ul><li>获取列数和行数</li><li>移动游标</li><li>绑定结果</li><li>获取查询结果</li><li>释放缓存结果集</li><li>关闭语句对象</li></ul><h2 id="8-3-使用PDO访问数据库"><a href="#8-3-使用PDO访问数据库" class="headerlink" title="8-3 | 使用PDO访问数据库"></a>8-3 | 使用PDO访问数据库</h2><blockquote><p>PDO（PHP Data Object）是一种PHP扩展，它的使用与MySQLi扩展非常相似，但PDO不仅能用于访问MySQL数据库，也能用于访问其他的数据库。</p><p>PDO是一种数据访问抽象层，它为PHP程序员提供了一个轻量级的一致的编程接口。利用它，PHP应用能够用相同的代码访问各种不同的数据库。</p><p>PDO编程接口由3个类组成，包括PDO类、PDOStatement类和PDOException类。</p></blockquote><h4 id="建立与数据库服务器的连接"><a href="#建立与数据库服务器的连接" class="headerlink" title="建立与数据库服务器的连接"></a>建立与数据库服务器的连接</h4><p>一个PDO类的实例对象代表PHP与数据库服务器之间的一个连接。</p><p>construct(string $dsn [, string $username [, string $password]])</p><p>参数$dsn表示数据源名称（Data Source Name），包含与数据库连接所需的信息，如服务器的IP地址、端口号、数据库的名称等。$dsn由PDO驱动器名开头，紧跟一个冒号，后面的语法通常与具体的PDO驱动器有关。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Content-type:text/html;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$dsn</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'mysql:dbname=elective_manage;host=127.0.0.1'</span><span class="token punctuation">;</span><span class="token variable">$user</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'root'</span><span class="token punctuation">;</span><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token variable">$pdo</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PDO</span><span class="token punctuation">(</span><span class="token variable">$dsn</span><span class="token punctuation">,</span> <span class="token variable">$user</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PDOException</span> <span class="token variable">$e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token string single-quoted-string">'连接失败: '</span> <span class="token operator">.</span> <span class="token variable">$e</span><span class="token operator">-></span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">echo</span> <span class="token string single-quoted-string">'成功连接至elective_manage数据库'</span><span class="token punctuation">;</span><span class="token variable">$pdo</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h4><ul><li>执行增删改</li><li>获取错误码和错误信息</li><li>执行查询</li></ul><h4 id="使用预处理语句"><a href="#使用预处理语句" class="headerlink" title="使用预处理语句"></a>使用预处理语句</h4><ul><li>创建预处理语句</li><li>绑定参数</li><li>执行预处理语句</li></ul><h4 id="访问结果集"><a href="#访问结果集" class="headerlink" title="访问结果集"></a>访问结果集</h4><ul><li>获取列数</li><li>绑定列</li><li>获取结果集的一行</li><li>获取一行中的单列值</li><li>获取所有行</li></ul><h4 id="管理事物"><a href="#管理事物" class="headerlink" title="管理事物"></a>管理事物</h4><ul><li>初始化一个事物</li><li>提交事物</li><li>回滚事物</li></ul><h2 id="8-4-分页显示"><a href="#8-4-分页显示" class="headerlink" title="8-4  | 分页显示"></a>8-4  | 分页显示</h2><p>要显示的数据集通常通过查询数据库获得。在实现分页显示时，可以有两种策略：一是每次只从数据库获取当前页的数据并呈现；另一种是预先从数据库获取整个数据集，然后把当前页呈现出来。</p><p>为实现分页显示功能，通常需要引入以下变量：</p><ul><li><p><strong>$rows</strong>：数据集的大小，即数据集包含的记录数。</p></li><li><p><strong>$pageSize</strong>：页面大小，即一次显示几条记录（行）。</p></li><li><p><strong>$pageCount</strong>：总页数，可根据$rows与$pageSize计算获得：</p><p>$pageCount = (int)ceil($rows/$pageSize);</p></li><li><p><strong>$currentPage</strong>：当前页码。该变量的初值可以设置为1，之后能由用户指定。</p></li><li><p><strong>$first</strong>：当前页第1条记录在数据集中的索引。可以根据$currentPage和$pageSize计算获得：</p><p>$first = ($currentPage-1)*$pageSize;</p></li></ul><h1 id="第9章-表单与会话"><a href="#第9章-表单与会话" class="headerlink" title="第9章 表单与会话"></a>第9章 表单与会话</h1><h2 id="9-1-表单处理"><a href="#9-1-表单处理" class="headerlink" title="9-1 | 表单处理"></a>9-1 | 表单处理</h2><h4 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h4><ul><li><p>GET方法</p><p>GET方法适合少量数据的提交，GET方法不适合提交密码等敏感数据。</p></li><li><p>POST方法</p><p>POST方法的请求数据放置在请求体中、而不是URL中，所以其信息相对较为安全，且传输的数据量没有大小限制，可以非常大。</p></li></ul><h4 id="获取表单数据"><a href="#获取表单数据" class="headerlink" title="获取表单数据"></a>获取表单数据</h4><ol><li><p>获取请求方式</p><p>$_SERVER[“REQUEST_METHOD”] ， “GET”|”POST”</p></li><li><p>获取GET数据</p><p>$_GET[“参数名”]，如$_GET[“name”]</p><p>$_GET是一个包含通过GET方法传递给当前脚本的请求参数的数组</p></li><li><p>获取POST数据</p><p>$_POST[“参数名”]，如$_POST[“name”]</p><p>$_POST是一个包含通过POST方法传递给当前脚本的请求参数数组</p></li></ol><h4 id="验证表单数据"><a href="#验证表单数据" class="headerlink" title="验证表单数据"></a>验证表单数据</h4><h2 id="9-2-会话管理"><a href="#9-2-会话管理" class="headerlink" title="9-2 | 会话管理"></a>9-2 | 会话管理</h2><h2 id="9-3-页面跳转与重定向"><a href="#9-3-页面跳转与重定向" class="headerlink" title="9-3 | 页面跳转与重定向"></a>9-3 | 页面跳转与重定向</h2><p>PHP中实现网页跳转的几种常见技术</p><ul><li>使用超链接&lt;a&gt;元素</li><li>使用表单&lt;form&gt;元素</li><li>使用特定的&lt;meta&gt;标记</li><li>使用PHP中特定的header函数</li></ul><h2 id="9-4-文件上传与下载"><a href="#9-4-文件上传与下载" class="headerlink" title="9-4 | 文件上传与下载"></a>9-4 | 文件上传与下载</h2><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><ul><li><p>文件的打开与关闭</p><p>(1) fopen函数</p><p>resource fopen($filename, $mode [, bool $use_include_path=false])</p><p>(2) fclose函数</p><p>bool fclose(resource $handle)</p></li><li><p>文件的写入</p><p>(1) fwrite函数</p><p>int fwrite(resource $handle, string $string [, int $length])</p><p>(2) fputcsv函数</p><p>int fputcsv(resource $handle, array $fields [, string $delimiter = ‘,’ [, string $enclosure = ‘“‘]])</p></li><li><p>文件的读取</p><p>(1) fread函数</p><p>string fread(resource $handle, int $length)</p><p>(2) fgets函数</p><p>string fgets(resource $handle [, int $length])</p><p>(3) fgetcsv函数</p><p>array fgetcsv(resource $handle [, int $length=0 [, string $delimiter=’,’ [, string $enclosure=’”‘]]])</p><p>(4) feof函数</p><p>bool feof(resource $handle)</p><p>(5) rewind函数</p><p>bool rewind(resource $handle)</p></li><li><p>其他函数</p><p>(1) readfile函数</p><p>int <strong>readfile</strong>(string $filename [, bool $use_include_path = false])</p><p>函数读取指定文件的内容并将其写入到输出缓冲区。</p><p>函数返回实际从文件中读入的字节数。</p><p>(2) filesize函数</p><p>int <strong>filesize</strong>(string $filename)</p><p>函数返回指定文件的大小，即文件的字节数。</p><p>(3) iconv函数</p><p>string <strong>iconv</strong>(string $in_charset , string $out_charset , string $str)</p><p>函数将字符串$str从$in_charset字符集编码转换为</p><p>$out_charset字符集编码。</p></li></ul><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><ul><li>文件上传表单</li><li>获取上传文件</li></ul><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><ul><li>用a元素直接打开文件</li><li>通过读取文件内容打开文件</li></ul><h1 id="第10章-使用数组"><a href="#第10章-使用数组" class="headerlink" title="第10章 使用数组"></a>第10章 使用数组</h1><h2 id="10-1-数组"><a href="#10-1-数组" class="headerlink" title="10-1 | 数组"></a>10-1 | 数组</h2><ul><li>在PHP中，数组是有序的映射。一个数组由若干元素组成，每个元素是一个键-值对。键可以是整数也可以是字符串，值可以是任意类型。</li><li>在一个PHP数组中，键的类型可以是混合：有些元素的键是整数，有些元素的键是字符串。</li><li>如果一个数组的元素的值本身就是数组，就可形成多维数组。</li><li>在PHP中，不要求一个数组的各元素的值具有相同的类型。</li></ul><h2 id="10-2-创建和初始化数组"><a href="#10-2-创建和初始化数组" class="headerlink" title="10-2 | 创建和初始化数组"></a>10-2 | 创建和初始化数组</h2><h4 id="使用array语言结构使用array语言结构"><a href="#使用array语言结构使用array语言结构" class="headerlink" title="使用array语言结构使用array语言结构"></a><strong>使用array语言结构使用array语言结构</strong></h4><p>①语言结构array用于创建并初始化一个数组：</p><p>array (</p><p>  [[&lt;key&gt;]=&gt;&lt;value&gt; [, [&lt;key&gt;]=&gt;&lt;value&gt;]*]</p><p>)</p><p>②在指定一个元素时，键是可以缺省的。此时，PHP将使用之前已经被使用的最大的整数键加1作为该元素的键，且至少是0。</p><p>③一个数组元素的值可以是标量类型数据，也可以是数组本身，这样就能形成二维数组和多维数组。多维数组可以使用嵌套的array来创建。</p><h4 id="使用range函数"><a href="#使用range函数" class="headerlink" title="使用range函数"></a><strong>使用range函数</strong></h4><p>①range函数可以快速创建一个由指定范围内的值填充的数组。其语法格式如下：</p><p>​    array range (mixed $start , mixed $end [, number $step ])</p><p>②参数$start、$end和$step分别表示用于填充新数组的初值、最大值和步长。参数$step是可选的，其默认值为1。</p><h2 id="10-3-操作数组元素"><a href="#10-3-操作数组元素" class="headerlink" title="10-3 | 操作数组元素"></a>10-3 | 操作数组元素</h2><h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>①可以通过方括号访问数组元素，其格式如下：<br> &lt;array&gt;[&lt;key&gt;]</p><p>   说明：访问数组元素时，方括号和花括号是可以互换的，如$arr[5]可以用$arr{5}代替。</p><p>②bool array_key_exists(mixed $key, array $array)<br> 检测指定的$key是否为数组$array的某个元素的键，若是返回true，否则返回false。</p><p>③bool in_array(mixed $needle, array $haystack [, bool $strict ] )<br> 检测指定值$needle是否是数组$haystack的某个元素的值，若是返回true，否则返回false。<br> 参数$strict是可选的，默认值为false，此时采用相等比较（==）。若将其设置为true，则采用全等比较（===）。</p><p>④mixed array_search(mixed $needle, array $haystack [, bool $strict] )<br> 检测指定值$needle是否是数组$haystack的某个元素的值，若是函数返回相应元素的键，否则返回false。若数组中存在多个元素具有该值，则返回第一个元素的键。</p><h4 id="修改、添加或删除数组元素"><a href="#修改、添加或删除数组元素" class="headerlink" title="修改、添加或删除数组元素"></a>修改、添加或删除数组元素</h4><p>①利用方括号同样可以修改数组元素或添加数组元素。这只需要将值赋给指定的的元素即可。<br> 格式1：&lt;array&gt;[&lt;key&gt;] = &lt;value&gt;;</p><p>​        将数组元素array[key]的值替换成value。如果数组中原先没有该元素，那么添加这样一个元素。</p><p> 格式2：&lt;array&gt;[] = &lt;value&gt;;</p><p>​        在数组中添加一个元素，元素的值为value，键为数组之前已经被用的最大的整数键加1，或者为0。</p><p>②使用unset函数可以删除一个数组元素，甚至整个数组。</p><p>例如：<br> unset($new_arr[‘y’]);    // 删除数组new_arr中键为’y’的元素<br> unset($new_arr);     // 删除整个数组new_arr </p><h4 id="在数组头部或尾部操作元素"><a href="#在数组头部或尾部操作元素" class="headerlink" title="在数组头部或尾部操作元素"></a><strong>在数组头部或尾部操作元素</strong></h4><p>①array_unshift()函数<br> array_unshift()函数用于在参数数组$array的头部插入一个或多个元素，其语法格式如下：<br> int array_unshift (array &amp;$array , mixed $value1 [, mixed $… ])<br> 新插入元素的键是数值键，与数组中原先已存在的数值键一起，重新设置为从0开始的连续整数。数组中原有的字符串键不变。函数返回插入元素后数组的元素个数。</p><p>②array_shift()函数<br> array_shift()函数用于从参数数组的头部删除一个元素，其语法格式如下：<br> mixed array_shift (array &amp;$array)<br> 第一个元素被删除后，数组中其他数值键被重新设置为以0开始的连续整数。函数返回被删除元素的值。若数组原先是空的，函数返回NULL。</p><p>③array_push()函数<br> array_push()函数用于在参数数组array的尾部添加一个或多个元素，其语法格式如下：<br> int array_push (array &amp;$array, mixed $value1 [, mixed $… ] )<br> 新添加元素的键是数值键，从原有的最大数值键加1开始设置。如果原先没有数值键元素，则新添加元素的键从0开始设置。函数返回添加元素后数组的元素数。</p><p>④array_pop()函数<br> array_pop()函数用于从参数数组的尾部删除一个元素，其语法格式如下：<br> mixed array_pop (array &amp;$array)<br> 函数返回被删除的元素的值。若数组原先是空的，函数返回NULL。</p><h2 id="10-4-遍历数组"><a href="#10-4-遍历数组" class="headerlink" title="10-4 | 遍历数组"></a>10-4 | 遍历数组</h2><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><p>①当创建一个数组时，其数组指针初始指向第一个元素。</p><p>②mixed next (array &amp;$array)<br> 移动指定数组$array的内部指针至下一个元素，并返回下一个元素的值。</p><p>③mixed prev (array &amp;$array)<br> 移动指定数组$array的内部指针至上一个元素，并返回上一个元素的值。</p><p>④mixed reset (array &amp;$array)<br> 移动指定数组$array的内部指针至第一个元素，并返回第一个元素的值。</p><p>⑤mixed end (array &amp;$array)<br> 移动指定数组$array的内部指针至最后一个元素，并返回最后一个元素的值。</p><p>⑥mixed current (array &amp;$array)<br> 返回数组$array当前元素的值。如果数组为空，或者数组指针移出了数组的范围，函数返回false。</p><p>⑦mixed key (array &amp;$array)<br> 返回数组$array当前元素的键。如果数组为空，或者数组指针移出了数组的范围，函数返回NULL。</p><h4 id="使用for语句遍历数组"><a href="#使用for语句遍历数组" class="headerlink" title="使用for语句遍历数组"></a><strong>使用for语句遍历数组</strong></h4><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$fruit</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'apple'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'banana'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'cranberry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$c</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$fruit</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$c</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token variable">$fruit</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br />"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="使用while语句遍历数组"><a href="#使用while语句遍历数组" class="headerlink" title="使用while语句遍历数组"></a><strong>使用while语句遍历数组</strong></h4><p>①key函数、current函数、next函数。</p><p>②each函数、list结构</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$fruit</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'a'</span> <span class="token operator">=></span> <span class="token string single-quoted-string">'apple'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'b'</span> <span class="token operator">=></span> <span class="token string single-quoted-string">'banana'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'c'</span> <span class="token operator">=></span> <span class="token string single-quoted-string">'cranberry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token operator">=</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token variable">$fruit</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token variable">$key</span><span class="token operator">.</span><span class="token string double-quoted-string">"=>"</span><span class="token operator">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token variable">$fruit</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br />"</span><span class="token punctuation">;</span>    <span class="token function">next</span><span class="token punctuation">(</span><span class="token variable">$fruit</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 使用each函数和list语言结构</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token variable">$fruit</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">list</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">,</span> <span class="token variable">$value</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">each</span><span class="token punctuation">(</span><span class="token variable">$fruit</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token variable">$key</span><span class="token operator">.</span><span class="token string double-quoted-string">"=>"</span><span class="token operator">.</span><span class="token variable">$value</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br />"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="使用foreach语句遍历数组"><a href="#使用foreach语句遍历数组" class="headerlink" title="使用foreach语句遍历数组"></a><strong>使用foreach语句遍历数组</strong></h4><p>①格式1：<br> foreach (<array_expression> as &lt;$value&gt;)<br>   &lt;statement&gt;</p><p>②格式2：<br> foreach (<array_expression> as &lt;$key&gt; =&gt; &lt;$value&gt;)<br>   &lt;statement&gt;</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$fruit</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'a'</span> <span class="token operator">=></span> <span class="token string single-quoted-string">'apple'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'b'</span> <span class="token operator">=></span> <span class="token string single-quoted-string">'banana'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'c'</span> <span class="token operator">=></span> <span class="token string single-quoted-string">'cranberry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$fruit</span> <span class="token keyword">as</span> <span class="token variable">$key</span><span class="token operator">=></span><span class="token variable">$value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">echo</span> <span class="token variable">$key</span><span class="token operator">.</span><span class="token string double-quoted-string">"=>"</span><span class="token operator">.</span><span class="token variable">$value</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br />"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="10-5-数组运算符"><a href="#10-5-数组运算符" class="headerlink" title="10-5 | 数组运算符"></a>10-5 | 数组运算符</h2><p>PHP提供了一些数组运算符，可以实现数组的联合、相等和不相等比较。</p><table><thead><tr><th>运算符</th><th>名称</th><th>例子</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>联合</td><td>$a + $b</td><td>返回一个包含了$a和$b两个数组中所有元素的数组。</td></tr><tr><td>==</td><td>松散相等</td><td>$a == $b</td><td>如果数组$a和数组$b具有相同的键值对，返回true。</td></tr><tr><td>===</td><td>严格相等</td><td>$a === $b</td><td>如果数组$a和数组$b具有相同的键值对以及相同的顺序和类型，返回true。</td></tr><tr><td>!=（&lt;&gt;）</td><td>不松散相等</td><td>$a != $b</td><td>如果数组$a和数组$b不是松散相等，返回true。</td></tr><tr><td>!==</td><td>不严格相等</td><td>$a !== $b</td><td>如果数组$a和数组$b不是严格相等，返回true。</td></tr></tbody></table><h2 id="10-6-数组排序"><a href="#10-6-数组排序" class="headerlink" title="10-6 | 数组排序"></a>10-6 | 数组排序</h2><ul><li><h4 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h4><p>bool sort (array &amp;$array [, int $sort_flags])</p><p>①函数根据元素值对数$array各元素从小到大进行排序。排序后，各元素的键重新设置为从0为开始的连续的整数。若排序成功，函数返回true；否则，返回false</p><p>②可选参数sort_flags的取值：<br> SORT_REGULAR：默认值。 正常比较（不改变类型）。<br> SORT_NUMERIC：数值化比较。<br> SORT_STRING：字符串化比较。<br> SORT_LOCALE_STRING：基于当前场所的字符串化比较。<br> SORT_NATURAL：自然顺序比较。<br> SORT_FLAG_CASE：能与SORT_STRING或SORT_NATURAL组合，以便比较时不区分大小写。</p></li><li><h4 id="asort和ksort函数"><a href="#asort和ksort函数" class="headerlink" title="asort和ksort函数"></a>asort和ksort函数</h4><p>①bool asort ( array &amp;$array [, int $sort_flags])<br> 该函数根据元素值对数组$array各元素从小到大进行排序。排序时，各元素的键和值保持关联。若排序成功，函数返回true；否则，返回false。</p><p>②bool ksort ( array &amp;$array [, int $sort_flags])<br> 该函数根据元素键对数组$array各元素从小到大进行排序。排序时，各元素的值和键保持关联。若排序成功，函数返回true；否则，返回false。</p></li><li><h4 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h4><p>① bool rsort(array &amp;$array [, int $sort_flags])</p><div class="code-wrapper"><pre class="language-none"><code class="language-none"> bool arsort(array &amp;$array [, int $sort_flags]) bool krsort(array &amp;$array [, int $sort_flags])</code></pre></div><p>②上面三个函数分别与sort、asort和ksort函数相对应。</p></li><li><h4 id="用户定义排序"><a href="#用户定义排序" class="headerlink" title="用户定义排序"></a>用户定义排序</h4></li></ul><h2 id="10-7-并集、交集和差集"><a href="#10-7-并集、交集和差集" class="headerlink" title="10-7 | 并集、交集和差集"></a>10-7 | 并集、交集和差集</h2><h4 id="求数组的并集"><a href="#求数组的并集" class="headerlink" title="求数组的并集"></a>求数组的并集</h4><p>①合并数组可以将若干数组合并在一起，返回一个包含各数组所有元素的数组。合并时，各参数数组依次将其各元素按其原先的顺序追加到结果数组中，各数值键被重新设置为从0开始的连续整数。</p><p>②array array_merge(array $array1 [, array $…])<br> array array_merge_recursive ( array $array1 [, array $…])</p><p>③array_merge_recursive函数与array_merge函数的功能大致相同，区别在于：如果合并的数组中存在有相同字符串键的元素，不是执行替换操作，而是合并操作，即将两个值合并成一个数组作为元素值。如果两个值本身就是数组，就将两个数组合并成一个数组作为元素值。所以这是一种递归合并。</p><h4 id="求数组的交集"><a href="#求数组的交集" class="headerlink" title="求数组的交集"></a>求数组的交集</h4><p>①array array_intersect ( array $array1, array $array2 [, array $array3]*)<br> 函数返回一个数组，这个数组仅包含第一个参数数组中其值在其他所有参数数组中都出现的元素。</p><p>②array array_intersect_assoc ( array $array1,  array $array2 [, array $array3]*)<br> 函数返回一个数组，这个数组仅包含第一个参数数组中其键-值对在其他所有参数数组中都出现的元素。</p><h4 id="求数组的差集"><a href="#求数组的差集" class="headerlink" title="求数组的差集"></a>求数组的差集</h4><p>①array array_diff ( array $array1, array $array2 [, array $array3]*)<br> 返回一个数组，这个数组仅包含第一个参数数组中其值没有在任何其他参数数组中出现的元素。</p><p>②array array_diff_assoc ( array $array1,  array $array2 [,array $array3]*)<br> 返回一个数组，这个数组仅包含第一个参数数组中其键-值对没有在任何其他参数数组中出现的元素。</p><h2 id="10-8-其他常用的数组函数"><a href="#10-8-其他常用的数组函数" class="headerlink" title="10-8 | 其他常用的数组函数"></a>10-8 | 其他常用的数组函数</h2><h4 id="计数与统计"><a href="#计数与统计" class="headerlink" title="计数与统计"></a>计数与统计</h4><p>①int count(array $array [, int $mode])<br> 返回数组中元素的个数。参数mode的取值如下：<br> COUNT_NORMAL：默认值。仅统计最外层数组的元素个数。<br> COUNT_RECURSIVE：递归统计各层数组的元素个数。</p><p>②array array_count_values(array $array)<br> 返回一个关联数组，其元素的键是参数数组中元素的值，相应的值是该键作为元素值在参数数组中出现的次数（频度）。</p><p>③number array_sum(array $array)<br> 计算参数数组中各元素值的和，返回一个整数或浮点数。<br> 对非数值型元素值，函数会将其转换成数值（大多数情况为0）。函数对内部数组的元素值不会进行递归累加。</p><h1 id="第11章-PHP面向对象程序设计"><a href="#第11章-PHP面向对象程序设计" class="headerlink" title="第11章 PHP面向对象程序设计"></a>第11章 PHP面向对象程序设计</h1><p>…….</p><h1 id="第12章-Ajax与jQuery"><a href="#第12章-Ajax与jQuery" class="headerlink" title="第12章 Ajax与jQuery"></a>第12章 Ajax与jQuery</h1><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><ul><li>Ajax是Asynchronous JavaScript And XML的首字母缩写，称为异步JavaScript和XML。</li><li>Ajax不是一种新的编程语言或技术，而是现有的几种技术的一种结合。它产生了一种新的、强大的开发Web应用的方法。Ajax包括：<ul><li>基于HTML+CSS来呈现信息。</li><li>使用XMLHttpRequest从Web服务器异步获取数据。</li><li>利用XML、JSON等来表示数据。</li><li>通过DOM实现页面的局部更新及动态效果。</li><li>运用JavaScript将各个方面绑定在一起。</li></ul></li><li>利用Ajax技术，Web应用可以在后台异步地向服务器发送数据和获取数据，而不会妨碍原有页面的显示和行为；Web应用能够动态地局部更新原有的页面，而不需要完整地重载一个页面。</li><li>Ajax的优点<ul><li>带来持续、动态的用户体验。</li><li>减轻网络通信的负担。</li><li>减轻服务器的负担。</li><li>创建桌面应用风格的界面。</li><li>促进数据和页面呈现的分离。</li></ul></li><li>Ajax的缺点<ul><li>无法正常使用书签化和后退按钮的功能。</li><li>兼容性不理想。不同的浏览器对Ajax的支持状况有所不同。</li><li>使用Ajax的脚本代码保存在HTML页中，不利于代码的保密。</li></ul></li></ul><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><ul><li>jQuery是一个“写的更少，但做的更多”的轻量级JavaScript库。涉及：<ul><li>HTML 元素选取</li><li>HTML 元素操作</li><li>CSS 操作</li><li> HTML 事件处理</li><li>HTML元素的动画效果</li><li>Ajax等</li></ul></li><li>jQuery库位于一个JavaScript文件中，其中包含了所有的jQuery函数和方法。<br> 可以通过下面的标记把jQuery添加到网页中：</li></ul><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“text/javascript”</span>           <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“jquery-3.1.0.min.js”</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li>jQuery是一个开源项目，可以从<a href="http://www.jquery.com免费下载.共有两个版本的/">www.jquery.com免费下载。共有两个版本的</a> jQuery 可供下载：一份是精简过的，另一份是未压缩的（供调试或阅读）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>解忧杂货</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串相乘</title>
    <link href="/2022/05/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <url>/2022/05/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-43：字符串相乘"><a href="#LeetCode-43：字符串相乘" class="headerlink" title="LeetCode 43：字符串相乘"></a>LeetCode 43：字符串相乘</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>对每次得到的字符串进行累加，可以使用「<a href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a>」的做法。</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>注意</strong>：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>如果 num1 和 num2 之一是 0，则直接将 0 作为结果返回即可。</p><p>如果 num1 和 num2 都不是 0，则可以通过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。这道题中，被乘数是 num1，乘数是 num2。</p><p>需要注意的是，num2 除了最低位以外，其余的每一位的运算结果都需要补 0。</p><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/QQ%E6%88%AA%E5%9B%BE20220502192051.png?raw=true" alt="方法一：做加法"></p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string multiply(string num1, string num2) &#123;        if(num1 &#x3D;&#x3D; &quot;0&quot; || num2 &#x3D;&#x3D; &quot;0&quot;)  return &quot;0&quot;;        string ans &#x3D; &quot;0&quot;;        int m &#x3D; num1.size(),n &#x3D; num2.size();        for(int i&#x3D;n-1; i&gt;&#x3D;0; i--)        &#123;            string cur;            int add &#x3D; 0;            &#x2F;&#x2F;末尾补0            for(int j&#x3D;n-1; j&gt;i; j--)            &#123;                ans.push_back(0);            &#125;            int y &#x3D; num2[i]-&#39;0&#39;;            for(int j&#x3D;m-1; j&gt;&#x3D;0; j--)            &#123;                int x &#x3D; num1[j]-&#39;0&#39;;                int sum &#x3D; x*y+add;                cur.push_back(&#39;0&#39;+sum%10);                add &#x3D; sum&#x2F;10;            &#125;            while(add !&#x3D; 0)            &#123;                cur.push_back(add%10);                add &#x3D; add&#x2F;10;            &#125;            reverse(cur.begin(),cur.end());  &#x2F;&#x2F;字符串翻转            ans &#x3D; addStrings(ans,cur);        &#125;        return ans;    &#125;    &#x2F;&#x2F;字符串相加 LeetCode 415    string addStrings(string &amp;num1,string &amp;num2)    &#123;        int i &#x3D; num1.size()-1,j &#x3D; num2.size()-1,add &#x3D; 0;        string ans;        while(i&gt;&#x3D;0 || j&gt;&#x3D;0 || add !&#x3D; 0)        &#123;            int x,y;            if(num1[i] &gt;&#x3D; 0)            &#123;                x &#x3D; num1[i] - &#39;0&#39;;            &#125;else&#123;                x &#x3D; 0;            &#125;            if(num2[j] &gt;&#x3D; 0)            &#123;                y &#x3D; num2[j] - &#39;0&#39;;            &#125;else&#123;                y &#x3D; 0;            &#125;            int sum &#x3D; x+y+add;            ans.push_back(&#39;0&#39;+sum%10);            add &#x3D; sum&#x2F;10;            i--;            j--;        &#125;        reverse(ans.begin(),ans.end());        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>方法1的时间和空间复杂度较高，方法一的做法是从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。如果使用数组代替字符串存储结果，则可以减少对字符串的操作。</p><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/QQ%E6%88%AA%E5%9B%BE20220502192422.png?raw=true" alt="方法二：做乘法"></p><p>LeetCode题解：<a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五一&#39;s Vlog</title>
    <link href="/2022/05/01/%E4%BA%94%E4%B8%80-s-Vlog/"/>
    <url>/2022/05/01/%E4%BA%94%E4%B8%80-s-Vlog/</url>
    
    <content type="html"><![CDATA[<h2 id="五一’s-Vlog"><a href="#五一’s-Vlog" class="headerlink" title="五一’s Vlog"></a>五一’s Vlog</h2><blockquote><p>五一’s Vlog 坐标青岛市 三万步 早九晚十 打卡东方影都 中山公园 湛山寺 八大关 海水浴场 小红楼美术馆 栈桥… </p><p>小红楼美术馆贼拉nice的一个地方 非常适合拍照 对于喜欢周杰伦的人来说真的是一种情怀</p></blockquote><blockquote><p>小小愿望：解封之后可以离开青岛市去泰安夜爬泰山看日出</p></blockquote><p>在东方影都 第二海水浴场和小红楼美术馆拍了几张我觉得挺有艺术感和氛围感的img</p><p>浅浅留念一下</p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181535.jpg" alt="微信图片_20220503181535"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181418.jpg" alt="微信图片_20220503181418"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181506.jpg" alt="微信图片_20220503181506"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181513.jpg" alt="微信图片_20220503181513"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181428.jpg" alt="微信图片_20220503181428"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181527.jpg" alt="微信图片_20220503181527"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181457.jpg" alt="微信图片_20220503181457"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181520.jpg" alt="微信图片_20220503181520"></p><p><img src="https://img.yiqiangshiyia.cn/blog/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220503181402.jpg" alt="微信图片_20220503181402"></p><p><img src="https://img.yiqiangshiyia.cn/blog/70BB5589229B05B912D4991998BFAB7A.jpg" alt="70BB5589229B05B912D4991998BFAB7A"></p><blockquote><p>哈哈哈 第一次以Blog的方式记录生活 我是一个不太喜欢记录生活的人 但是偶尔记录一下也还挺哦可的！！！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vlog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.27每日一题 DFS+BFS</title>
    <link href="/2022/04/27/4-27%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-DFS-BFS/"/>
    <url>/2022/04/27/4-27%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-DFS-BFS/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-417：太平洋大西洋水流问题"><a href="#LeetCode-417：太平洋大西洋水流问题" class="headerlink" title="LeetCode 417：太平洋大西洋水流问题"></a>LeetCode 417：太平洋大西洋水流问题</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>这是一道学习BFS和DFS绝绝子的题目，之前没怎么做过BFS和DFS的题目，一直都不太会，每日一题遇到了这么典型的题目当然要搞清楚啦。4.27今天一天的任务就是搞懂这道题BFS和DFS两种解法。</p></blockquote><p><strong>DFS利用了递归的思想</strong></p><p><strong>BFS利用了队列的思想</strong></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">https://leetcode-cn.com/problems/pacific-atlantic-water-flow/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法1：深度优先搜索（DFS）"><a href="#方法1：深度优先搜索（DFS）" class="headerlink" title="方法1：深度优先搜索（DFS）"></a>方法1：深度优先搜索（DFS）</h4><blockquote><p>雨水的流动方向是从高到低，每个单元格上的雨水只能流到高度小于等于当前单元格的相邻单元格。从一个单元格开始，通过搜索的方法模拟雨水的流动，则可以判断雨水是否可以从该单元格流向海洋。</p><p>如果直接以每个单元格作为起点模拟雨水的流动，则会重复遍历每个单元格，导致时间复杂度过高。为了降低时间复杂度，可以从矩阵的边界开始反向搜索寻找雨水流向边界的单元格，反向搜索时，每次只能移动到高度相同或更大的单元格。</p><p>由于矩阵的左边界和上边界是太平洋，矩阵的右边界和下边界是大西洋，因此从矩阵的左边界和上边界开始反向搜索即可找到雨水流向太平洋的单元格，从矩阵的右边界和下边界开始反向搜索即可找到雨水流向大西洋的单元格。</p><p>可以<strong>使用深度优先搜索实现反向搜索</strong>，搜索过程中需要记录每个单元格是否可以从太平洋反向到达以及是否可以从大西洋反向到达。反向搜索结束之后，遍历每个网格，如果一个网格既可以从太平洋反向到达也可以从大西洋反向到达，则该网格满足太平洋和大西洋都可以到达，将该网格添加到答案中。</p></blockquote><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static const int dirs[4][2] &#x3D; &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;  &#x2F;&#x2F;定义方向数组，分别表示向上下左右四个方向流动class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; heights;  &#x2F;&#x2F;定义一个全局数组    void dfs(int row,int col,vector&lt;vector&lt;bool&gt;&gt; &amp;ocean)    &#123;        int m &#x3D; ocean.size();        int n &#x3D; ocean[0].size();        if(ocean[row][col])        &#123;            return;        &#125;        ocean[row][col] &#x3D; true;        &#x2F;&#x2F;分别对上下左右四个方向进行搜索        for(int i&#x3D;0; i&lt;4; i++)        &#123;            int newRow &#x3D; row+dirs[i][0];            int newCol &#x3D; col+dirs[i][1];            if(newRow &gt;&#x3D; 0 &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;&#x3D; 0 &amp;&amp; newCol &lt; n &amp;&amp; heights[newRow][newCol] &gt;&#x3D; heights[row][col])            &#123;                dfs(newRow,newCol,ocean);            &#125;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123;        this-&gt;heights &#x3D; heights;        int m &#x3D; heights.size();        int n &#x3D; heights[0].size();        &#x2F;&#x2F;防止重复遍历单元格，增加时间复杂度，定义bool类型数组进行标记,默认值为false        vector&lt;vector&lt;bool&gt;&gt; pacific(m,vector&lt;bool&gt;(n,false));        vector&lt;vector&lt;bool&gt;&gt; atlantic(m,vector&lt;bool&gt;(n,false));        &#x2F;&#x2F;从左边缘开始dfs可以流入太平洋的单元格        for(int i&#x3D;0; i&lt;m; i++)        &#123;            dfs(i,0,pacific);        &#125;        &#x2F;&#x2F;从上边缘开始dfs可以流入太平洋的单元格        for(int j&#x3D;1; j&lt;n; j++)        &#123;            dfs(0,j,pacific);        &#125;        &#x2F;&#x2F;从右边缘开始dfs可以流入大西洋的单元格        for(int i&#x3D;0; i&lt;m; i++)        &#123;            dfs(i,n-1,atlantic);        &#125;        &#x2F;&#x2F;从下边缘开始dfs可以流入大西洋的单元格        for(int j&#x3D;0; j&lt;n-1; j++)        &#123;            dfs(m-1,j,atlantic);        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i&#x3D;0; i&lt;m; i++)        &#123;            for(int j&#x3D;0; j&lt;n; j++)            &#123;                if(pacific[i][j] &amp;&amp; atlantic[i][j])                &#123;                    vector&lt;int&gt; cell;                    cell.push_back(i);                    cell.push_back(j);                    ans.push_back(cell);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="方法2：宽度优先搜索（BFS）"><a href="#方法2：宽度优先搜索（BFS）" class="headerlink" title="方法2：宽度优先搜索（BFS）"></a>方法2：宽度优先搜索（BFS）</h4><blockquote><p>反向搜索也可以使用广度优先搜索实现。搜索过程中同样需要记录每个单元格是否可以从太平洋反向到达以及是否可以从大西洋反向到达。反向搜索结束之后，遍历每个网格，如果一个网格既可以从太平洋反向到达也可以从大西洋反向到达，则该网格满足太平洋和大西洋都可以到达，将该网格添加到答案中。</p></blockquote><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static const int dirs[4][2] &#x3D; &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;  &#x2F;&#x2F;定义方向数组，分别表示向上下左右四个方向流动class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; heights;  &#x2F;&#x2F;定义一个全局数组    void dfs(int row,int col,vector&lt;vector&lt;bool&gt;&gt; &amp;ocean)    &#123;        if(ocean[row][col])        &#123;            return;        &#125;        int m &#x3D; ocean.size();        int n &#x3D; ocean[0].size();        ocean[row][col] &#x3D; true;        queue&lt;pair&lt;int,int&gt;&gt; q;  &#x2F;&#x2F;定义队列存放单元格的位置坐标        q.emplace(row,col);  &#x2F;&#x2F;note：这里只能用q.emplace()不能使用q.push()        while(!q.empty())        &#123;            auto [row,col] &#x3D; q.front();            q.pop();            for(int i&#x3D;0; i&lt;4; i++)            &#123;                int newRow &#x3D; row+dirs[i][0];                int newCol &#x3D; col+dirs[i][1];                if(newRow &gt;&#x3D; 0 &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;&#x3D;0 &amp;&amp; newCol &lt; n &amp;&amp; heights[newRow][newCol] &gt;&#x3D; heights[row][col] &amp;&amp; !ocean[newRow][newCol])                &#123;                    ocean[newRow][newCol] &#x3D; true;                    q.emplace(newRow,newCol);                &#125;            &#125;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123;        this-&gt;heights &#x3D; heights;        int m &#x3D; heights.size();        int n &#x3D; heights[0].size();        &#x2F;&#x2F;防止重复遍历单元格，增加时间复杂度，定义bool类型数组进行标记,默认值为false        vector&lt;vector&lt;bool&gt;&gt; pacific(m,vector&lt;bool&gt;(n,false));        vector&lt;vector&lt;bool&gt;&gt; atlantic(m,vector&lt;bool&gt;(n,false));        &#x2F;&#x2F;从左边缘开始dfs可以流入太平洋的单元格        for(int i&#x3D;0; i&lt;m; i++)        &#123;            dfs(i,0,pacific);        &#125;        &#x2F;&#x2F;从上边缘开始dfs可以流入太平洋的单元格        for(int j&#x3D;1; j&lt;n; j++)        &#123;            dfs(0,j,pacific);        &#125;        &#x2F;&#x2F;从右边缘开始dfs可以流入大西洋的单元格        for(int i&#x3D;0; i&lt;m; i++)        &#123;            dfs(i,n-1,atlantic);        &#125;        &#x2F;&#x2F;从下边缘开始dfs可以流入大西洋的单元格        for(int j&#x3D;0; j&lt;n-1; j++)        &#123;            dfs(m-1,j,atlantic);        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i&#x3D;0; i&lt;m; i++)        &#123;            for(int j&#x3D;0; j&lt;n; j++)            &#123;                if(pacific[i][j] &amp;&amp; atlantic[i][j])                &#123;                    vector&lt;int&gt; cell;                    cell.push_back(i);                    cell.push_back(j);                    ans.push_back(cell);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.21每日一题</title>
    <link href="/2022/04/21/4-21%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <url>/2022/04/21/4-21%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这道题在LeetCode为简单题，但是通过不断更新两个下标i,j分割字符串的思路比较有借鉴意义。比直接遍历用split()函数分割字符串要更简单。</p></blockquote><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>string(cnt,’a’)    //字符串的一种构造函数，表示生成一个字符串，包含 cnt 个字符 ‘a’</p><p>sentence.substr(i,j-i)    //注意第一个参数为sentence下标其实位置，第二个参数为单词复制的长度而不是结束位置的下标。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://leetcode-cn.com/problems/goat-latin/">https://leetcode-cn.com/problems/goat-latin/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>我们可以对给定的字符串 sentence 进行一次遍历，找出其中的每一个单词，并根据题目的要求进行操作。</p><p>在寻找单词时，我们可以使用语言自带的 split() 函数，将空格作为分割字符，得到所有的单词。为了节省空间，我们也可以直接进行遍历：每当我们遍历到一个空格或者到达 sentence 的末尾时，我们就找到了一个单词。</p><p>当我们得到一个单词 w 后，我们首先需要判断 w 的首字母是否为元音字母。我们可以使用一个哈希集合 vowels 存储所有的元音字母 aeiouAEIOU，这样只需要判断 w 的首字母是否在 vowels 中。如果是元音字母，那么单词本身保持不变；如果是辅音字母，那么需要首字母移到末尾，这里使用语言自带的字符串切片函数即可。在这之后，我们需要在末尾添加 m 以及若干个 a，因此可以使用一个变量 cnt 记录需要添加的 a 的个数，它的初始值为 1，每当我们得到一个单词，就将它的值增加 1。</p></blockquote><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string toGoatLatin(string sentence) &#123;        unordered_set&lt;char&gt; vowels &#x3D; &#123;&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;&#125;;        int n &#x3D; sentence.size();        int i &#x3D; 0,cnt &#x3D; 1;        string ans;        while(i &lt; n)        &#123;            int j &#x3D; i;            while(j &lt; n &amp;&amp; sentence[j] !&#x3D; &#39; &#39;)  j++;            cnt++;            if(cnt !&#x3D; 2)  ans &#x3D; ans+&#39; &#39;;            if(vowels.count(sentence[i]))            &#123;                ans &#x3D; ans+sentence.substr(i,j-i)+&#39;m&#39;+string(cnt,&#39;a&#39;);            &#125;else&#123;                ans &#x3D; ans+sentence.substr(i+1,j-i-1)+sentence[i]+&#39;m&#39;+string(cnt,&#39;a&#39;);            &#125;            i &#x3D; j+1;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python图形化界面设计</title>
    <link href="/2022/04/20/Python%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/04/20/Python%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Github+PicGo搭建的图床没有梯子不好用，Github经常加载不出来。最近要复习考试，考完试有空把用Github搭建的图床换成Gitee+PicGo，再重新上传之前的笔记测试一下吧。</p><p>额……  还有博客的域名没整，没绑定域名又拍云CDN加速也整不了。算算了，等考完试在腾讯云重新买一个.cn的域名再折腾吧。</p></blockquote><h2 id="Python图形化界面设计"><a href="#Python图形化界面设计" class="headerlink" title="Python图形化界面设计"></a>Python图形化界面设计</h2><blockquote><p>学习链接：<a href="https://www.jianshu.com/p/91844c5bca78">https://www.jianshu.com/p/91844c5bca78</a></p></blockquote><blockquote><p>Python自带了tkinter 模块，实质上是一种流行的面向对象的GUI工具包 TK 的Python编程接口，提供了快速便利地创建GUI应用程序的方法。其图像化编程的基本步骤通常包括：</p><p>一、导入 tkinter 模块</p><p>二、创建 GUI 根窗体</p><p>三、添加人机交互控件并编写相应的函数</p><p>四、在主事件循环中等待用户触发事件响应</p></blockquote><h3 id="Python图形化界面设计-1"><a href="#Python图形化界面设计-1" class="headerlink" title="Python图形化界面设计"></a>Python图形化界面设计</h3><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> tkinter <span class="token keyword">import</span><span class="token operator">*</span><span class="token keyword">import</span> tkinterroot<span class="token operator">=</span>Tk<span class="token punctuation">(</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"我的第一个Python窗口"</span><span class="token punctuation">)</span>   <span class="token comment"># title() 方法可设置其标题文字</span>root<span class="token punctuation">.</span>geometry<span class="token punctuation">(</span><span class="token string">'550x400'</span><span class="token punctuation">)</span>  <span class="token comment">#geometry()方法可以设置窗体的大小（以像素为单位）  x为小写英文字母x</span><span class="token comment">#标签</span>lb<span class="token operator">=</span>Label<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">"我的第一个标签"</span><span class="token punctuation">,</span>bg<span class="token operator">=</span><span class="token string">"#d3fbfb"</span><span class="token punctuation">,</span>      <span class="token comment">#背景颜色</span>fg<span class="token operator">=</span><span class="token string">"red"</span><span class="token punctuation">,</span>          <span class="token comment">#字体颜色</span>font<span class="token operator">=</span><span class="token string">"'楷体'，32"</span><span class="token punctuation">,</span>  <span class="token comment">#标签字体</span>width<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span>height<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>relief<span class="token operator">=</span>RAISED    <span class="token comment">#浮雕样式</span><span class="token comment">#属性 relief 为控件呈现出来的3D浮雕样式，有 FLAT(平的)、RAISED(凸起的)、SUNKEN(凹陷的)、GROOVE(沟槽状边缘)和 RIDGE(脊状边缘) 5种。</span><span class="token punctuation">)</span>lb<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#控件布局 常见的控件布局有三种：pack() grid() place() 具体详见笔记</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="Python简单加法计算器"><a href="#Python简单加法计算器" class="headerlink" title="Python简单加法计算器"></a>Python简单加法计算器</h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426111614315.png?raw=true" alt="image-20220426111614315.png"></p><p>Python简单加法计算器代码：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#将两个输入框输入文本转化为浮点数值进行加法运算 要求每次单击按钮计算结果是以文本的形式追加到文本框中 将原输入框清空</span><span class="token comment">#按钮方法一：不传参数调用函数run1()实现 按钮方法二：用lambda()调用函数run2(x,y)同时传递参数实现</span><span class="token keyword">from</span> tkinter <span class="token keyword">import</span><span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">run1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>inp1<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    b <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>inp2<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    s <span class="token operator">=</span> <span class="token string">'%0.2f+%0.2f=%0.2f\n'</span><span class="token operator">%</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span>    txt<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>END<span class="token punctuation">,</span>s<span class="token punctuation">)</span>  <span class="token comment">#追加显示运算结果</span>    inp1<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>END<span class="token punctuation">)</span>  <span class="token comment">#清空输入</span>    inp2<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>END<span class="token punctuation">)</span>  <span class="token comment">#清空输入</span><span class="token keyword">def</span> <span class="token function">run2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    b <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>    s <span class="token operator">=</span> <span class="token string">'%0.2f+%0.2f=%0.2f\n'</span><span class="token operator">%</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span>    txt<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>END<span class="token punctuation">,</span>s<span class="token punctuation">)</span>    inp1<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>END<span class="token punctuation">)</span>    inp2<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>END<span class="token punctuation">)</span>root <span class="token operator">=</span> Tk<span class="token punctuation">(</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>geometry<span class="token punctuation">(</span><span class="token string">'460x240'</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'简单加法计算器'</span><span class="token punctuation">)</span>lb1 <span class="token operator">=</span> Label<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'请输入两个数，按下面两个按钮之一进行加法计算'</span><span class="token punctuation">)</span>lb1<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>rely<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>relwidth<span class="token operator">=</span><span class="token number">0.8</span><span class="token punctuation">,</span>relheight<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span>inp1<span class="token operator">=</span>Entry<span class="token punctuation">(</span>root<span class="token punctuation">)</span>inp1<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>rely<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span>relwidth<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span>relheight<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span>inp2<span class="token operator">=</span>Entry<span class="token punctuation">(</span>root<span class="token punctuation">)</span>inp2<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.6</span><span class="token punctuation">,</span>rely<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span>relwidth<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span>relheight<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token comment">#方法一：直接调用run1()</span>btn1 <span class="token operator">=</span> Button<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'方法一'</span><span class="token punctuation">,</span>command<span class="token operator">=</span>run1<span class="token punctuation">)</span>btn1<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>rely<span class="token operator">=</span><span class="token number">0.4</span><span class="token punctuation">,</span>relwidth<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span>relheight<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token comment">#方法二：利用lambda函数传参数调用run2()</span>btn2 <span class="token operator">=</span> Button<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'方法二'</span><span class="token punctuation">,</span>command<span class="token operator">=</span><span class="token keyword">lambda</span><span class="token punctuation">:</span>run2<span class="token punctuation">(</span>inp1<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>inp2<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>btn2<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.6</span><span class="token punctuation">,</span>rely<span class="token operator">=</span><span class="token number">0.4</span><span class="token punctuation">,</span>relwidth<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span>relheight<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token comment">#在窗体垂直自上而下位置60%处起 布局相对窗体高度40%高的文本框</span>txt <span class="token operator">=</span> Text<span class="token punctuation">(</span>root<span class="token punctuation">)</span>txt<span class="token punctuation">.</span>place<span class="token punctuation">(</span>rely<span class="token operator">=</span><span class="token number">0.6</span><span class="token punctuation">,</span>relheight<span class="token operator">=</span><span class="token number">0.4</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>mainloop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#place()方法：根据控件实例在父容器中的绝对或相对位置参数进行布局 常用参数布局：</span><span class="token comment">#lb.place(x=,y=) x y:控件实例在根窗体中水平和垂直方向上的其实位置（单位为像素）根窗体左上角为x=0,y=0 水平向右 垂直向下为正方向</span><span class="token comment">#lb.place(height=,width=) height width:控件实例本身的高度和宽度（单位为像素）</span><span class="token comment">#lb.place(relx=,rely=) relx rely:控件实例在根窗体中水平和垂直方向上起始布局的相对位置 即相对于根窗体宽和高的比例位置 取值在0.0~1.0之间</span><span class="token comment">#lb.place(relheight=,relwidth=) relheight relwidth:控件实例相对于根窗体的高度和宽度比例 取值在0.0~1.0之间</span><span class="token comment">#利用place的方法配合relx rely和relwidth relheight参数所得到的界面可自适应根窗体尺寸的大小</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="python图形化界面设计时钟"><a href="#python图形化界面设计时钟" class="headerlink" title="python图形化界面设计时钟"></a><strong>python图形化界面设计时钟</strong></h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426111840666.png?raw=true" alt="image-20220426111840666.png"></p><p>python图形化界面设计时钟代码：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#tkinter常见控件的特征属性</span><span class="token comment">#文本输入和输出相关控件：标签（Label）消息（Message）输入框（Entry）文本框（Text）Label和Message除了单行和多行不同外 属性和用法基本一直 用于呈现文本信息</span><span class="token comment">#利用configure()方法或config来实现文本变化</span><span class="token keyword">from</span> tkinter <span class="token keyword">import</span><span class="token operator">*</span><span class="token keyword">import</span> tkinter<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">gettime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    timestr <span class="token operator">=</span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%H:%M:%S"</span><span class="token punctuation">)</span>  <span class="token comment">#获取当前的时间并转化为字符串</span>    lb<span class="token punctuation">.</span>configure<span class="token punctuation">(</span>text<span class="token operator">=</span>timestr<span class="token punctuation">)</span>  <span class="token comment">#重新设置标签文本</span>    root<span class="token punctuation">.</span>after<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span>gettime<span class="token punctuation">)</span>  <span class="token comment">#每隔1s调用函数 gettime自身获取时间</span>root <span class="token operator">=</span> tkinter<span class="token punctuation">.</span>Tk<span class="token punctuation">(</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"时钟"</span><span class="token punctuation">)</span>lb <span class="token operator">=</span> tkinter<span class="token punctuation">.</span>Label<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">,</span>fg<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">,</span>font<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">"黑体"</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span>lb<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span>gettime<span class="token punctuation">(</span><span class="token punctuation">)</span>lb<span class="token punctuation">.</span>mainloop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="python图形化界面设计（复选框）"><a href="#python图形化界面设计（复选框）" class="headerlink" title="python图形化界面设计（复选框）"></a><strong>python图形化界面设计（复选框）</strong></h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426112015548.png?raw=true" alt="image-20220426112015548.png"></p><p>python图形化界面设计（复选框）代码：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> tkinter <span class="token keyword">import</span><span class="token operator">*</span><span class="token comment">#复选框</span><span class="token keyword">import</span> tkinter<span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ChackVar1<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">and</span> ChackVar2<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">and</span> ChackVar3<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">and</span> ChackVar4<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        s <span class="token operator">=</span> <span class="token string">'您还没选择任何爱好项目'</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        s1 <span class="token operator">=</span> <span class="token string">"足球"</span> <span class="token keyword">if</span> ChackVar1<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token string">""</span>        s2 <span class="token operator">=</span> <span class="token string">"篮球"</span> <span class="token keyword">if</span> ChackVar2<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token string">""</span>        s3 <span class="token operator">=</span> <span class="token string">"游泳"</span> <span class="token keyword">if</span> ChackVar3<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token string">""</span>        s4 <span class="token operator">=</span> <span class="token string">"田径"</span> <span class="token keyword">if</span> ChackVar4<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token string">""</span>        s <span class="token operator">=</span> <span class="token string">"您选择了%s%s%s%s"</span><span class="token operator">%</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3<span class="token punctuation">,</span>s4<span class="token punctuation">)</span>    lb2<span class="token punctuation">.</span>config<span class="token punctuation">(</span>text<span class="token operator">=</span>s<span class="token punctuation">)</span>root <span class="token operator">=</span> Tk<span class="token punctuation">(</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'复选框'</span><span class="token punctuation">)</span>lb1 <span class="token operator">=</span> Label<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'请选择您的爱好项目'</span><span class="token punctuation">)</span>lb1<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span>ChackVar1 <span class="token operator">=</span> IntVar<span class="token punctuation">(</span><span class="token punctuation">)</span>ChackVar2 <span class="token operator">=</span> IntVar<span class="token punctuation">(</span><span class="token punctuation">)</span>ChackVar3 <span class="token operator">=</span> IntVar<span class="token punctuation">(</span><span class="token punctuation">)</span>ChackVar4 <span class="token operator">=</span> IntVar<span class="token punctuation">(</span><span class="token punctuation">)</span>ch1 <span class="token operator">=</span> Checkbutton<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'足球'</span><span class="token punctuation">,</span>variable <span class="token operator">=</span> ChackVar1<span class="token punctuation">,</span>onvalue<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>offvalue<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>ch2 <span class="token operator">=</span> Checkbutton<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'篮球'</span><span class="token punctuation">,</span>variable <span class="token operator">=</span> ChackVar2<span class="token punctuation">,</span>onvalue<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>offvalue<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>ch3 <span class="token operator">=</span> Checkbutton<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'游泳'</span><span class="token punctuation">,</span>variable <span class="token operator">=</span> ChackVar3<span class="token punctuation">,</span>onvalue<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>offvalue<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>ch4 <span class="token operator">=</span> Checkbutton<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'田径'</span><span class="token punctuation">,</span>variable <span class="token operator">=</span> ChackVar4<span class="token punctuation">,</span>onvalue<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>offvalue<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>ch1<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span>ch2<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span>ch3<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span>ch4<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span>btn <span class="token operator">=</span> Button<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'OK'</span><span class="token punctuation">,</span>command<span class="token operator">=</span>run<span class="token punctuation">)</span>  <span class="token comment">#按钮的command参数和函数相连接</span>btn<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span>lb2 <span class="token operator">=</span> Label<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>lb2<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>mainloop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#复选框：复选框（Checkbutton）是为了返回多个选项值的交互控件 通常不直接触发函数的执行 该控件除了具有共有属性外</span><span class="token comment">#还具有显示文本（text）返回变量（variable）选中返回值（onvalue）和未选中默认返回值（offvalue）等重要属性</span><span class="token comment">#返回变量variable = var通常可以预先逐项分别声明变量的类型var = IntVar()（默认）或var = StringVar()</span><span class="token comment">#在所调用的函数中方可分别调用var.get()方法取得被选中实例的onvalue或offvalue值 复选框实例通常还可分别利用</span><span class="token comment">#seclet() deselect()和toggle()方法对其进行选中、清除选中和反选操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="python图形化界面设计（列表框）"><a href="#python图形化界面设计（列表框）" class="headerlink" title="python图形化界面设计（列表框）"></a><strong>python图形化界面设计（列表框）</strong></h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426112137578.png?raw=true" alt="image-20220426112137578.png"></p><p>python图形化界面设计（列表框）代码：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#列表框：列表框（Listbox）可供用户单选或多选所列条目以形成人机交互 列表框的主要控件方法如下:</span><span class="token comment">#curselection()：返回光标选中项目的元组 注意并不是单个的整数</span><span class="token comment">#delete(起始位置,终止位置)：删除项目 终止位置可省略 全部清空为delete(0,END)</span><span class="token comment">#get(起始位置,终止位置)：返回范围所含项目文本的元组 终止位置可忽略</span><span class="token comment">#insert(位置,项目元素)：插入项目元素（若有多项,可用列表或元组类型赋值）若位置为END 则将项目元素添加到最后</span><span class="token keyword">from</span> tkinter <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">ini</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    Lstbox1<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>END<span class="token punctuation">)</span>    list_items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"数学"</span><span class="token punctuation">,</span><span class="token string">"物理"</span><span class="token punctuation">,</span><span class="token string">"化学"</span><span class="token punctuation">,</span><span class="token string">"语文"</span><span class="token punctuation">,</span><span class="token string">"外语"</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> list_items<span class="token punctuation">:</span>        Lstbox1<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>END<span class="token punctuation">,</span>item<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    Lstbox1<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>END<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">ins</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> entry<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> Lstbox1<span class="token punctuation">.</span>curselection<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            Lstbox1<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>Lstbox1<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>entry<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            Lstbox1<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>Lstbox1<span class="token punctuation">.</span>curselection<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>entry<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">updt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> entry<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">''</span> <span class="token keyword">and</span> Lstbox1<span class="token punctuation">.</span>curselection<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        selected<span class="token operator">=</span>Lstbox1<span class="token punctuation">.</span>curselection<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        Lstbox1<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>selected<span class="token punctuation">)</span>        Lstbox1<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>selected<span class="token punctuation">,</span>entry<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> Lstbox1<span class="token punctuation">.</span>curselection<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        Lstbox1<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>Lstbox1<span class="token punctuation">.</span>curselection<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>root <span class="token operator">=</span> Tk<span class="token punctuation">(</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'列表框实验'</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>geometry<span class="token punctuation">(</span><span class="token string">'320x240'</span><span class="token punctuation">)</span>frame1 <span class="token operator">=</span> Frame<span class="token punctuation">(</span>root<span class="token punctuation">,</span>relief<span class="token operator">=</span>RAISED<span class="token punctuation">)</span>frame1<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">)</span>frame2 <span class="token operator">=</span> Frame<span class="token punctuation">(</span>root<span class="token punctuation">,</span>relief<span class="token operator">=</span>GROOVE<span class="token punctuation">)</span>frame2<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span>Lstbox1 <span class="token operator">=</span> Listbox<span class="token punctuation">(</span>frame1<span class="token punctuation">)</span>Lstbox1<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span>entry <span class="token operator">=</span> Entry<span class="token punctuation">(</span>frame2<span class="token punctuation">)</span>entry<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token punctuation">)</span>btn1 <span class="token operator">=</span> Button<span class="token punctuation">(</span>frame2<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'初始化'</span><span class="token punctuation">,</span>command<span class="token operator">=</span>ini<span class="token punctuation">)</span>btn1<span class="token punctuation">.</span>pack<span class="token punctuation">(</span>fill<span class="token operator">=</span>X<span class="token punctuation">)</span>btn2 <span class="token operator">=</span> Button<span class="token punctuation">(</span>frame2<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'添加'</span><span class="token punctuation">,</span>command<span class="token operator">=</span>ins<span class="token punctuation">)</span>btn2<span class="token punctuation">.</span>pack<span class="token punctuation">(</span>fill<span class="token operator">=</span>X<span class="token punctuation">)</span>btn3 <span class="token operator">=</span> Button<span class="token punctuation">(</span>frame2<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'插入'</span><span class="token punctuation">,</span>command<span class="token operator">=</span>ins<span class="token punctuation">)</span> btn3<span class="token punctuation">.</span>pack<span class="token punctuation">(</span>fill<span class="token operator">=</span>X<span class="token punctuation">)</span>btn4 <span class="token operator">=</span> Button<span class="token punctuation">(</span>frame2<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'修改'</span><span class="token punctuation">,</span>command<span class="token operator">=</span>updt<span class="token punctuation">)</span>btn4<span class="token punctuation">.</span>pack<span class="token punctuation">(</span>fill<span class="token operator">=</span>X<span class="token punctuation">)</span>btn5 <span class="token operator">=</span> Button<span class="token punctuation">(</span>frame2<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'删除'</span><span class="token punctuation">,</span>command<span class="token operator">=</span>delt<span class="token punctuation">)</span>btn5<span class="token punctuation">.</span>pack<span class="token punctuation">(</span>fill<span class="token operator">=</span>X<span class="token punctuation">)</span>btn6 <span class="token operator">=</span> Button<span class="token punctuation">(</span>frame2<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'清空'</span><span class="token punctuation">,</span>command<span class="token operator">=</span>clear<span class="token punctuation">)</span>btn6<span class="token punctuation">.</span>pack<span class="token punctuation">(</span>fill<span class="token operator">=</span>X<span class="token punctuation">)</span>root<span class="token punctuation">.</span>mainloop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="python图形化界面设计（组合框）"><a href="#python图形化界面设计（组合框）" class="headerlink" title="python图形化界面设计（组合框）"></a><strong>python图形化界面设计（组合框）</strong></h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426112247491.png?raw=true" alt="image-20220426112247491.png"></p><p>python图形化界面设计（组合框）代码：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> tkinter<span class="token punctuation">.</span>ttk <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> tkinter <span class="token keyword">import</span><span class="token operator">*</span><span class="token keyword">import</span> tkinter<span class="token keyword">def</span> <span class="token function">calc</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">:</span>       a <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       b <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       dic <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">:</span>a<span class="token operator">+</span>b<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span>a<span class="token operator">-</span>b<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">:</span>a<span class="token operator">*</span>b<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">:</span>a<span class="token operator">/</span>b<span class="token punctuation">&#125;</span>       c <span class="token operator">=</span> dic<span class="token punctuation">[</span>comb<span class="token punctuation">.</span>current<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>       lbl<span class="token punctuation">.</span>config<span class="token punctuation">(</span>text<span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>root <span class="token operator">=</span> Tk<span class="token punctuation">(</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'四则运算'</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>geometry<span class="token punctuation">(</span><span class="token string">'320x240'</span><span class="token punctuation">)</span>t1 <span class="token operator">=</span> Entry<span class="token punctuation">(</span>root<span class="token punctuation">)</span>t1<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>rely<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>relwidth<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span>relheight<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> Entry<span class="token punctuation">(</span>root<span class="token punctuation">)</span>t2<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>rely<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>relwidth<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span>relheight<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span>var <span class="token operator">=</span> StringVar<span class="token punctuation">(</span><span class="token punctuation">)</span>comb <span class="token operator">=</span> Combobox<span class="token punctuation">(</span>root<span class="token punctuation">,</span>textvariable<span class="token operator">=</span>var<span class="token punctuation">,</span>values<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'加'</span><span class="token punctuation">,</span><span class="token string">'减'</span><span class="token punctuation">,</span><span class="token string">'乘'</span><span class="token punctuation">,</span><span class="token string">'除'</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span>comb<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>rely<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>relwidth<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span>comb<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token string">'&lt;&lt;ComboboxSelected>>'</span><span class="token punctuation">,</span>calc<span class="token punctuation">)</span>lbl<span class="token operator">=</span>Label<span class="token punctuation">(</span>root<span class="token punctuation">,</span>text<span class="token operator">=</span><span class="token string">'结果'</span><span class="token punctuation">)</span>lbl<span class="token punctuation">.</span>place<span class="token punctuation">(</span>relx<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>rely<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">,</span>relwidth<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span>relheight<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>mainloop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python从excel表中读取数据并绘图</title>
    <link href="/2022/04/20/Python%E4%BB%8Eexcel%E8%A1%A8%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%BB%98%E5%9B%BE/"/>
    <url>/2022/04/20/Python%E4%BB%8Eexcel%E8%A1%A8%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%BB%98%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="Python从excel表中读取数据并绘图"><a href="#Python从excel表中读取数据并绘图" class="headerlink" title="Python从excel表中读取数据并绘图"></a>Python从excel表中读取数据并绘图</h2><blockquote><p>图文教程链接：<a href="https://mp.weixin.qq.com/s/DchGtK_wOavZ9eSPeV8ZUQ">https://mp.weixin.qq.com/s/DchGtK_wOavZ9eSPeV8ZUQ</a></p></blockquote><h3 id="一、柱状图"><a href="#一、柱状图" class="headerlink" title="一、柱状图"></a>一、柱状图</h3><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426105632700.png?raw=true" alt="Excel表中的数据"></p><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220426105719236.png?raw=true" alt="image-20220426105719236.png"></p><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h3><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment">#中文处理模块</span><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> rcParams  <span class="token comment">#中文处理模块 解决标签文字乱码情况</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.family'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'simhei'</span>  <span class="token comment">#中文处理模块 解决标签文字乱码情况</span>Vae <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_excel<span class="token punctuation">(</span><span class="token string">'Vae专辑.xlsx'</span><span class="token punctuation">)</span><span class="token comment">#Vae.sort_values(by='歌曲数目',inplace=True,ascending=False)</span><span class="token comment">#降序排列</span><span class="token comment">#Vae.sort_values(by='歌曲数目',inplace=True,ascending=True)</span><span class="token comment">#升序排列</span><span class="token comment">#print(Vae)</span>Vae<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'专辑'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'歌曲数目'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token comment">#color='blue'  统一设置柱状图颜色</span>plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span>rotation<span class="token operator">=</span><span class="token number">360</span><span class="token punctuation">)</span>  <span class="token comment">#调整标签方向使其横向写</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬虫</title>
    <link href="/2022/04/20/Python%E7%88%AC%E8%99%AB/"/>
    <url>/2022/04/20/Python%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Python爬虫学习"><a href="#Python爬虫学习" class="headerlink" title="Python爬虫学习"></a>Python爬虫学习</h2><p><strong>学习爬虫前需要安装的标准库</strong></p><p>安装如下：</p><p>pip install requests</p><p>pip install re</p><p>pip install bs4</p><p><strong>爬虫的四个主要步骤：</strong></p><p>1.明确目标</p><p>2.爬(将网站的所有内容给爬下来)</p><p>3.取(将自己想要的数据取下来)</p><p>4.保存数据</p><p><strong>接下来的所有代码操作都是在执行爬虫的四个主要步骤</strong></p><p>import requests    #爬取html的标准库函数</p><p>ret=requests.get(‘<a href="http://www.qiushibaike.com/&#39;">http://www.qiushibaike.com/&#39;</a>)    #ret返回的是网页请求成功的状态码</p><p>result=ret.content.decode()    #通过这段代码能够把网页的中文源代码返回给我们</p><p>print(result)    #result是一个字符串</p><p>通过请求一个url，来得到前端的数据，然后从前端的数据里面获取我们想要的内容</p><p>import re    #python的一个模块 用来将自己想要的数据取下来</p><p>re模块是针对字符串这种数据格式来提取的一种方法</p><p>具体代码：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">import</span> requests  <span class="token comment">#爬取html的标准库函数</span>headers<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"User-Urgent"</span><span class="token punctuation">:</span><span class="token string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"</span><span class="token punctuation">&#125;</span>  <span class="token comment">#防反爬 模拟人去访问网站 </span>ret<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.xbiquge.la/paihangbang/'</span><span class="token punctuation">)</span>   <span class="token comment">#ret返回的是网页请求成功的状态码</span>result<span class="token operator">=</span>ret<span class="token punctuation">.</span>content<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">#通过这段代码能够把网页的中文源代码返回给我们</span><span class="token comment">#result是一个字符串</span>novel <span class="token operator">=</span> <span class="token string">'&lt;li>\d&lt;a href=".+">(.*?)&lt;\/a>&lt;\/li>'</span>content<span class="token operator">=</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>novel<span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token comment">#re.S代表可以匹配到换行符</span><span class="token comment">#print(content)</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'笔趣阁爬虫数据.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> content<span class="token punctuation">:</span>         s <span class="token operator">=</span> i<span class="token operator">+</span><span class="token string">'\n'</span>         f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="一个完整的爬虫实例（re模块解析）"><a href="#一个完整的爬虫实例（re模块解析）" class="headerlink" title="一个完整的爬虫实例（re模块解析）"></a><strong>一个完整的爬虫实例（re模块解析）</strong></h3><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">import</span> requestsheaders<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"User-Urgent"</span><span class="token punctuation">:</span><span class="token string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"</span><span class="token punctuation">&#125;</span>ret<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.xbiquge.la/paihangbang/'</span><span class="token punctuation">)</span> result<span class="token operator">=</span>ret<span class="token punctuation">.</span>content<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#print(type(result))   </span>novel <span class="token operator">=</span> <span class="token string">'&lt;li>\d&lt;a href=".+">(.*?)&lt;\/a>&lt;\/li>'</span>content<span class="token operator">=</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>novel<span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token comment">#print(content)</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'笔趣阁爬虫数据.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> content<span class="token punctuation">:</span>         s <span class="token operator">=</span> i<span class="token operator">+</span><span class="token string">'\n'</span>         f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="一个完整的爬虫实例（BeautifulSoup模块解析）"><a href="#一个完整的爬虫实例（BeautifulSoup模块解析）" class="headerlink" title="一个完整的爬虫实例（BeautifulSoup模块解析）"></a><strong>一个完整的爬虫实例（BeautifulSoup模块解析）</strong></h3><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests  <span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupheaders<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"User-Urgent"</span><span class="token punctuation">:</span><span class="token string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"</span><span class="token punctuation">&#125;</span>ret<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.xbiquge.la/paihangbang/'</span><span class="token punctuation">)</span> result<span class="token operator">=</span>ret<span class="token punctuation">.</span>content<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#print(type(result)) </span>soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>result<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span><span class="token comment">#print(type(soup))</span>content <span class="token operator">=</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> content<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="写给小吕的详细解释版"><a href="#写给小吕的详细解释版" class="headerlink" title="写给小吕的详细解释版"></a><strong>写给小吕的详细解释版</strong></h3><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> re  <span class="token comment">#re为python的一个模块 用于解析网页源代码</span><span class="token comment">#同样可以实现该功能的还有bs4 lxml等</span><span class="token keyword">import</span> requests  <span class="token comment">#爬取html的标准库函数</span>headers<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"User-Urgent"</span><span class="token punctuation">:</span><span class="token string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"</span><span class="token punctuation">&#125;</span>  <span class="token comment">#防反爬 模拟人去访问网站 </span>ret<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.xbiquge.la/paihangbang/'</span><span class="token punctuation">)</span>   <span class="token comment">#ret返回的是网页请求成功的状态码</span><span class="token comment">#requests.get()可以得到该网站的代码</span>result<span class="token operator">=</span>ret<span class="token punctuation">.</span>content<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">#对代码进行解析 通过解析能够把网页的中文源代码返回给我们</span><span class="token comment">#得到中文源代码之后只需要提取我们所需要的的数据即可</span><span class="token comment">#result是一个字符串</span>novel <span class="token operator">=</span> <span class="token string">'&lt;li>\d&lt;a href=".+">(.*?)&lt;\/a>&lt;\/li>'</span><span class="token comment">#使用正则表达式去匹配代码中的关键字 小括号()前后代表所要去匹配代码的标签</span><span class="token comment">#(.*?)代表所要提取的内容</span><span class="token comment">#这个地方你在展示的时候如果说不明白的话 你可以这么说：</span><span class="token comment">#正则表达式是爬虫的关键 用来提取所爬代码中我们所需要的数据 如果大家想要更深入的了解的话 可以建议大家去b站看一下这个视频</span><span class="token comment">#b站视频链接(https://www.bilibili.com/video/BV1da4y1p7iZ)</span><span class="token comment">#这个视频详细的介绍了正则表达式的使用 以及还推荐了一个很实用的在线的正则表达式检验的网站 同学们可以去学习一下</span><span class="token comment">#正则表达式检验网站(https://regex101.com/)</span>content<span class="token operator">=</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>novel<span class="token punctuation">,</span>result<span class="token punctuation">)</span>  <span class="token comment">#调用re模块 re.finaall是用来查找result中与novel所匹配的内容 以列表的形式返回所匹配到的字符串</span><span class="token comment">#将所匹配到的字符串存储在content列表中</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'笔趣阁爬虫数据.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>  <span class="token comment">#以写入的方式将所提取的数据存入txt文件中 'w'代表写入 encoding='utf-8'代表声明文件的编码方式</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> content<span class="token punctuation">:</span>  <span class="token comment">#循环遍历列表</span>         s <span class="token operator">=</span> i<span class="token operator">+</span><span class="token string">'\n'</span>    <span class="token comment">#'\n'代表换行符 每写入一个列表元素之后进行换行</span>         f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token comment">#将列表元素写入文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记</title>
    <link href="/2022/04/20/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/20/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>上传之前的Python学习笔记，顺便测试一下GitHub+PicGo搭建的图床</p></blockquote><h2 id="Python基础语法"><a href="#Python基础语法" class="headerlink" title="Python基础语法"></a>Python基础语法</h2><h3 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a><strong>数字类型转换</strong></h3><p>eval()和float()函数都可以把input() 函数接收到的数值型字符串转为数值类型</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">#输入整数字符串，转换为整数；输入浮点数字符串，转换为浮点数</span>b <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">#输入整数和浮点数，都转换为浮点数</span>c <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">#只接受整数输入，输出为整数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>例：float(‘3.14’) 的结果是数值 3.14</p><p>int()函数可以把整数字符串转为整数</p><p>例：int(‘5’) 的结果是数值 5</p><h3 id="格式化浮点数的两种方法"><a href="#格式化浮点数的两种方法" class="headerlink" title="格式化浮点数的两种方法"></a><strong>格式化浮点数的两种方法</strong></h3><p>方法一：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Interest is"</span><span class="token punctuation">,</span><span class="token builtin">round</span><span class="token punctuation">(</span>interest<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>方法二：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;0:10.nf&#125;"</span><span class="token punctuation">,</span><span class="token builtin">format</span><span class="token punctuation">(</span>interest<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;0:.nf&#125;"</span><span class="token punctuation">,</span><span class="token builtin">format</span><span class="token punctuation">(</span>interest<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p><strong>Note：</strong>{}中的三个数分别表示从第一个字符开始、格式化浮点数后的字符长度、保留到小数点后的第n位</p><p><strong>// 是Python中数学运算符： 整除(向小取整)</strong></p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">5</span> <span class="token operator">/</span> <span class="token number">2</span>     <span class="token comment">#  2.5</span><span class="token number">5</span> <span class="token operator">//</span> <span class="token number">2</span>    <span class="token comment">#  2</span><span class="token operator">-</span><span class="token number">5</span> <span class="token operator">/</span> <span class="token number">2</span>    <span class="token comment"># -2.5</span><span class="token operator">-</span><span class="token number">5</span> <span class="token operator">//</span> <span class="token number">2</span>  <span class="token comment"># -3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="Python-实现一行输入多个数字-用空格隔开"><a href="#Python-实现一行输入多个数字-用空格隔开" class="headerlink" title="Python 实现一行输入多个数字(用空格隔开)"></a><strong>Python</strong> <strong>实现一行输入多个数字(用空格隔开)</strong></h3><p>很多人都会使用以下代码，来实现多个字符串的连续输入，但是这是以换行进行操作的，而有些题目需要将一些数字进行一行输入</p><p>a=input()</p><p>b=input()</p><p><strong>1.实现一行输入多个数字，并以空格隔开。</strong></p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>#运行结果</p><p>1 2</p><p>1 2</p><p>&lt;class ‘int’&gt;</p><p><strong>2.实现一个输入多个单词，每个单词之间用逗号隔开。</strong></p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">str1<span class="token punctuation">,</span>str2<span class="token operator">=</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span>str2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>#运行结果</p><p>love,china</p><p>love china</p><p>&lt;class ‘str’&gt;</p><p>例题：将二进制日期翻译为十进制的形式并输出。例如，日期 00010 00000 00010 00000 00001 00011，翻译为2020年1月3日。int(x,2)：将一个二进制的数字准换为十进制。</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"请输入报道日期，每位二进制数之间用空格隔开"</span><span class="token punctuation">)</span>sstr<span class="token operator">=</span><span class="token string">""</span>year1<span class="token punctuation">,</span>year2<span class="token punctuation">,</span>year3<span class="token punctuation">,</span>year4<span class="token punctuation">,</span>month<span class="token punctuation">,</span>day<span class="token operator">=</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sstr<span class="token operator">=</span>sstr<span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>year1<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>year2<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>year3<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>year4<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"年"</span>sstr<span class="token operator">=</span>sstr<span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>month<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"月"</span>sstr<span class="token operator">=</span>sstr<span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>day<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"日"</span><span class="token keyword">print</span><span class="token punctuation">(</span>sstr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>#运行结果</p><p>请输入报道日期，每位二进制数之间用空格隔开</p><p>00010 00000 00001 00100 00100 00001</p><p>2014年4月1日</p><h3 id="格式化数字和字符串解题报告"><a href="#格式化数字和字符串解题报告" class="headerlink" title="格式化数字和字符串解题报告"></a><strong>格式化数字和字符串解题报告</strong></h3><h4 id="格式化数字："><a href="#格式化数字：" class="headerlink" title="格式化数字："></a><strong>格式化数字：</strong></h4><p>format格式化数字:</p><p><img src="https://github.com/yiqiangshiyia/img/blob/main/images/image-20220420194240729.png?raw=true" alt="format格式化数字"></p><p>格式化浮点数的两种方法：</p><p>方法一：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Interest is"</span><span class="token punctuation">,</span><span class="token builtin">round</span><span class="token punctuation">(</span>interest<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>方法二：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;0:10.nf&#125;"</span><span class="token punctuation">,</span><span class="token builtin">format</span><span class="token punctuation">(</span>interest<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;0:.nf&#125;"</span><span class="token punctuation">,</span><span class="token builtin">format</span><span class="token punctuation">(</span>interest<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>PS:{}中的三个数分别表示从第一个字符开始、格式化浮点数后的字符长度、保留到小数点后的第n位</p><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a><strong>格式化字符串</strong></h4><p><strong>1.format格式化字符串</strong></p><p>format（）方法接受位置参数和关键字参数，两者均传递一个叫做replacement字段，而这个replacement字段在字符串内由大括号表示。</p><p>位置参数：</p><p>字符串中的{0}{1}{2}表示位置，依次被format中的三个参数代换，format中的三个参数就叫做位置参数</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span><span class="token operator">=</span><span class="token string">"&#123;0&#125; prety &#123;1&#125; &#123;2&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"I"</span><span class="token punctuation">,</span><span class="token string">"love"</span><span class="token punctuation">,</span><span class="token string">"python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>I prety love python         </p><p>关键字参数：format将参数中等值的字符串替换进去，这就是关键字参数</p><p>字符串中的{a}{b}{c}相当于三个标签，</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span><span class="token operator">=</span><span class="token string">"&#123;a&#125; prety &#123;b&#125; &#123;c&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token string">"I"</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token string">"love"</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">"python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>I prety love python</p><p>位置参数和关键字参数同时用：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span><span class="token operator">=</span><span class="token string">"&#123;a&#125; prety &#123;b&#125; &#123;c&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token string">"I"</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token string">"love"</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token string">"python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>I prety love python</p><p><strong>2.格式化操作符：%</strong></p><p>%c:格式化字符及其ASCLL值</p><p>%s:格式化字符串</p><p>%d：格式化整数</p><p>%o:格式化无符号八进制数</p><p>%x:格式化无符号十六进制数</p><p>%X格式化无符号十六进制数（大写）</p><p>%f:格式化浮点数字，可指定小数点后的精度</p><p>%e：用科学计数法格式化浮点数</p><h3 id="lambda函数学习"><a href="#lambda函数学习" class="headerlink" title="lambda函数学习"></a>lambda函数学习</h3><p>lambda函数是一种匿名函数，python允许使用lambda 关键字来创建匿名函数，匿名函数比普通函数要简洁。</p><p>lambda函数的使用方法：</p><p>python中lambda函数的使用非常的精简，基本语法是在冒号（：）左边放原函数的参数，可以有多个参数，用逗号（，）隔开即可：冒号右边是返回值。</p><p>举例：</p><p>当只有一个参数的时候：</p><p>普通函数：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ds</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">return</span> <span class="token number">2</span><span class="token operator">*</span>x<span class="token operator">+</span><span class="token number">1</span>y<span class="token operator">=</span>ds<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>输出值为11</p><p>匿名函数：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">y<span class="token operator">=</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">*</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>输出值为11</p><p>当有两个或者两个以上的参数时：</p><p>普通函数：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">return</span> x<span class="token operator">+</span>yz<span class="token operator">=</span>add<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>匿名函数：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">z<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y <span class="token punctuation">:</span> x<span class="token operator">+</span>y<span class="token keyword">print</span><span class="token punctuation">(</span>z<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>lambda函数的作用：</p><p>1.python写一些执行脚本时，使用lambda就可以省下定义函数过程，比如说只是需要写个简单的脚本来管理服务器时，就不需要专门定义一个函数然后再写调用，使用lambda函数就可以使代码变得更加精简。</p><p>2．对于一些比较抽象并且整个程序执行下来只需要调用一两次的函数，有时候给函数起个名字也是比较头疼的问题，使用lambda函数就不需要 考虑命名的问题了。</p><p>3.简化代码的可读性，由于阅读普通函数经常要跳到开头def定义的位置，使用lambda函数就可以省去这样的步骤</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h3><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">string1<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>list_string<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span>string1<span class="token punctuation">)</span>  <span class="token comment">#将字符串转化成列表</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_string<span class="token punctuation">)</span><span class="token comment">#向列表中添加元素</span>list_string<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#append()可以在列表末尾添加单个元素</span>list_string<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">#extend()可以在列表末尾添加多个元素 且元素是以列表的形式添加的</span>list_string<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">#insert()可以在列表的任意位置添加元素 insert()有两个参数 第一个参数代表在列表中的插入位置 第二个参数代表在列表中插入的元素</span><span class="token comment">#从列表中获取元素 类似于数组</span><span class="token comment">#列表分片 列表的分片可以更加快速的获取列表中的元素</span>list_string<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span>  <span class="token comment">#分号前后的两个参数值分别代表元素的位置</span>list_string<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment">#列表分片还可以引入第三个参数步长 步长代表每前进一个步长后再取出一个元素</span>list_string<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment">#特殊情况 当步长为-1时 代表输出一个反转列表</span><span class="token comment">#从列表中删除元素</span>list_string<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>  <span class="token comment">#无需知道元素的位置 若不存在则会报错 remove不能删除指定位置的元素</span><span class="token keyword">del</span> list_string<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment">#del是语句不是列表方法 不用小括号 []中元素代表删除元素的位置</span>list_string<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#pop默认弹出列表中的最后一个元素 当在()中加上索引值也可以删除具体位置的列表元素</span><span class="token comment">#列表比较大小 列表的+ *</span>list_string<span class="token operator">+</span>list_string  <span class="token comment">#+表示连接两个列表</span>list_string<span class="token operator">*</span><span class="token number">3</span>  <span class="token comment">#*表示对列表进行3次复制</span>list_string<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">#count()用于计算()中参数在列表中出现的次数</span>list_string<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">#index()用于返回()中参数在列表中的位置</span>list_string<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment">#index()方法还有两个参数 限定查找范围</span>list_string<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#reverse()对列表进行反转</span>list_string<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#sort()对列表进行排序</span>string2<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>list_string<span class="token punctuation">)</span>  <span class="token comment">#将列表转化成字符串</span><span class="token keyword">print</span><span class="token punctuation">(</span>string2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a><strong>字典和集合</strong></h3><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#创建和访问字典</span>dict1<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"李宁"</span><span class="token punctuation">:</span><span class="token string">"一切皆有可能"</span><span class="token punctuation">,</span><span class="token string">"耐克"</span><span class="token punctuation">:</span><span class="token string">"Just do it"</span><span class="token punctuation">,</span><span class="token string">"阿迪达斯"</span><span class="token punctuation">:</span><span class="token string">"Impossible is nothing"</span><span class="token punctuation">,</span><span class="token string">"鱼C工作室"</span><span class="token punctuation">:</span><span class="token string">"让编程改变时间"</span><span class="token punctuation">&#125;</span><span class="token comment">#冒号：前面的是键 后面的是值</span><span class="token comment">#也可以用dict()来创建字典</span>dict1<span class="token operator">=</span>dict1<span class="token punctuation">(</span>F<span class="token operator">=</span><span class="token number">70</span><span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">105</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">115</span><span class="token punctuation">,</span>h<span class="token operator">=</span><span class="token number">104</span><span class="token punctuation">,</span>C<span class="token operator">=</span><span class="token number">67</span><span class="token punctuation">)</span>dict1<span class="token punctuation">.</span>fromkeys<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"Number"</span><span class="token punctuation">)</span>  <span class="token comment">#fromkeys()用于创建并返回一个新的字典 有两个参数 第一个参数时字典的键 第二个参数时传入键对应的值</span><span class="token comment">#访问字典</span>dict1<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>dict1<span class="token operator">=</span>dict1<span class="token punctuation">.</span>fromkeys<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"赞"</span><span class="token punctuation">)</span>dict1<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#keys()用于返回字典中的键</span>dict1<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#values()用于返回字典中所有的值</span>dict1<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#items()返回字典中所有的键值对</span>dict1<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span>  <span class="token comment">#第二个参数为所设置的默认返回值 可以不加</span>dict1<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#清空字典</span>dict1<span class="token punctuation">.</span>copy  <span class="token comment">#复制字典</span>dict1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">#给定键弹出对应的值</span>dict1<span class="token punctuation">.</span>popitem  <span class="token comment">#弹出一项</span>dict1<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#用来更新字典</span><span class="token comment">#dict1=&#123;"米奇":"老鼠","汤姆":"猫","小白":"猪"&#125;</span><span class="token comment">#dict1.update(小白="狗")</span><span class="token comment">#集合</span><span class="token comment">#集合：用大括号括起来一堆数字 如果没有体现出映射关系就是集合</span><span class="token comment">#集合具有无序性 无法索引集合中的某个元素</span><span class="token comment">#集合会自动删除重复的元素</span><span class="token comment">#创建集合</span>set1<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"小甲鱼"</span><span class="token punctuation">,</span><span class="token string">"小鱿鱼"</span><span class="token punctuation">,</span><span class="token string">"小姑娘"</span><span class="token punctuation">,</span><span class="token string">"小甲鱼"</span><span class="token punctuation">&#125;</span>  <span class="token comment">#用大括号括起来创建</span>set2<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"小甲鱼"</span><span class="token punctuation">,</span><span class="token string">"小鱿鱼"</span><span class="token punctuation">,</span><span class="token string">"小姑娘"</span><span class="token punctuation">,</span><span class="token string">"小甲鱼"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">#直接创建</span><span class="token comment">#访问集合</span><span class="token comment">#集合是无序的所以不能用下标访问 但是可以用迭代的方法访问</span>set1<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> each <span class="token keyword">in</span> set1<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>each<span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token comment">#也可以用in或not in判断元素是否在集合中存在</span>set1<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>  <span class="token comment">#add()方法可以为集合添加元素</span>set1<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment">#remove可以删除集合中的已知元素</span><span class="token comment">#不可变集合</span>set1<span class="token operator">=</span><span class="token builtin">frozenset</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>while和if的区别</title>
    <link href="/2022/04/18/while%E5%92%8Cif%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/18/while%E5%92%8Cif%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天做了两题都以为代码没什么问题，结果提交都没有AC，浪费了很长时间终于明白了。我原来一直有一个知识误区，在判断条件的时候一直把while和if当成等价。但其实while条件和if条件还是有一些区别的。</p></blockquote><p>while语句属于<strong>循环语句</strong>，在判断时，如果条件为true，则会继续判断，直到false为止，即会进行多次判断（除非一开始条件就是错的）</p><p>if语句属于条件<strong>判断语句</strong>，如果条件是true，则继续执行，为false则跳出语句不执行，只会进行单次判断</p><h3 id="while和if相同点"><a href="#while和if相同点" class="headerlink" title="while和if相同点"></a>while和if相同点</h3><p>while与if语句的最大的相同点是都有至少一步的判断。</p><h3 id="while和if不同点"><a href="#while和if不同点" class="headerlink" title="while和if不同点"></a>while和if不同点</h3><p>最大的不同点是：if语句运行完毕后，接着运行下面的语句。而while中的执行语句运行完毕后，还要进行继续判断条件是否符合循环条件，根据判断的条件，返回执行语句或继续运行下面的程序。</p><p>相关题目：<a href="https://leetcode-cn.com/problems/word-pattern/">https://leetcode-cn.com/problems/word-pattern/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和+哈希求和为K的子数组</title>
    <link href="/2022/04/18/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%93%88%E5%B8%8C%E6%B1%82%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/04/18/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%93%88%E5%B8%8C%E6%B1%82%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-560：和为-K-的子数组"><a href="#LeetCode-560：和为-K-的子数组" class="headerlink" title="LeetCode 560：和为 K 的子数组"></a>LeetCode 560：和为 K 的子数组</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>解决数组问题时，如果多层循环遍历超时，多考虑前缀和的思想来减少循环次数降低时间复杂度。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法1：枚举"><a href="#方法1：枚举" class="headerlink" title="方法1：枚举"></a>方法1：枚举</h4><p>两层循环遍历，超出时间限制</p><h4 id="方法2：前缀和-哈希表"><a href="#方法2：前缀和-哈希表" class="headerlink" title="方法2：前缀和+哈希表"></a>方法2：前缀和+哈希表</h4><blockquote><p>我们可以基于方法一利用数据结构进行进一步的优化，我们知道方法一的瓶颈在于对每个 i，我们需要枚举所有的 j 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。</p><p>我们定义 pre[i] 为 0..i 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：<br>pre[i]=pre[i−1]+nums[i]</p><p>那么 j..i 这个子数组和为 k 这个条件我们可以转化为<br>pre[i]−pre[j−1]==k</p><p>简单移项可得符合条件的下标 j 需要满足<br>pre[j−1]==pre[i]−k</p><p>所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1) 时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。</p><p>需要注意的是，从左往右边更新边计算的时候已经保证了mp[pre[i]−k] 里记录的 pre[j] 的下标范围是 0≤j≤i 。同时，由于 pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用 pre 变量来记录 pre[i−1] 的答案即可。</p></blockquote><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        int n &#x3D; nums.size();        unordered_map&lt;int,int&gt; mp;        mp[0] &#x3D; 1;        int pre &#x3D; 0,cnt &#x3D; 0;        for(auto num : nums)        &#123;            pre &#x3D; pre+num;            if(mp.find(pre-k) !&#x3D; mp.end())            &#123;                cnt &#x3D; cnt+mp[pre-k];            &#125;            mp[pre]++;        &#125;        return cnt;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>LeetCode题解：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/">https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.15每日一题</title>
    <link href="/2022/04/15/4-15%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <url>/2022/04/15/4-15%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-385：迷你语法分析器"><a href="#LeetCode-385：迷你语法分析器" class="headerlink" title="LeetCode 385：迷你语法分析器"></a>LeetCode 385：迷你语法分析器</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>一道题做了一个多小时，人都麻了… 4.15今天日子也很特殊 哈哈哈！</p></blockquote><p>这道题的 NestedInteger 其实就是定义的一个新的数据类型，相当于集合之类的。核心思想就是栈的嵌套，先把 NestedInteger 类型的数字放入栈中，然后再将栈顶的元素top嵌套入栈的top-1中。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。</p><p>列表中的每个元素只可能是整数或整数嵌套列表</p><p>示例1</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;324&quot;,输出：324解释：你应该返回一个 NestedInteger 对象，其中只包含整数值 324。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>示例2</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;[123,[456,[789]]]&quot;,输出：[123,[456,[789]]]解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：1. 一个 integer 包含值 1232. 一个包含两个元素的嵌套列表：    i.  一个 integer 包含值 456    ii. 一个包含一个元素的嵌套列表         a. 一个 integer 包含值 789<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法1：深度优先搜索"><a href="#方法1：深度优先搜索" class="headerlink" title="方法1：深度优先搜索"></a>方法1：深度优先搜索</h4><p>模拟</p><h4 id="方法2：栈"><a href="#方法2：栈" class="headerlink" title="方法2：栈"></a>方法2：栈</h4><p><img src="https://raw.githubusercontent.com/yiqiangshiyia/img/main/images/QQ%E6%88%AA%E5%9B%BE20220415164146.png" alt="图示模拟栈的过程"></p><p>当s[i] == ‘[‘时：建立一个’[]’，放入栈中</p><p>当isdigit(s[i])时：记录数字num</p><p>当s[i] == ‘,’ || s[i] == ‘]’时：如果数字不为空，将数字加入栈顶，重置数字num = 0</p><p>当s[i] == ‘]’ &amp;&amp; st.size()&gt;1时，将栈顶元素加入栈顶的倒数第二个元素中，直到栈的到小为1</p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    NestedInteger deserialize(string s) &#123;        if(s[0] !&#x3D; &#39;[&#39;)  return NestedInteger(stoi(s));        stack&lt;NestedInteger&gt; st;        int num &#x3D; 0;        bool flag &#x3D; false;        for(int i&#x3D;0; i&lt;s.size(); i++)        &#123;            if(s[i] &#x3D;&#x3D; &#39;[&#39;)            &#123;                st.push(NestedInteger());            &#125;else if(s[i] &#x3D;&#x3D; &#39;-&#39;)            &#123;                flag &#x3D; true;            &#125;else if(isdigit(s[i]))            &#123;                num &#x3D; num*10 + s[i]-&#39;0&#39;;            &#125;else if(s[i] &#x3D;&#x3D; &#39;,&#39; || s[i] &#x3D;&#x3D; &#39;]&#39;)            &#123;                if(isdigit(s[i-1]))                &#123;                    if(flag)  num &#x3D; num*-1;                    st.top().add(NestedInteger(num));                    num &#x3D; 0;                    flag &#x3D; false;                &#125;                if(s[i] &#x3D;&#x3D; &#39;]&#39; &amp;&amp; st.size() &gt; 1)                &#123;                    NestedInteger ni &#x3D; st.top();                    st.pop();                    st.top().add(ni);                &#125;            &#125;        &#125;        return st.top();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>b栈学习视频：<a href="https://www.bilibili.com/video/BV195411U7h4?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV195411U7h4?spm_id_from=333.337.search-card.all.click</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dapp学习</title>
    <link href="/2022/04/14/Dapp%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/04/14/Dapp%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Dapp"><a href="#Dapp" class="headerlink" title="Dapp"></a>Dapp</h2><h3 id="Dapp原理"><a href="#Dapp原理" class="headerlink" title="Dapp原理"></a>Dapp原理</h3><p>中心化app的数据存储在中心化服务器上，dapp的数据存储在区块链上</p><h3 id="Dapp开发环境"><a href="#Dapp开发环境" class="headerlink" title="Dapp开发环境"></a>Dapp开发环境</h3><blockquote><p>以太坊：以太坊（英文Ethereum）是一个开源的有智能合约功能的公共区块链平台，通过其专用加密货币以太币（Ether，简称“ETH”）提供去中心化的以太虚拟机（Ethereum Virtual Machine）来处理点对点合约。</p></blockquote><p>基于以太坊的开发环境</p><ul><li><p>geth+js</p></li><li><p>ganache+js（主要）</p></li><li><p>truffle（js框架 以太坊官方提供的框架）</p></li></ul><h3 id="Geth私链环境搭建"><a href="#Geth私链环境搭建" class="headerlink" title="Geth私链环境搭建"></a>Geth私链环境搭建</h3><p>geth是以太坊的一个客户端</p><ul><li><p>安装geth</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">$ sudo apt-get install software-properties-common$ sudo add-apt-repository -y ppa:ethereum&#x2F;etherum$ sudo apt-get update$ sudo apt-get install etherum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ul><h3 id="ganache使用"><a href="#ganache使用" class="headerlink" title="ganache使用"></a>ganache使用</h3><ul><li><p>ganache</p><p>目前主流的基于以太坊开发Dapp的方式主要是ganache和truffle</p><p>ganache的github地址：<a href="https://link.zhihu.com/?target=https://github.com/trufflesuite/ganache/releases">https://</a><a href="https://github.com/trufflesuite/ganache/releases">https://github.com/trufflesuite/ganache/releases</a></p><blockquote><p>Ganache可以快速启动个人以太坊区块链，并可以使用它来运行测试，执行命令、检查状态，同时控制链条的运行方式。通过Ganache我们可以快速查看所有账户的当前状态，包括他们的地址、私钥、交易和余额。查看Ganache内部区块链的日志输出，包括响应和其他重要的调试信息，检查所有块和交易，以获取相关问题的信息。</p></blockquote></li><li><p>连接ganache节点-Remix连接节点</p></li><li><p>连接ganache节点-MetaMask连接节点（导入账号）</p></li></ul><p>知乎上有具体使用方法：<a href="https://zhuanlan.zhihu.com/p/46524142">https://zhuanlan.zhihu.com/p/46524142</a></p><h3 id="使用Web3js和区块链进行交互"><a href="#使用Web3js和区块链进行交互" class="headerlink" title="使用Web3js和区块链进行交互"></a>使用Web3js和区块链进行交互</h3><ul><li>express安装</li><li>创建工程</li><li>和区块链交互</li><li>运行</li></ul><h3 id="智能合约编写、部署"><a href="#智能合约编写、部署" class="headerlink" title="智能合约编写、部署"></a>智能合约编写、部署</h3><p><a href="http://remix.hubwiz.com/#optimize=false&version=soljson-v0.5.1+commit.c8a2cb62.js">智能合约在线编译器</a></p><h3 id="完整Dapp-demo"><a href="#完整Dapp-demo" class="headerlink" title="完整Dapp demo"></a>完整Dapp demo</h3><ul><li><p>编写智能合约</p></li><li><p>编译合约</p><p>在remix上进行编译</p><blockquote><p>智能合约在线编译器：<a href="http://remix.hubwiz.com/#optimize=false&amp;version=soljson-v0.5.1+commit.c8a2cb62.js">http://remix.hubwiz.com/#optimize=false&amp;version=soljson-v0.5.1+commit.c8a2cb62.js</a></p></blockquote></li><li><p>部署合约</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">ganache-climkdir deploy-projcd deploy-projnpm install web3 -save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>编写deploy.js</p><p>部署</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">node deploy.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>创建工程</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">express -e dapp4cd dapp4npm installnpm start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>修改app.js</p></li><li><p>修改route/index.js</p></li><li><p>编辑view/index.html</p></li><li><p>运行</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">ganache-clinpm_start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li></ul><h3 id="使用truffle"><a href="#使用truffle" class="headerlink" title="使用truffle"></a>使用truffle</h3><ul><li><p>truffle介绍</p><p>Truffle是针对基于以太坊的Solidity语言的一套开发框架，本身基于Javascript。</p><p>官方学习文档：<a href="https://learnblockchain.cn/docs/truffle/index.html">https://learnblockchain.cn/docs/truffle/index.html</a></p></li><li><p>安装truffle</p><p>只要通过以下命令就可以安装Truffle</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm install -g truffle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>写合约</p><p>写完合约之后在remix中调试</p></li><li><p>创建工程</p><ul><li>使用命令创建工程</li></ul><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">mkdir Votecd Votetruffle unbox webpack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><ul><li>创建合约</li></ul><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">cd contractsrm meta.solrm Lib.solvim Voting.sol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li><p>将上面的合约代码复制到Voting.sol中</p></li><li><p>修改migrations/_deploy_contracts.js</p></li></ul></li><li><p>编译合约</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">truffle compile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>部署合约</p><ul><li><p>启动ganache-cli</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">ganache-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>修改truffle-config.js</p></li><li><p>部署</p></li><li><p>部署完后可以用truffle console进行测试</p></li></ul></li><li><p>修改前端页面</p><p>修改app/src/index.html</p><p>修改app/src/index.js</p></li><li><p>运行</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>打开浏览器，输入127.0.0.1:8080</p><p><strong>使用truffle完成投票dapp的开发实例</strong></p><p>1、投票的智能合约</p><p>投票智能合约代码：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">pragma solidity &gt;&#x3D;0.4.22 &lt;0.6.0;contract Voting &#123;    bytes32[] public candidateList;    mapping(bytes32 &#x3D;&gt; uint8) public votesReceived;    constructor(bytes32[] memory candidateListName) public  &#123;        candidateList &#x3D; candidateListName;    &#125;    function validateCanditate(bytes32 candidateName)internal view returns(bool) &#123;        for (uint8 i &#x3D;0; i &lt; candidateList.length; i++) &#123;            if (candidateName &#x3D;&#x3D; candidateList[i])                return true;        &#125;        return false;        &#125;    function voteForCandidate(bytes32 candidateName) public &#123;        require(validateCanditate(candidateName));        votesReceived[candidateName] +&#x3D; 1;    &#125;    function totalVotesFor(bytes32 candidateName) view public returns(uint8) &#123;        require(validateCanditate(candidateName));        return votesReceived[candidateName];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>2、合约的编译部署</p><p>3、编写前端页面</p><p>4、和智能合约的交互</p></li></ul><p>区块链学习官站：<a href="https://learnblockchain.cn/">https://learnblockchain.cn/</a></p><p>区块链、超级账本、智能合约等概念官网文档 <a href="https://gitee.com/link?target=https://hyperledger-fabric.readthedocs.io/en/release-1.4/">https://hyperledger-fabric.readthedocs.io/en/release-1.4/</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 字符串</title>
    <link href="/2022/04/11/C-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/04/11/C-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a>C++ 字符串</h2><h2 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h2><h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a>push_back()函数</h3><blockquote><p>push_back()函数的用法</p><p>函数将一个新的元素加到vector的最后面，位置为当前最后一个元素的下一个元素。</p></blockquote><p><strong>push_back()函数也同样适用于string字符串</strong></p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str &#x3D; &quot;&quot;;str.push_back(&#39;d&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>类似的：</p><p>pop_back()    //移除最后一个元素</p><p>clear()    //清空所有元素</p><p>empty()    //判断vector是否为空，如果返回true为空</p><p>erase()    // 删除指定元素</p><h3 id="reverse-函数"><a href="#reverse-函数" class="headerlink" title="reverse()函数"></a>reverse()函数</h3><p>对字符串进行翻转的函数</p><p>reverse(s.begin(),s.end());</p><h3 id="str-‘0’"><a href="#str-‘0’" class="headerlink" title="str-‘0’"></a>str-‘0’</h3><p>实际就是减去 ‘0’ 的ASCII码值，也就是一个整数。</p><p>对字符串进行类型转换（string→int）</p><h3 id="isdigit-函数"><a href="#isdigit-函数" class="headerlink" title="isdigit()函数"></a>isdigit()函数</h3><p>C ++库函数 void isalpha(int c) 检查所传的字符是否是字母。</p><h3 id="isalpha-函数"><a href="#isalpha-函数" class="headerlink" title="isalpha()函数"></a>isalpha()函数</h3><p>C ++库函数 void isalpha(int c) 检查所传的字符是否是字母。</p><h3 id="add-函数"><a href="#add-函数" class="headerlink" title="add()函数"></a>add()函数</h3><h3 id="stoi-函数"><a href="#stoi-函数" class="headerlink" title="stoi()函数"></a>stoi()函数</h3><p>stoi函数中放入string类型的参数，可以把string类型转换成int类型</p><h3 id="substr-函数"><a href="#substr-函数" class="headerlink" title="substr()函数"></a>substr()函数</h3><p>用途：一种构造string的方法，也可以用来复制字符串的一部分</p><p>形式：s.substr(pos, n)</p><p>解释：返回一个string，包含s中从pos开始的n个字符的拷贝（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）</p><p>补充：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾</p><h3 id="tolower-函数"><a href="#tolower-函数" class="headerlink" title="tolower()函数"></a>tolower()函数</h3><p>C ++库函数 int tolower(int c) 把给定的字母转换为小写字母。</p><h3 id="toupper-函数"><a href="#toupper-函数" class="headerlink" title="toupper()函数"></a>toupper()函数</h3><p>C ++库函数 int toupper(int c) 把给定的字母转换为大写字母。</p><h3 id="string-back-函数"><a href="#string-back-函数" class="headerlink" title="string.back()函数"></a>string.back()函数</h3><p>C++string.back()函数 此函数同于访问字符串的最后一个字符 。</p><h3 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a>find()函数</h3><p>C++ string中的find()函数，string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数）</p><ul><li><p>返回子串出现在母串中的首次出现的位置，和最后一次出现的位置。</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">flag &#x3D; &quot;c&quot;;position &#x3D; s.find_first_of(flag);printf(&quot;s.find_first_of(flag) is :%d\n&quot;,position);position &#x3D; s.find_last_of(flag);printf(&quot;s.find_last_of(flag) is :%d\n&quot;,position);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>查找某一给定位置后的子串的位置</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;从字符串s 下标5开始，查找字符串b ,返回b 在s 中的下标  position&#x3D;s.find(&quot;b&quot;,5);  cout&lt;&lt;&quot;s.find(b,5) is : &quot;&lt;&lt;position&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li><li><p>查找所有子串在母串中出现的位置</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;查找s 中flag 出现的所有位置。    char flag&#x3D;&quot;a&quot;;    int position&#x3D;0;    int i&#x3D;1;    while((position&#x3D;s.find(flag,position))!&#x3D;string::npos)    &#123;        cout&lt;&lt;&quot;position  &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;position&lt;&lt;endl;        position++;        i++;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ul><h2 id="C-数据类型转换"><a href="#C-数据类型转换" class="headerlink" title="C++ 数据类型转换"></a>C++ 数据类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><blockquote><p>自动类型转换是指在不同类型数据进行混合运算时，系统会自动进行数据类型的转换。</p></blockquote><p>string→int</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str;cout&lt;&lt;str-&#39;0&#39;cout&lt;&lt;str-&#39;a&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>int→string</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><blockquote><p>强制类型转换在表达式中可以根据需要把任意一个数据的类型转换成另一个数据类型。强制类型转换是靠强制类型转换控制运算符实现的。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; double(2.5);double b &#x3D; double(12);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p><a href="http://c.biancheng.net/view/208.html">http://c.biancheng.net/view/208.html</a></p><p><a href="https://blog.csdn.net/weixin_46274168/article/details/117209139">https://blog.csdn.net/weixin_46274168/article/details/117209139</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL:map unordered_map set unordered_set的用法和区别</title>
    <link href="/2022/04/10/C-STL-map-unordered-map-set-unordered-set%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/10/C-STL-map-unordered-map-set-unordered-set%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><table><thead><tr><th align="center"><strong>数据结构</strong></th><th align="center"><strong>map</strong></th><th align="center"><strong>unordered_map</strong></th><th align="center"><strong>set</strong></th><th align="center"><strong>unordered_set</strong></th></tr></thead><tbody><tr><td align="center">实现机理</td><td align="center">红黑树</td><td align="center">hash表</td><td align="center">红黑树</td><td align="center">hash表</td></tr><tr><td align="center">元素格式</td><td align="center">key+value</td><td align="center">key+value</td><td align="center">key</td><td align="center">key</td></tr><tr><td align="center">存储规律</td><td align="center">键升序</td><td align="center">无序</td><td align="center">键升序</td><td align="center">无序</td></tr><tr><td align="center">元素重复</td><td align="center">键不可,值可</td><td align="center">键不可,值可</td><td align="center">不可重复</td><td align="center">不可重复</td></tr><tr><td align="center">头文件</td><td align="center">#include&lt; map&gt;</td><td align="center">#include<unordered_map></td><td align="center">#include&lt; set&gt;</td><td align="center">#include<unordered_set></td></tr></tbody></table><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h4 id="内部实现机理"><a href="#内部实现机理" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>map内部实现了一个 红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树）， 红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p><h4 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a><strong>优缺点以及适用处</strong></h4><p>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作；红黑树，内部实现一个红黑树使得map的很多操作在O(logN)的时间复杂度下就可以实现，因此效率非常的高。</p><p>缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率（低于unorder_map），但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间（但占用的内存比unorder_map低）</p><p>适用处：对于那些数据存储有顺序要求的问题，用map会更高效一些</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>1.构造函数 2.插入数据 3.判断是否有元素 4.遍历 5.查找 </p><p>参考博客</p><p><a href="https://blog.csdn.net/weixin_45774972/article/details/113418453?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">C++ 中使用哈希表(unordered_map)的常用操作</a> </p><p><a href="https://lover.blog.csdn.net/article/details/82633778?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&utm_relevant_index=6">简述C++中map和unordered_map的用法</a> </p><p><a href="https://blog.csdn.net/qq_30815237/article/details/91047041">C++ map set unordered_map和unorder_set的区别</a></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; list &#x3D; &#123; 5,14,34,22,39,5 &#125;;map&lt;int, int&gt; map;for (int i &#x3D; list.size() - 1; i &gt;&#x3D; 0; i--) &#123;map[i] &#x3D; list[i];  &#x2F;&#x2F;倒序插入&#125;for (auto i &#x3D; map.begin(); i !&#x3D; map.end(); i++) &#123;cout &lt;&lt; i-&gt;first &lt;&lt; &#39; &#39; &lt;&lt; i-&gt;second &lt;&lt; endl;  &#x2F;&#x2F;输出的数是有序的且有两个5&#125;if (map.find(3) !&#x3D; map.end()) &#123;cout &lt;&lt; &quot;find key&#x3D;&quot; &lt;&lt; map.find(3)-&gt;first &lt;&lt; &quot;, value&#x3D;&quot; &lt;&lt; map.find(3)-&gt;second &lt;&lt; endl;&#125;if (map.count(5) &gt; 0) &#123;  &#x2F;&#x2F;m.count(n)计算下标为n的位置有无数据，有返回1，无返回0cout &lt;&lt; &quot;count 5: &quot; &lt;&lt; map.count(5) &lt;&lt; endl;  &#x2F;&#x2F;find()和count()的输入参数都是key值&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>map是基于RBT的，因此元素是有序存储的（默认按键的升序排列）。</p></blockquote><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><h4 id="内部实现机理-1"><a href="#内部实现机理-1" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>unordered_map内部实现了一个 哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此， 其元素的排列顺序是无序的。</p><h4 id="优缺点以及适用处-1"><a href="#优缺点以及适用处-1" class="headerlink" title="优缺点以及适用处"></a><strong>优缺点以及适用处</strong></h4><p>优点： 因为内部实现了哈希表，因此其查找速度非常的快（运行效率快于map）</p><p>缺点： 哈希表的建立比较耗费时间（unorder_map占用的内存比map要高）</p><p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><p>1.构造函数 2.插入数据 3.判断是否有元素 4.遍历 5.查找 </p><p><a href="https://blog.csdn.net/weixin_45774972/article/details/113418453?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">C++ 中使用哈希表(unordered_map)的常用操作</a> </p><p><a href="https://lover.blog.csdn.net/article/details/82633778?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.pc_relevant_antiscan&utm_relevant_index=6">简述C++中map和unordered_map的用法</a> </p><p><a href="https://blog.csdn.net/qq_30815237/article/details/91047041">C++ map set unordered_map和unorder_set的区别</a></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><div class="code-wrapper"><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;int&gt; list &#x3D; &#123; 5,14,34,22,39,5 &#125;;unordered_map&lt;int, int&gt; map;for (int i &#x3D; list.size()-1; i&gt;&#x3D;0; i--) &#123;map[i] &#x3D; list[i];  &#x2F;&#x2F;倒序插入&#125;cout &lt;&lt; map[0] &lt;&lt; endl;for (unordered_map&lt;int, int&gt;::iterator i &#x3D; map.begin(); i !&#x3D; map.end(); i++) &#123;cout &lt;&lt; i-&gt;first &lt;&lt; &#39; &#39; &lt;&lt; i-&gt;second &lt;&lt; endl;  &#x2F;&#x2F;输出的数是有序的且有两个5&#125;if (map.find(3) !&#x3D; map.end()) &#123;cout &lt;&lt; &quot;find key&#x3D;&quot; &lt;&lt; map.find(3)-&gt;first &lt;&lt; &quot;, value&#x3D;&quot; &lt;&lt; map.find(3)-&gt;second &lt;&lt; endl;&#125;if (map.count(5) &gt; 0) &#123;  &#x2F;&#x2F;m.count(n)计算下标为n的位置有无数据，有返回1，无返回0cout &lt;&lt; &quot;find 5: &quot; &lt;&lt; map.count(5) &lt;&lt; endl;  &#x2F;&#x2F;find()和count()的输入都是key值&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>unordered_map 是基于hash表的，因此元素是无序存储的（不按键升序排列）。</p></blockquote><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h4 id="内部实现机理-2"><a href="#内部实现机理-2" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; list &#x3D; &#123; 5,14,34,22,39,5 &#125;;set&lt;int&gt; set1;for (int i &#x3D; list.size() - 1; i &gt;&#x3D; 0; i--) &#123;set1.insert(list[i]);  &#x2F;&#x2F;倒序插入&#125;for (auto i &#x3D; set1.begin(); i !&#x3D; set1.end(); i++) &#123;cout &lt;&lt; *i &lt;&lt; endl;  &#x2F;&#x2F;输出的数是有序的且只有一个5&#125;cout &lt;&lt; &quot;find 5: &quot; &lt;&lt; *set1.find(5) &lt;&lt; endl;cout &lt;&lt;&quot;count 5: &quot; &lt;&lt; set1.count(5) &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>set 是基于RBT的，因此元素是顺序存储的（默认按键值升序排列）。</p></blockquote><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><h4 id="内部实现机理-3"><a href="#内部实现机理-3" class="headerlink" title="内部实现机理"></a><strong>内部实现机理</strong></h4><p>unordered_set的内部实现了一个 哈希表，因此， 其元素的排列顺序是无序的。</p><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; list &#x3D; &#123; 5,14,34,22,39,5 &#125;;unordered_set&lt;int&gt; set;for (int i &#x3D; list.size() - 1; i &gt;&#x3D; 0; i--) &#123;set.insert(list[i]);  &#x2F;&#x2F;倒序插入&#125;for (unordered_set&lt;int&gt;::iterator i &#x3D; set.begin(); i !&#x3D; set.end(); i++) &#123;cout &lt;&lt; *i &lt;&lt; endl;  &#x2F;&#x2F;输出的数是无序的且只有一个5&#125;cout &lt;&lt; &quot;find 39: &quot; &lt;&lt; *set.find(39) &lt;&lt; endl;cout &lt;&lt; &quot;count 14:&quot; &lt;&lt; set.count(14) &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>unordered_set 是基于hash表的，因此元素是无序存储的（不按键值升序排列）。</p></blockquote><h2 id="unordered-map与unordered-set的区别"><a href="#unordered-map与unordered-set的区别" class="headerlink" title="unordered_map与unordered_set的区别"></a>unordered_map与unordered_set的区别</h2><blockquote><p>后者就是在哈希表插入value，而这个value就是它自己的key，而不是像之前的unordered_map那样有键-值对，这里单纯就是为了方便查询这些值。</p><p>它们几乎相同. unordered_set只包含键,没有值.没有从键到值的映射,因此不需要operator[]. unordered_map将键映射到值.</p></blockquote><h2 id="unordered-map与map的区别"><a href="#unordered-map与map的区别" class="headerlink" title="unordered_map与map的区别"></a>unordered_map与map的区别</h2><blockquote><p>这两个的内部结构都是采用哈希表来实现。区别在哪里？unordered_map在C++11的时候被引入标准库了，而hash_map没有，所以建议还是使用unordered_map比较好。</p></blockquote><h2 id="hash-map与unordered-map的区别"><a href="#hash-map与unordered-map的区别" class="headerlink" title="hash_map与unordered_map的区别"></a>hash_map与unordered_map的区别</h2><blockquote><p>虽然都是map，但是内部结构大大的不同哎，map的内部结构是R-B-tree来实现的，所以保证了一个稳定的动态操作时间，查询、插入、删除都是O（logN），最坏和平均都是。而unordered_map如前所述，是哈希表。顺便提一下，哈希表的查询时间虽然是O（1），但是并不是unordered_map查询时间一定比map短，因为实际情况中还要考虑到数据量，而且unordered_map的hash函数的构造速度也没那么快，所以不能一概而论，应该具体情况具体分析。</p></blockquote><p>参考博客：</p><p><a href="https://blog.csdn.net/bryant_zhang/article/details/111600209">C++：map,unordered_map,set和unordered_set的用法和区别</a></p><p><a href="https://blog.csdn.net/u013195320/article/details/23046305?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&utm_relevant_index=1">C++中map、hash_map、unordered_map、unordered_set通俗辨析</a></p><p> </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「数据库系统概论」期末复习</title>
    <link href="/2022/04/07/%E3%80%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8D%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/04/07/%E3%80%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8D%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h1><p><a href="https://youpai.roccoshi.top/img/20210107010414.png"><img src="https://youpai.roccoshi.top/img/20210107010414.png" alt="img"></a></p><h1 id="2-关系数据库"><a href="#2-关系数据库" class="headerlink" title="2. 关系数据库"></a>2. 关系数据库</h1><h2 id="1-关系数据结构及形式化定义"><a href="#1-关系数据结构及形式化定义" class="headerlink" title="1 | 关系数据结构及形式化定义"></a>1 | 关系数据结构及形式化定义</h2><p>关系模型中数据的逻辑结构是一张扁平的二维表</p><p>关系是笛卡尔积的有限子集，所以关系也是一张二维表</p><p><strong>候选码</strong>：若关系中某一属性的值能唯一标识一个元组，而其子集不能，则称该属性组为候选码</p><p><strong>主码</strong>：若一个关系中有多个候选码，则选定其中一个为主码</p><p><strong>主属性</strong>：候选码的诸属性称为主属性</p><p><strong>非主属性</strong>：不包含在任何候选码中的属性称为非主属性或非码属性</p><p><strong>全码</strong>：关系模式的所有属性是这个关系模式的候选码，称为全码</p><h2 id="2-关系的完整性"><a href="#2-关系的完整性" class="headerlink" title="2 | 关系的完整性"></a>2 | 关系的完整性</h2><p>关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。</p><h2 id="3-关系代数"><a href="#3-关系代数" class="headerlink" title="3| 关系代数"></a>3| 关系代数</h2><h4 id="3-1-传统的集合运算"><a href="#3-1-传统的集合运算" class="headerlink" title="3-1 | 传统的集合运算"></a>3-1 | 传统的集合运算</h4><p>并、叉、交、笛卡尔积</p><h4 id="3-2-专门的关系运算"><a href="#3-2-专门的关系运算" class="headerlink" title="3-2 | 专门的关系运算"></a>3-2 | 专门的关系运算</h4><p>选择</p><p>投影：投影操作 是从列的角度进行运算</p><p>连接：两种常用的连接：等值连接和自然连接</p><p>除运算：除法是用象集来定义的</p><p>关系代数的五个基本操作：其余三种运算可以用这五种基本运算来表达</p><p><a href="https://youpai.roccoshi.top/img/20210107010534.png"><img src="https://youpai.roccoshi.top/img/20210107010534.png" alt="img"></a></p><p>关系代数中可能会用到的各个符号:</p><p><a href="https://youpai.roccoshi.top/img/20210107010616.png"><img src="https://youpai.roccoshi.top/img/20210107010616.png" alt="img"></a></p><h1 id="3-关系数据库标准语言SQL"><a href="#3-关系数据库标准语言SQL" class="headerlink" title="3. 关系数据库标准语言SQL"></a>3. 关系数据库标准语言SQL</h1><h2 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1 | SQL概述"></a>1 | SQL概述</h2><h3 id="1-1-SQL的特点"><a href="#1-1-SQL的特点" class="headerlink" title="1-1 | SQL的特点"></a>1-1 | SQL的特点</h3><p>1、综合统一 </p><p>2、高度非过程化</p><p>3、面向集合的操作方式</p><p>4、以同一种语法结构提供多种使用方式</p><p>5、语言简洁，易学易用</p><h3 id="1-2-SQL与三级模式体系结构图"><a href="#1-2-SQL与三级模式体系结构图" class="headerlink" title="1-2 | SQL与三级模式体系结构图"></a>1-2 | SQL与<strong>三级模式</strong>体系结构图</h3><p><a href="https://youpai.roccoshi.top/img/20210106174625.png"><img src="https://youpai.roccoshi.top/img/20210106174625.png" alt="image-20201226123540167"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174625.png">image-20201226123540167</a></p><p>模式：模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征描述，是所有用户的公共数据视图</p><p>外模式：外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</p><p>内模式：内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式</p><h2 id="2-数据定义"><a href="#2-数据定义" class="headerlink" title="2 | 数据定义"></a>2 | 数据定义</h2><p>SQL数据的定义功能：定义各种数据库的对象</p><p>SQL数据库定义功能包括模式定义、表定义、视图定义和索引定义</p><p><a href="https://youpai.roccoshi.top/img/20210106174626.png"><img src="https://youpai.roccoshi.top/img/20210106174626.png" alt="image-20201226123755751"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174626.png">image-20201226123755751</a></p><p>数据库对象命名机制的层次结构：</p><p>一个关系数据库管理系统中可以建立多个数据库，一个数据库可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</p><h3 id="2-1-模式的定义与删除"><a href="#2-1-模式的定义与删除" class="headerlink" title="2-1 | 模式的定义与删除"></a>2-1 | 模式的定义与删除</h3><h3 id="2-2-基本表的定义、删除与修改"><a href="#2-2-基本表的定义、删除与修改" class="headerlink" title="2-2 | 基本表的定义、删除与修改"></a>2-2 | 基本表的定义、删除与修改</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token operator">&lt;</span>name<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h4 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h4><p>格式</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">(</span>    <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token operator">&lt;</span>列级完整性约束条件<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token operator">&lt;</span>列级完整性约束条件<span class="token operator">></span><span class="token punctuation">,</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">&lt;</span>表级完整性约束条件<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>列级完整性约束条件</p><p>表级完整性约束条件</p><p>实例：建立一个 “课程” 表Course</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Course<span class="token punctuation">(</span>Cno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>  <span class="token comment">/*列级完整性约束条件，Cno是主码*/</span>     Cname <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token comment">/*列级完整性约束条件，Cname不能取空值*/</span>     Cpno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">/*Cpno的含义是先修课*/</span>     Ccredit <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span>     <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Cpno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Course<span class="token punctuation">(</span>Cno<span class="token punctuation">)</span>     <span class="token comment">/*表级完整性约束条件，Cpno是外码，被参照表是Course，被参照对的列是Cno*/</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>常用的完整性约束:</p><p><a href="https://youpai.roccoshi.top/img/20210106174627.png"><img src="https://youpai.roccoshi.top/img/20210106174627.png" alt="image-20201226125004438"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174627.png">image-20201226125004438</a></p><h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><p>格式</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">ADD</span><span class="token punctuation">[</span><span class="token keyword">COLUMN</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>新列名<span class="token operator">></span><span class="token operator">&lt;</span>数据类型<span class="token operator">></span><span class="token punctuation">[</span>完整性约束<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">ADD</span><span class="token operator">&lt;</span>表级完整性约束<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">DROP</span><span class="token punctuation">[</span><span class="token keyword">COLUMN</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">CASCADE</span><span class="token operator">|</span><span class="token keyword">RESTRICT</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">DROP</span> <span class="token keyword">CONSTRAINT</span><span class="token operator">&lt;</span>完整性约束名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">RESTRICT</span><span class="token operator">|</span><span class="token keyword">CASCADE</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token operator">&lt;</span>数据类型<span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h4><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">RESTRICT</span><span class="token operator">|</span><span class="token keyword">CASCADE</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><blockquote><p>RESTRICT：若选择RESTRICT，则该表的删除是有限制条件的</p><p>CASCADE：若选择CASCADE，则该表的删除是没有限制条件的</p></blockquote><h2 id="3-数据查询（重点）"><a href="#3-数据查询（重点）" class="headerlink" title="3 | 数据查询（重点）"></a>3 | 数据查询（重点）</h2><p>语法:</p><p><a href="https://youpai.roccoshi.top/img/20210106174628.png"><img src="https://youpai.roccoshi.top/img/20210106174628.png" alt="image-20201226130756283"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174628.png">image-20201226130756283</a></p><h3 id="3-1-单表查询"><a href="#3-1-单表查询" class="headerlink" title="3-1 | 单表查询"></a>3-1 | 单表查询</h3><h4 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h4><p><a href="https://youpai.roccoshi.top/img/20210106174629.png"><img src="https://youpai.roccoshi.top/img/20210106174629.png" alt="image-20201226130825216"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174629.png">image-20201226130825216</a></p><p>例子：</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">where</span> age <span class="token operator">between</span> <span class="token number">20</span> <span class="token operator">and</span> <span class="token number">23</span><span class="token punctuation">;</span>    <span class="token comment">/*找年龄20-23岁的*/</span><span class="token keyword">where</span> dept <span class="token operator">not</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'is'</span><span class="token punctuation">,</span> <span class="token string">'ma'</span><span class="token punctuation">,</span> <span class="token string">'cs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*查询不是is, ma, cs系得*/</span><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'刘%'</span><span class="token punctuation">;</span>    <span class="token comment">/*找姓刘的*/</span><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'__阳'</span><span class="token punctuation">;</span>    <span class="token comment">/*找名字叫xx阳的*/</span><span class="token keyword">where</span> cname <span class="token operator">like</span> <span class="token string">'DB\_Design'</span> <span class="token keyword">ESCAPE</span> '\'<span class="token punctuation">;</span><span class="token comment">/*escape定义转义字符, 出现在其后的第一个字符不是通配符而是字符本身*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="ORDER-BY字句"><a href="#ORDER-BY字句" class="headerlink" title="ORDER BY字句"></a>ORDER BY字句</h4><p>用户可以用ORDER BY字句对查询结果按照一个或多个属性的升序（ASC）或降序（DESC）排列，默认值为升序。</p><p>对属性列排序：</p><ul><li>asc为升序</li><li>desc为降序</li><li>默认为升序</li></ul><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">/*查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列*/</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> Student<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Sdept<span class="token punctuation">,</span>Sage <span class="token keyword">DESC</span><span class="token punctuation">;</span>  <span class="token comment">/*Sdept默认升序*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token operator">|</span><span class="token keyword">ALL</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span><span class="token function">SUM</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token operator">|</span><span class="token keyword">ALL</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span><span class="token function">AVG</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token operator">|</span><span class="token keyword">ALL</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span><span class="token function">MAX</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token operator">|</span><span class="token keyword">ALL</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span><span class="token function">MIN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token operator">|</span><span class="token keyword">ALL</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>如果指定DISTINCT短语，则表示在计算时要取消指定列中的重复行。如果不指定DISTINCT短语或者ALL短语（ALL为默认值），则表示不取消重复行。</p></blockquote><h4 id="GROUP-BY短语"><a href="#GROUP-BY短语" class="headerlink" title="GROUP BY短语"></a>GROUP BY短语</h4><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token keyword">HAVING</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>GROUP BY子句将查询结果按某一列或多列的值分组，值相等的为一组。</p><p>分散后聚集函数将作用于每一个组，即每一组都有一个函数值。</p><p>Note:</p><p>按指定的一列或者多列分组, 值相等的为一组, HAVING子句作用于各个组之上</p><ul><li>如果未对查询结果分组, 集函数作用于整个查询结果</li><li>对查询结果分组后, 集函数分别作用于各个组</li><li>使用GROUP BY子句后, SELECT子句的列名表中只能出现分组属性和集函数, 不能出现在group by中没有出现的属性</li></ul><p>例子:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">/*查询各个课程号和相应的选课人数*/</span><span class="token keyword">select</span> cno<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>sno<span class="token punctuation">)</span><span class="token keyword">from</span> sc<span class="token keyword">group</span> <span class="token keyword">by</span> cno<span class="token punctuation">;</span><span class="token comment">/*查询有3门以上课程是90分以上的学生学号及其(90分以上的)课程数。*/</span><span class="token keyword">select</span> sno<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">from</span> sc<span class="token keyword">where</span> grade <span class="token operator">>=</span> <span class="token number">90</span><span class="token keyword">group</span> <span class="token keyword">by</span> sno<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="3-2-连接查询"><a href="#3-2-连接查询" class="headerlink" title="3-2 | 连接查询"></a>3-2 | 连接查询</h3><h3 id="3-3-嵌套查询"><a href="#3-3-嵌套查询" class="headerlink" title="3-3 | 嵌套查询"></a>3-3 | 嵌套查询</h3><p>分类:</p><ul><li><p><strong>相关子查询</strong> : 子查询执行依赖于父查询条件</p></li><li><p><strong>不相关子查询</strong> : 子查询执行不依赖于父查询条件</p></li></ul><h4 id="带有IN谓词的子查询"><a href="#带有IN谓词的子查询" class="headerlink" title="带有IN谓词的子查询"></a>带有IN谓词的子查询</h4><h4 id="带有比较运算的子查询"><a href="#带有比较运算的子查询" class="headerlink" title="带有比较运算的子查询"></a>带有比较运算的子查询</h4><p>带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是单个值时，可以用&gt;、&lt;、=、&gt;=、&lt;=、!=或&lt;&gt;等比较运算符。</p><h4 id="带有ANY（SOME）或ALL谓词的子查询"><a href="#带有ANY（SOME）或ALL谓词的子查询" class="headerlink" title="带有ANY（SOME）或ALL谓词的子查询"></a>带有ANY（SOME）或ALL谓词的子查询</h4><p>子查询返回单值时可以用比较运算符，但返回多值时要用ANY或ALL谓词修饰。而使用ANY或ALL谓词时必须同时使用比较运算符。</p><p><a href="https://youpai.roccoshi.top/img/20210106174630.png"><img src="https://youpai.roccoshi.top/img/20210106174630.png" alt="img"></a></p><p>例子: (为不相关子查询)</p><p><a href="https://youpai.roccoshi.top/img/20210106174631.png"><img src="https://youpai.roccoshi.top/img/20210106174631.png" alt="image-20201226133604299"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174631.png">image-20201226133604299</a></p><p>使用any/all谓词与集函数具有等价关系, 而用集函数查询通常比any/all查询效率高因为前者可以减少比较次数</p><p><a href="https://youpai.roccoshi.top/img/20210106174632.png"><img src="https://youpai.roccoshi.top/img/20210106174632.png" alt="image-20201226133751280"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174632.png">image-20201226133751280</a></p><h4 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h4><p>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false， 故子查询通常只用select *</p><p><a href="https://youpai.roccoshi.top/img/20210106174633.png"><img src="https://youpai.roccoshi.top/img/20210106174633.png" alt="image-20201226133932439"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174633.png">image-20201226133932439</a></p><p>使用<strong>EXISTS子查询的效率要优于使用连接查询和IN查询</strong></p><p>EXISTS通常引入的是相关子查询, 而IN更多的是不相关子查询</p><h3 id="3-4-集合查询"><a href="#3-4-集合查询" class="headerlink" title="3-4 | 集合查询"></a>3-4 | 集合查询</h3><p>集合操作命令</p><table><thead><tr><th>命令</th><th></th></tr></thead><tbody><tr><td>UNION</td><td>并</td></tr><tr><td>INTERSECT</td><td>交</td></tr><tr><td>MINUS</td><td>差</td></tr></tbody></table><p><a href="https://youpai.roccoshi.top/img/20210106174634.png"><img src="https://youpai.roccoshi.top/img/20210106174634.png" alt="image-20201226140459748"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174634.png">image-20201226140459748</a></p><h2 id="4-数据更新"><a href="#4-数据更新" class="headerlink" title="4 | 数据更新"></a>4 | 数据更新</h2><h3 id="4-1-插入数据"><a href="#4-1-插入数据" class="headerlink" title="4-1 | 插入数据"></a>4-1 | 插入数据</h3><h4 id="插入单个结果"><a href="#插入单个结果" class="headerlink" title="插入单个结果"></a>插入单个结果</h4><p>格式:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span><span class="token keyword">INTO</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>属性列<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>属性列<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>常量<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>常量<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>如果不指定属性列, 则values必须以完整的元组插入, 且属性与表中属性顺序一致</p><p>举例:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> sc<span class="token punctuation">(</span>sno<span class="token punctuation">,</span> cno<span class="token punctuation">)</span><span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'95001'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><h4 id="插入子查询结果"><a href="#插入子查询结果" class="headerlink" title="插入子查询结果"></a>插入子查询结果</h4><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span><span class="token keyword">INTO</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>属性列<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>属性列<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span>子查询<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>举例:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span><span class="token keyword">INTO</span> Deptage<span class="token punctuation">(</span>Sdept<span class="token punctuation">,</span> Avgage<span class="token punctuation">)</span><span class="token keyword">SELECT</span> Sdept<span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>Sage<span class="token punctuation">)</span>  <span class="token comment">-- 属性个数要匹配</span><span class="token keyword">FROM</span> Student<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sdept<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="注意完整性约束"><a href="#注意完整性约束" class="headerlink" title="注意完整性约束"></a>注意完整性约束</h4><p><a href="https://youpai.roccoshi.top/img/20210106174635.png"><img src="https://youpai.roccoshi.top/img/20210106174635.png" alt="image-20201226143151436"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174635.png">image-20201226143151436</a></p><h3 id="4-2-修改数据"><a href="#4-2-修改数据" class="headerlink" title="4-2 | 修改数据"></a>4-2 | 修改数据</h3><p>格式:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token keyword">SET</span> <span class="token operator">&lt;</span>列名<span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>举例:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> student<span class="token keyword">set</span> sage <span class="token operator">=</span> <span class="token number">22</span><span class="token keyword">where</span> sno <span class="token operator">=</span> <span class="token string">'95001'</span>Copy<span class="token comment">-- 将所有学生年龄增加一岁</span><span class="token keyword">update</span> student<span class="token keyword">set</span> sage <span class="token operator">=</span> sage <span class="token operator">+</span> <span class="token number">1</span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="4-3-删除数据"><a href="#4-3-删除数据" class="headerlink" title="4-3 | 删除数据"></a>4-3 | 删除数据</h3><p>格式:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>删除表中满足where指定条件的元组</p><p>例子:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">delete</span><span class="token keyword">from</span> student<span class="token keyword">where</span> sno <span class="token operator">=</span> <span class="token string">'95001'</span><span class="token punctuation">;</span>Copy<span class="token comment">-- 删除所有学生的选课记录</span><span class="token keyword">delete</span><span class="token keyword">from</span> sc<span class="token punctuation">;</span>Copy<span class="token comment">-- 删除CS系所有学生的选课记录</span><span class="token keyword">delete</span> <span class="token keyword">from</span> sc<span class="token keyword">where</span> sno <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> sno    <span class="token keyword">from</span> student    <span class="token keyword">where</span> student<span class="token punctuation">.</span>sdept <span class="token operator">=</span> <span class="token string">'CS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>删除时的参照完整性:</p><ul><li>不允许被删除</li><li>级联删除 ( 通过CASCADE参数指定 )</li></ul><h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5 | 视图"></a>5 | 视图</h2><p>视图的特点：</p><p>1、虚表，是从一个或几个基本表（或视图）导出的表</p><p>2、只存放视图的定义，不存放视图对应的数据</p><p>3、基本表中的数据发生变化，从视图中查询出的数据也随之改变</p><p>数据库系统的<strong>三级模式</strong>: 外模式, 模式, 内模式</p><p>数据库系统的<strong>两级映像</strong>: 外模式-模式映像 模式-内模式映像</p><ul><li>外模式-模式映像用途: <strong>保证数据的逻辑独立性</strong></li><li>模式-内模式映像用途: <strong>保证数据的物理独立性</strong></li></ul><p>视图对应的就是三级模式/两级映像体系结构中的外模式和外模式/模式映像</p><h3 id="5-1-定义视图"><a href="#5-1-定义视图" class="headerlink" title="5-1 | 定义视图"></a>5-1 | 定义视图</h3><p>格式:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">AS</span> <span class="token operator">&lt;</span>子查询<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p><a href="https://youpai.roccoshi.top/img/20210106174636.png"><img src="https://youpai.roccoshi.top/img/20210106174636.png" alt="image-20210102151117045"></a></p><p><a href="https://youpai.roccoshi.top/img/20210106174636.png">image-20210102151117045</a></p><p>DBMS执行create view语句时只是把视图的定义存入数据字典, 并不执行其中的select语句, 在对视图查询时, 按视图的定义从基本表中将数据查出</p><p>例子:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">view</span> IS_STUDENT<span class="token keyword">as</span><span class="token keyword">select</span> sno<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> sage<span class="token keyword">from</span> student<span class="token keyword">where</span> sdept <span class="token operator">=</span> <span class="token string">'IS'</span><span class="token punctuation">;</span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>若一个视图是从单个基本表导出的, 并且只去掉了基本表的某些行和某些列但保留了码, 则这类视图称为<strong>行列子集视图</strong>, 上例所建立的视图就是行列子集视图</p><h3 id="5-2-查询视图"><a href="#5-2-查询视图" class="headerlink" title="5-2 | 查询视图"></a>5-2 | 查询视图</h3><p>视图消解：从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转化过程称为视图消解。</p><h3 id="5-3-更新视图"><a href="#5-3-更新视图" class="headerlink" title="5-3 | 更新视图"></a>5-3 | 更新视图</h3><h3 id="5-4-视图的作用"><a href="#5-4-视图的作用" class="headerlink" title="5-4 | 视图的作用"></a>5-4 | 视图的作用</h3><p>1、视图能够简化用户的操作</p><p>2、视图使用户能以多种角度看待同一数据</p><p>3、视图对重构数据库提供了一定程度的逻辑独立性</p><p>4、视图能够对机密数据提供安全防护</p><p>5、适当利用视图可以更清晰地表达查询</p><h1 id="4-数据库安全-赋权"><a href="#4-数据库安全-赋权" class="headerlink" title="4. 数据库安全-赋权"></a>4. 数据库安全-赋权</h1><blockquote><p>数据库的安全性控制通过授权机制来实现, 即通过赋予用户对数据库的使用权限来保证数据的安全</p></blockquote><h2 id="1-授权GRANT语句"><a href="#1-授权GRANT语句" class="headerlink" title="1 | 授权GRANT语句"></a>1 | 授权<code>GRANT</code>语句</h2><ul><li>将数据库中的某些对象的某些操作权限赋予某些用户</li></ul><p>格式:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">Grant</span> <span class="token operator">&lt;</span>权限s<span class="token operator">></span><span class="token keyword">ON</span><span class="token operator">&lt;</span>对象类型<span class="token operator">></span> <span class="token operator">&lt;</span>对象名<span class="token operator">></span><span class="token keyword">TO</span><span class="token operator">&lt;</span>用户s<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token keyword">GRANT</span> <span class="token keyword">OPTION</span><span class="token punctuation">]</span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li>DBA拥有数据库操作的所有权限并可将权限赋予其他用户</li><li>建立数据库对象的用户称为OWNER, 他拥有对该对象的所有操作权限</li><li>接收权限的用户可以是一个或者多个具体用户, 也可以是全体用户PUBLIC</li><li><code>WITH GRANT OPTION</code>子句: 获得某种权限的用户还可以把这种权限再授予别的用户, 没有指定with grant option时, 获得某种权限的用户只能使用该权限, 不能传播该权限</li></ul><h3 id="所有权限一览表"><a href="#所有权限一览表" class="headerlink" title="所有权限一览表"></a>所有权限一览表</h3><p><a href="https://youpai.roccoshi.top/img/20201227101704.png"><img src="https://youpai.roccoshi.top/img/20201227101704.png" alt="image-20201227101703896"></a></p><p><a href="https://youpai.roccoshi.top/img/20201227101704.png">image-20201227101703896</a></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">select</span><span class="token keyword">on</span> <span class="token keyword">table</span> student<span class="token keyword">to</span> user1<span class="token punctuation">;</span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>把对sc表的全部权限授予全部用户</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">all</span> priviliges<span class="token keyword">on</span> <span class="token keyword">table</span> sc<span class="token keyword">to</span> <span class="token keyword">public</span><span class="token punctuation">;</span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>把查询student表和修改学生学号的权限授予给用户3和用户4</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">update</span><span class="token punctuation">(</span>sno<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">select</span><span class="token keyword">on</span> <span class="token keyword">table</span> student<span class="token keyword">to</span> user3<span class="token punctuation">,</span> user4<span class="token punctuation">;</span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>把对表sc的insert权限授予给user5用户, 并允许他再将此权限授予其他用户</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">insert</span><span class="token keyword">on</span> <span class="token keyword">table</span> sc<span class="token keyword">to</span> user5<span class="token keyword">with</span> <span class="token keyword">grant</span> <span class="token keyword">option</span><span class="token punctuation">;</span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>把在数据库S_C中的建表权限授予用户8</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> createtab<span class="token keyword">on</span> <span class="token keyword">database</span> S_C<span class="token keyword">to</span> user8<span class="token punctuation">;</span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="2-收回权限REVOKE语句"><a href="#2-收回权限REVOKE语句" class="headerlink" title="2 | 收回权限REVOKE语句"></a>2 | 收回权限<code>REVOKE</code>语句</h2><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">REVOKE</span> <span class="token operator">&lt;</span>权限s<span class="token operator">></span><span class="token keyword">ON</span> <span class="token operator">&lt;</span>对象类型<span class="token operator">></span> <span class="token operator">&lt;</span>对象名<span class="token operator">></span><span class="token keyword">FROM</span> <span class="token operator">&lt;</span>用户s<span class="token operator">></span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">revoke</span> <span class="token keyword">update</span><span class="token punctuation">(</span>sno<span class="token punctuation">)</span><span class="token keyword">on</span> <span class="token keyword">table</span> student<span class="token keyword">from</span> user4<span class="token punctuation">;</span>Copy<span class="token keyword">revoke</span> <span class="token keyword">select</span><span class="token keyword">on</span> <span class="token keyword">table</span> sc<span class="token keyword">from</span> <span class="token keyword">public</span><span class="token punctuation">;</span>Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li>收回权限时, 将收回自己所级联授予出的权限</li><li>如果存在多重授予, (从不同用户处得到的相同权限, 则仍然具有该权限), 只收回自己级联授予的权限</li></ul><h2 id="3-视图机制"><a href="#3-视图机制" class="headerlink" title="3 | 视图机制"></a>3 | 视图机制</h2><p><a href="https://youpai.roccoshi.top/img/20201227102725.png"><img src="https://youpai.roccoshi.top/img/20201227102725.png" alt="image-20201227102725294"></a></p><p><a href="https://youpai.roccoshi.top/img/20201227102725.png">image-20201227102725294</a></p><h1 id="5-存储过程和触发器"><a href="#5-存储过程和触发器" class="headerlink" title="5. 存储过程和触发器"></a>5. 存储过程和触发器</h1><h2 id="1-存储过程"><a href="#1-存储过程" class="headerlink" title="1 | 存储过程"></a>1 | 存储过程</h2><p>创建存储过程:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>执行存储过程:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXECUTE</span> <span class="token keyword">PROCEDURE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>修改存储过程:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">PROCEDURE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>删除存储过程:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h2 id="2-触发器"><a href="#2-触发器" class="headerlink" title="2 | 触发器"></a>2 | 触发器</h2><p>功能: 强化约束, 跟踪变化, 级联运行, 存储过程的调用</p><p>分类: 前触发器(<code>INSTEAD OF</code>), 后触发器 (<code>AFTER</code>)</p><p>创建:</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">ON</span><span class="token keyword">FOR</span><span class="token keyword">AS</span><span class="token comment">-- 例子</span><span class="token keyword">create</span> <span class="token keyword">trigger</span> reminder<span class="token keyword">on</span> titles<span class="token keyword">for</span> <span class="token keyword">insert</span><span class="token punctuation">,</span> <span class="token keyword">update</span><span class="token keyword">as</span> sql_statementsCopy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>在触发器的执行过程中，系统会自动建立和管理两个逻辑表：插入表(inserted)和删除表(deleted)。这两个表与触发器所对应的基本表有着完全相同的结构，但为只读表，驻留于内存之中，直到触发器执行完毕，系统会自动删除。这两个表是事务回滚的重要依据。</p><h1 id="6-数据库设计"><a href="#6-数据库设计" class="headerlink" title="6. 数据库设计"></a>6. 数据库设计</h1><h2 id="1-数据库设计的流程"><a href="#1-数据库设计的流程" class="headerlink" title="1 | 数据库设计的流程"></a>1 | 数据库设计的流程</h2><table><thead><tr><th>1-需求分析</th><th>2-概念结构设计</th><th>3-逻辑结构设计</th><th>4-物理结构设计</th></tr></thead><tbody><tr><td></td><td>ER图</td><td>ER图-&gt;关系模型</td><td></td></tr></tbody></table><h2 id="2-ER图"><a href="#2-ER图" class="headerlink" title="2 | ER图"></a>2 | ER图</h2><p>三种表示</p><table><thead><tr><th></th><th>表示方式</th></tr></thead><tbody><tr><td>实体</td><td>矩形</td></tr><tr><td>属性</td><td>圆形</td></tr><tr><td>联系</td><td>菱形</td></tr></tbody></table><p>三种不同的联系</p><ul><li>一对一联系</li><li>一对多联系</li><li>多对多联系</li></ul><h2 id="3-ER图向关系模型的转换"><a href="#3-ER图向关系模型的转换" class="headerlink" title="3 | ER图向关系模型的转换"></a>3 | ER图向关系模型的转换</h2><table><thead><tr><th>联系</th><th>转换</th></tr></thead><tbody><tr><td>1 : 1</td><td>两实体<strong>任意一端添加另一端的主键</strong></td></tr><tr><td>1 : N</td><td>在<strong>N端添加另一端的主键</strong></td></tr><tr><td>N : M</td><td>将<strong>联系转化为实体</strong>, 并在实体中加入联系两端实体的主键</td></tr><tr><td>1 : 1 : N - N : M : P</td><td>同 1 : N - N : M (在N端添加另外两端主键 - 联系转化为实体添加三端实体主键)</td></tr></tbody></table><h1 id="7-关系数据理论"><a href="#7-关系数据理论" class="headerlink" title="7. 关系数据理论"></a>7. 关系数据理论</h1><p><strong>关系模式的简记</strong>: <code>R&lt;U, F&gt;</code></p><p>其中U表示属性集, F表示数据依赖</p><h2 id="1-关系数据理论"><a href="#1-关系数据理论" class="headerlink" title="1 | 关系数据理论"></a>1 | 关系数据理论</h2><p>不合适的数据依赖造成以下等问题</p><ul><li>数据冗余</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ul><h2 id="2-规范化"><a href="#2-规范化" class="headerlink" title="2 | 规范化"></a>2 | 规范化</h2><h3 id="2-1-函数依赖"><a href="#2-1-函数依赖" class="headerlink" title="2-1 | 函数依赖"></a>2-1 | 函数依赖</h3><p>函数依赖（Functional Dependencies）简写为FD</p><ul><li><p><strong>平凡函数依赖</strong>： (X→Y,Y⊆X) 平凡函数依赖没什么用, 不研究</p><p>例如(sno, cno)→sno</p></li><li><p><strong>非平凡函数依赖</strong>：(X→Y,Y⊈X) 如果不特别声明, 我们总是讨论非平凡函数依赖</p><p>例如(sno, cno)→grade</p><blockquote><p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反应新的语义，因此若不特别声明，我们总是讨论非平凡函数依赖。</p></blockquote></li><li><p><strong>完全函数依赖</strong>：在R(U)中，如果X→Y，并且对于X的任何一个真子集X‘，都有X‘/→Y</p></li><li><p><strong>部分函数依赖</strong>：若X→Y，但Y不完全函数依赖于X</p></li><li><p><strong>传递函数依赖</strong>：在R(U)中，X→Y，Y→Z，且Y/→X，则Z传递依赖于X, 如果Y→X则为直接函数依赖</p></li></ul><h3 id="2-2-码"><a href="#2-2-码" class="headerlink" title="2-2 | 码"></a>2-2 | 码</h3><blockquote><p>码是关系模式中的一个重要概念。在第二章关系数据库中已经给出了有关码的若干定义，这里用函数依赖的概念来定义码。</p></blockquote><p><strong>候选码</strong>：设K为R&lt;U,F&gt;中的属性或属性组合，若U完全函数依赖于K，则K为R的候选码。</p><p><strong>超码</strong>：如果U部分函数依赖于K，则K为超码</p><blockquote><p>候选码是最小的超码，即K的任何一个真子集都不是候选码</p><p>候选码是 一类特殊的超码，即候选码的超集一定是超码，候选码的任何真子集一定不是超码</p></blockquote><p><strong>主码</strong>：若关系模式R有多个候选码，则选定其中一个作为主码</p><p><strong>主属性</strong>：包含在任何一个候选码中的属性称为主属性</p><p><strong>非主属性</strong>：不包含在任何一个候选码中的属性称为非主属性或非码属性</p><p><strong>全码</strong>：整个属性组是码，称为全码</p><blockquote><p>例：关系模式R(P,W,A)中，属性P表示演奏者，W表示作品，A表示听众。假设一个演奏者可以演奏多个作品，某一个作品可以被多个演奏者演奏，听众也可以欣赏不同演奏者的不同作品，这个关系模式的码为(P,W,A)，即all-key。</p></blockquote><p><strong>外码</strong>：关系模式R&lt;U,F&gt;，U中属性或者属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码也称外码。</p><blockquote><p>主码与外码一起提供了表示关系间联系的手段</p></blockquote><h3 id="2-3-范式"><a href="#2-3-范式" class="headerlink" title="2-3 | 范式"></a>2-3 | 范式</h3><ul><li>范式：范式 是符合某一级别的关系模式的集合</li><li>关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。</li><li><strong>规范化</strong>：一个低一级范式的关系模式通过模式分解可以转换成为若干个高一级范式的关系模式的集合，这个过程就叫规范化。</li></ul><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p><strong>定义</strong>：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。</p><p>所有属性必须是原子的, 不允许表中套表</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p><strong>定义</strong>：若 R∈1NF，且每一个非主属性完全依赖于任何一个候选码，则R∈2NF。</p><p>满足1NF且不存在非主属性对候选码的部分函数依赖</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>满足2NF且不存在非主属性对候选码的传递函数依赖和部分函数依赖</p><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>修正的第三范式</p><p>没有任何属性对码的部分函数依赖和传递函数依赖</p><p>在关系模式R&lt;U,F&gt;中每一个决定因素都包含码，则R&lt;U,F&gt;∈BCNF</p><h2 id="3-数据库依赖的公理系统"><a href="#3-数据库依赖的公理系统" class="headerlink" title="3 | 数据库依赖的公理系统"></a>3 | 数据库依赖的公理系统</h2><h3 id="六条推理规则"><a href="#六条推理规则" class="headerlink" title="六条推理规则"></a>六条推理规则</h3><ul><li>自反律</li><li>增广律</li><li>传递律</li><li>合并规则</li><li>分解规则</li><li>伪传递规则</li></ul><p><a href="https://youpai.roccoshi.top/img/20210102192831.png"><img src="https://youpai.roccoshi.top/img/20210102192831.png" alt="img"></a></p><h3 id="函数依赖集的闭包"><a href="#函数依赖集的闭包" class="headerlink" title="函数依赖集的闭包"></a>函数依赖集的闭包</h3><p>在关系模式R中为F所逻辑蕴含的函数依赖的全体叫做F的闭包, 记为F+</p><p>注: F+一般超级多, 求F+属于NP完全问题</p><h3 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h3><p>设F为属性集U上的一组函数依赖, X⊆U, X关于函数依赖集F的闭包为XF+</p><p>能由根据公理导出XF+={A|X→A能由F根据Armstrong公理导出}</p><p>注: 即求X可以导出的所有属性集合</p><p><a href="https://youpai.roccoshi.top/img/20210102192832.png"><img src="https://youpai.roccoshi.top/img/20210102192832.png" alt="img"></a></p><h3 id="最小函数依赖集"><a href="#最小函数依赖集" class="headerlink" title="最小函数依赖集"></a>最小函数依赖集</h3><p>即用最少的函数依赖表示全部属性之间的依赖关系, 记为Fmin</p><p>最小函数依赖集的定义:</p><p><a href="https://youpai.roccoshi.top/img/20210102192833.png"><img src="https://youpai.roccoshi.top/img/20210102192833.png" alt="img"></a></p><h3 id="考点-最小函数依赖集的求解算法"><a href="#考点-最小函数依赖集的求解算法" class="headerlink" title="考点: 最小函数依赖集的求解算法"></a>考点: 最小函数依赖集的求解算法</h3><p>第一步: <strong>对每个函数依赖作右部属性分离</strong></p><p>第二步: <strong>去掉左部的冗余属性</strong></p><p>第三步: <strong>去除多余的函数依赖</strong></p><p>注意: 最小函数依赖集不是唯一的</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><a href="https://youpai.roccoshi.top/img/20210102192834.png"><img src="https://youpai.roccoshi.top/img/20210102192834.png" alt="img"></a></p><p>在第三步的时候可以采用「除本求包」的方法, 即除去正在考察的这个函数依赖, 看左部属性的闭包是否包含正在考察的函数依赖的右部属性, 如果包含则正在考察的这个函数依赖为多余的函数依赖, 例如上面的A-&gt;D, 除去A-&gt;D的这个函数依赖求A的闭包为{A, B, C, D, E}包含D, 则A-&gt;D为多余, 应该去除。</p><p><strong>正则覆盖</strong>: 将求出的最小函数依赖集左部属性相同的函数依赖合并(例如A-&gt;B A-&gt;C合并为A-&gt;BC)</p><h3 id="考点-候选码求解算法"><a href="#考点-候选码求解算法" class="headerlink" title="考点: 候选码求解算法"></a>考点: 候选码求解算法</h3><p>第一步: <strong>根据函数依赖集F将R的所有属性分为L类, R类, LR类和N类属性[<a href="https://blog.roccoshi.top/2021/%E8%A5%BF%E7%94%B5%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E5%A4%8D%E4%B9%A0/#fn:1">1]</a>, 令X为L, N类的集合, Y为LR类的集合</strong></p><p>第二步: <strong>如果XF+=U, 则X为R的唯一候选码, 结束, 否则到第三步</strong></p><p>第三步: <strong>逐一取Y中的单一属性A, 若(XA)F+=U, 则XA为候选码, 令Y = Y - {A}, 到第四步</strong></p><p>第四步: <strong>依次取Y中的两个, 三个…属性与X组成属性组XZ, 若XZ不包含已求得的候选码, 则求其关于F的闭包(XZ)F+</strong></p><p><strong>若(XZ)F+=U, 则XZ为候选码, 重复第四步直到所有Y中的属性取完为止, 算法结束</strong></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><a href="https://youpai.roccoshi.top/img/20210102192835.png"><img src="https://youpai.roccoshi.top/img/20210102192835.png" alt="img"></a></p><h2 id="4-模式分解"><a href="#4-模式分解" class="headerlink" title="4 | 模式分解"></a>4 | 模式分解</h2><p><a href="https://youpai.roccoshi.top/img/20210102192836.png"><img src="https://youpai.roccoshi.top/img/20210102192836.png" alt="img"></a></p><p>分解应该考虑的问题</p><ul><li>分解不能丢失信息</li><li>分解应该保持函数依赖</li><li>分解需要保持无损连接 (可以通过自然连接还原)</li></ul><h3 id="考点-模式的无损连接性判定算法"><a href="#考点-模式的无损连接性判定算法" class="headerlink" title="考点: 模式的无损连接性判定算法"></a>考点: 模式的无损连接性判定算法</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>R的一个分解为R1, R2</p><p><strong>若U1∩U2→U1−U2∈F+或者U1∩U2→U2−U1∈F+则分解R1, R2保持无损连接</strong> (<strong>充分必要条件</strong>, 用于一分为二模式的无损连接判断)</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>构造表</p><p><a href="https://youpai.roccoshi.top/img/20210102192837.png"><img src="https://youpai.roccoshi.top/img/20210102192837.png" alt="img"></a></p><h3 id="将模式分解为BCNF并保持无损连接"><a href="#将模式分解为BCNF并保持无损连接" class="headerlink" title="将模式分解为BCNF并保持无损连接"></a>将模式分解为BCNF并保持无损连接</h3><p><a href="https://youpai.roccoshi.top/img/20210102192838.png"><img src="https://youpai.roccoshi.top/img/20210102192838.png" alt="img"></a></p><h1 id="8-嵌入式SQL"><a href="#8-嵌入式SQL" class="headerlink" title="8. 嵌入式SQL"></a>8. 嵌入式SQL</h1><h2 id="1-主语言-SQLCA-主变量-游标"><a href="#1-主语言-SQLCA-主变量-游标" class="headerlink" title="1 | 主语言 SQLCA 主变量 游标"></a>1 | 主语言 SQLCA 主变量 游标</h2><p>主语言: C++, JAVA</p><p>SQLCA: sql communication area (SQL通信区)</p><p>主变量: sql使用主语言中的变量</p><p>游标: 一段缓冲区, 用于存放sql的执行结果</p><h3 id="数据库和源程序工作单元间的通信"><a href="#数据库和源程序工作单元间的通信" class="headerlink" title="数据库和源程序工作单元间的通信"></a>数据库和源程序工作单元间的通信</h3><ol><li>SQLCA向主语言传递SQL语句的执行信息(执行状态)</li><li>主语言通过主变量向SQL提供参数</li><li>主变量和游标将SQL语句查询数据库的结果交主语言处理</li></ol><h1 id="9-事务"><a href="#9-事务" class="headerlink" title="9. 事务"></a>9. 事务</h1><h2 id="1-事务的ACID特性"><a href="#1-事务的ACID特性" class="headerlink" title="1 | 事务的ACID特性"></a>1 | 事务的ACID特性</h2><ul><li>原子性Atomicity: 事务要么全做, 要么全不做</li><li>一致性Consistency: 事务让数据库从一个一致性状态—&gt;另一个一致性状态</li><li>隔离性Isolation: 事务的执行不能被其他事务干扰</li><li>持续性Durability: 事务提交后对数据库中数据的改变为永久性的</li></ul><h2 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2 | 并发控制"></a>2 | 并发控制</h2><p>几种并发冲突:</p><ol><li><strong>丢失修改</strong> (写-写冲突)</li><li><strong>不可重复读</strong> (读-写冲突)</li><li><strong>读“脏”数据</strong> (写-读冲突)</li></ol><h2 id="3-封锁机制"><a href="#3-封锁机制" class="headerlink" title="3 | 封锁机制"></a>3 | 封锁机制</h2><p><strong>X锁</strong>: 排他锁, 持有X锁的人能读写数据库</p><p><strong>S锁:</strong> 共享锁, 持有S锁的人能读不能写数据库</p><p>仅能有一个事务拥有X锁, 可以有多个事务同时拥有S锁</p><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p>修改数据之前先加X锁, 事务结束后释放</p><p>解决问题: <strong>丢失修改</strong></p><h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><p>在一级封锁协议基础上增加在读取数据前必须对数据加S锁, 读完后即可释放</p><p>解决问题: <strong>丢失修改和读“脏”数据</strong></p><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p>在一级封锁协议的基础上增加在读取数据前必须对数据加S锁, 在事务结束后才可释放</p><p>解决问题: <strong>丢失修改, 不可重复读, 读“脏”数据</strong></p><h2 id="4-并发调度的可串行性"><a href="#4-并发调度的可串行性" class="headerlink" title="4 | 并发调度的可串行性"></a>4 | 并发调度的可串行性</h2><p><strong>可串行化调度的定义:</strong></p><blockquote><p>定义: 多个并发事务的执行是正确的, 当且仅当其结果与按一定次序串行地执行这些事务时的结果相同</p></blockquote><p><strong>可串行性</strong>是并发事务正确调度的准则, 一个给定的并发调度当且仅当它是可串行化的才认为是正确的调度</p><p><strong>冲突可串行化调度:</strong></p><p>将并发调度保证冲突操作次序不变的情况下交换不冲突操作的次序得到另一个串行调度, 则称这个并发调度为冲突可串行化的调度, 如果一个调度是冲突可串行化的, 那么则一定是可串行化的调度。</p><p>注意: 冲突可串行化调度是可串行化调度的充分非必要条件</p><h2 id="5-两段锁协议"><a href="#5-两段锁协议" class="headerlink" title="5 | 两段锁协议"></a>5 | 两段锁协议</h2><p>两段锁协议:</p><blockquote><p>先统一加锁, 事务结束时统一释放锁</p></blockquote><ul><li>遵守两段锁协议也会发生死锁</li><li>遵守两段锁协议是可串行化调度的充分条件</li></ul><p>原博客转载于：<a href="https://blog.roccoshi.top/">https://blog.roccoshi.top/</a> + 本人增删修改</p>]]></content>
    
    
    <categories>
      
      <category>解忧杂货</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维矩阵的二分查找</title>
    <link href="/2022/04/06/%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/04/06/%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="LeeetCode-240：搜索二维矩阵"><a href="#LeeetCode-240：搜索二维矩阵" class="headerlink" title="LeeetCode 240：搜索二维矩阵"></a>LeeetCode 240：搜索二维矩阵</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>C++ lower_bound()函数</p><blockquote><p>lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。它的底层实现采用的都是二分查找的方式。</p><p>注意：</p><p>1.因为函数底层实现采用的是二维数组，所以该函数仅适用于已排好序的序列。</p><p>2.迭代器遍历时，函数返回的是迭代器</p><p>详解见博客：<a href="http://m.biancheng.net/view/7521.html">http://m.biancheng.net/view/7521.html</a></p></blockquote><p>用for(const auto row : matrix)遍历时会超时的原因</p><blockquote><p>1.auto即for(auto x:range) 会拷贝一份range元素，不会改变range中的元素；<br>2.只读取range中的元素,使用const auto&amp;,如：for(const auto&amp;x:range),它不会进行拷贝，也不会修改range,效率会比用auto快一点。</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h5 id="方法1：二分查找"><a href="#方法1：二分查找" class="headerlink" title="方法1：二分查找"></a>方法1：二分查找</h5><blockquote><p>由于矩阵 matrix 中每一行的元素都是升序排列的，因此我们可以对每一行都使用一次二分查找，判断 target 是否在该行中，从而判断 target 是否出现。</p></blockquote><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        for(const auto&amp; row : matrix)        &#123;            auto it &#x3D; lower_bound(row.begin(),row.end(),target);            if(it !&#x3D; row.end() &amp;&amp; *it &#x3D;&#x3D; target)  return true;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用库函数</title>
    <link href="/2022/04/05/C-%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <url>/2022/04/05/C-%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="builtin-popcount"><a href="#builtin-popcount" class="headerlink" title="__builtin_popcount"></a>__builtin_popcount</h3><blockquote><p>__builtin_popcount()</p><p>该函数是C++自带的库函数，内部实现是用查表实现的。<br><strong>作用</strong>：统计数字在二进制下“1”的个数。</p><p>Note：是__builtin_popcount()，千万别写成 _builtin_popcount()</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计哈希集合+设计哈希映射</title>
    <link href="/2022/03/31/%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/"/>
    <url>/2022/03/31/%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-705：设计哈希集合"><a href="#LeetCode-705：设计哈希集合" class="headerlink" title="LeetCode 705：设计哈希集合"></a>LeetCode 705：设计哈希集合</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：<br>1.哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。<br>2.冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现冲突时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：<br>  链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。<br>  开放地址法：当发现哈希值 hh 处产生冲突时，根据某种策略，从 hh 出发找到下一个不冲突的位  置。例如，一种最简单的策略是，不断地检查 h+1,h+2,h+3,… 这些整数对应的位置。<br>  再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。<br>3.扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。  </p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 实现 MyHashSet 类： </p><p>void add(key) 向哈希集合中插入值 key 。 </p><p>bool contains(key) 返回哈希集合中是否存在这个值 key 。 </p><p>void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：链地址法</strong> </p><p>设哈希表的大小为 base，则可以设计一个简单的哈希函数：hash(x) = x mod base。 开辟一个大小为 base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。 由于使用整数除法作为哈希函数，为了尽可能避免冲突，应当将 base 取为一个质数。取 base=769。   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyHashSet &#123;public:    vector&lt;list&lt;int&gt;&gt; data;  &#x2F;&#x2F;定义一个数组base,数组的每一个位置是一个链表    static const int base &#x3D; 769;  &#x2F;&#x2F;定义哈希表的大小    &#x2F;&#x2F;用链地址法设计一个哈希表    static int hash(int key)    &#123;        return key % base;    &#125;    MyHashSet():data(base) &#123;&#125;    &#x2F;&#x2F;插入    void add(int key) &#123;        int h &#x3D; hash(key);  &#x2F;&#x2F;找出key在哈希表中对应的位置        for(auto it&#x3D;data[h].begin(); it!&#x3D;data[h].end(); it++)  &#x2F;&#x2F;迭代法遍历key在哈希表中对应位置的链表        &#123;            &#x2F;&#x2F;如果插入元素存在 则返回空            if(*it &#x3D;&#x3D; key)            &#123;                return;            &#125;        &#125;        &#x2F;&#x2F;如果元素不存在则插入元素        data[h].push_back(key);    &#125;    &#x2F;&#x2F;删除    void remove(int key) &#123;        int h &#x3D; hash(key);        for(auto it&#x3D;data[h].begin(); it!&#x3D;data[h].end(); it++)        &#123;            if(*it &#x3D;&#x3D; key)            &#123;                data[h].erase(it);                &#x2F;*                    注意：data\[h\].erase(it) 这里的it不可写成\*it或者key                    因为删除的是key在链表上的地址而不是值                *&#x2F;                return;            &#125;        &#125;    &#125;    &#x2F;&#x2F;判断key是否存在    bool contains(int key) &#123;        int h &#x3D; hash(key);        for(auto it&#x3D;data[h].begin(); it!&#x3D;data[h].end(); it++)        &#123;            if(*it &#x3D;&#x3D; key)  &#x2F;* 注意：*it *&#x2F;            &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> </p><h2 id="LeetCode-706：设计哈希映射"><a href="#LeetCode-706：设计哈希映射" class="headerlink" title="LeetCode 706：设计哈希映射"></a>LeetCode 706：设计哈希映射</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p><em><strong>设计哈希映射</strong></em> 与 <em><strong>设计哈希集合</strong></em> 解法接近，唯一的区别在于哈希映射存储的不是 key 本身，而是键值对(key,value)。   </p><blockquote><p>哈希表增加键值对的函数：map1.insert(make_pair(n,1))<br>哈希表删除键值对的函数：data[h].erase(it)<br>哈希表使用迭代器遍历时：<br>i-&gt;first：表示键<br>i-&gt;second：表示值  </p></blockquote><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。 实现 MyHashMap 类： </p><p>MyHashMap() 用空映射初始化对象 </p><p>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。 </p><p>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。 </p><p>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyHashMap &#123;public:    vector&lt;list&lt;pair&lt;int,int&gt;&gt;&gt; data;    static const int base &#x3D; 769;    static int hash(int key)    &#123;        return key % base;    &#125;    MyHashMap():data(base) &#123;&#125;    void put(int key, int value) &#123;        int h &#x3D; hash(key);        for(auto it&#x3D;data[h].begin(); it!&#x3D;data[h].end(); it++)        &#123;            if(it-&gt;first &#x3D;&#x3D; key)            &#123;                it-&gt;second &#x3D; value;                return;            &#125;        &#125;        data[h].push_back(make_pair(key,value));    &#125;    int get(int key) &#123;        int h &#x3D; hash(key);        for(auto it&#x3D;data[h].begin(); it!&#x3D;data[h].end(); it++)        &#123;            if(it-&gt;first &#x3D;&#x3D; key)            &#123;                return it-&gt;second;            &#125;        &#125;        return -1;    &#125;    void remove(int key) &#123;        int h &#x3D; hash(key);        for(auto it&#x3D;data[h].begin(); it!&#x3D;data[h].end(); it++)        &#123;            if(it-&gt;first &#x3D;&#x3D; key)            &#123;                data[h].erase(it);                return;            &#125;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三数之和</title>
    <link href="/2022/03/25/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/03/25/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-15-三数之和"><a href="#LeetCode-15-三数之和" class="headerlink" title="LeetCode 15:三数之和"></a>LeetCode 15:三数之和</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>本题与LeetCode 1：两数之和类似，是非常经典的面试题，但是做法不尽相同。  </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：排序+双指针</strong> </p><blockquote><p>关键字：不可以包含重复<br>模式识别：利用排序避免重复答案<br>降低复杂度变成twoSum<br>利用双指针找到所有解<br>数组有序，和为定值的两个数一定可以通过头尾指针向中间移动获得。<br>关键去重，每次移动跳过与当前值相同的元素，枚举第三个元素也要跳过重复元素。</p></blockquote><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        sort(nums.begin(),nums.end());  &#x2F;&#x2F;对数组进行排序方便去重        &#x2F;&#x2F;枚举a        for(int i&#x3D;0; i&lt;nums.size(); i++)        &#123;            if(i&gt;0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1])  continue;  &#x2F;&#x2F;去重，需要和上次遍历的元素不同            int target &#x3D; 0-nums[i];  &#x2F;&#x2F;定义目标值target，转化为二元组问题target &#x3D; b+c            int l &#x3D; i+1,r &#x3D; nums.size()-1;  &#x2F;&#x2F;定义首尾指针，通过首尾指针移动获取定值target            while(l&lt;r)  &#x2F;&#x2F;通过首尾指针获取定值target            &#123;                if(nums[l]+nums[r] &#x3D;&#x3D; target)                &#123;                    ans.push_back(&#123;nums[i],nums[l],nums[r]&#125;);  &#x2F;&#x2F;将符合的元组加入结果ans中                    while(l&lt;r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l+1])  l++;  &#x2F;&#x2F;去除重复的左指针元素                    while(l&lt;r &amp;&amp; nums[r] &#x3D;&#x3D; nums[r-1])  r--;  &#x2F;&#x2F;去除重复的右指针元素                    l++;  &#x2F;&#x2F;左指针向右移                    r--;  &#x2F;&#x2F;右指针向左移                &#125;                else if(nums[l]+nums[r] &gt; target)                &#123;                    r--;  &#x2F;&#x2F;结果大于目标值，右指针向左移                &#125;                else                &#123;                    l++;  &#x2F;&#x2F;结果小于目标值，左指针向右移                &#125;            &#125;        &#125;        return ans;  &#x2F;&#x2F;返回结果    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><a href="https://www.bilibili.com/video/BV1Jq4y1A7u7?spm_id_from=333.337.search-card.all.click">B站视频讲解</a>  </p><h2 id="LeetCode-1：两数之和"><a href="#LeetCode-1：两数之和" class="headerlink" title="LeetCode 1：两数之和"></a>LeetCode 1：两数之和</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个整数数组 nums 和一个整数目标值 target ，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：暴力枚举</strong> </p><p><strong>方法2：哈希表</strong> </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int,int&gt; map1;  &#x2F;&#x2F;键为nums[i] 值为数组下标i        int n &#x3D; nums.size();        for(int i&#x3D;0; i&lt;n; i++)        &#123;            auto it &#x3D; map1.find(target-nums[i]);            if(it  !&#x3D; map1.end())            &#123;                return &#123;it-&gt;second,i&#125;;            &#125;            map1[nums[i]] &#x3D; i;        &#125;        return &#123;&#125;;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一题四解：排序 集合 哈希表 位运算</title>
    <link href="/2022/03/25/%E4%B8%80%E9%A2%98%E5%9B%9B%E8%A7%A3%EF%BC%9A%E6%8E%92%E5%BA%8F-%E9%9B%86%E5%90%88-%E5%93%88%E5%B8%8C%E8%A1%A8-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/03/25/%E4%B8%80%E9%A2%98%E5%9B%9B%E8%A7%A3%EF%BC%9A%E6%8E%92%E5%BA%8F-%E9%9B%86%E5%90%88-%E5%93%88%E5%B8%8C%E8%A1%A8-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-136：只出现一次的数字"><a href="#LeetCode-136：只出现一次的数字" class="headerlink" title="LeetCode 136：只出现一次的数字"></a>LeetCode 136：只出现一次的数字</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>这道题 虽然是一道简单题，但是学到了很多东西。意识到大一学的C++其实有很多东西都没有学到，比如哈希表和集合的很多用法都不够了解。  </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：判断排序数组前后元素是否相等</strong> </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        int n &#x3D; nums.size();        if(n &#x3D;&#x3D; 1)  return nums[0];        if(n&gt;&#x3D;2 &amp;&amp; nums[0] !&#x3D;  nums[1])  return nums[0];        if(n&gt;&#x3D;2 &amp;&amp; nums[n-1] !&#x3D; nums[n-2])  return nums[n-1];        for(int i&#x3D;1; i&lt;n-1; i++)        &#123;            if(nums[i] !&#x3D; nums[i-1] &amp;&amp; nums[i] !&#x3D; nums[i+1])            &#123;                return nums[i];            &#125;        &#125;        return 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>方法2：集合</strong> </p><blockquote><p>set集合只能使用迭代器遍历，不能使用下标遍历。所以只能返回set1.begin()，而不能返回下标。 auto ans = set1.begin();  //这里只能用auto 而不能用<br>int return *ans;  //返回的必须是指针类型 因为set1.begin()是迭代器类型，所以 ans只能用auto定义，而不能用int类型定义。因此返回的值也必须是 指针类型的。  </p></blockquote><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        unordered_set&lt;int&gt; set1;        for(int n : nums)        &#123;            if(set1.count(n))            &#123;                set1.erase(n);            &#125;            else            &#123;                set1.insert(n);            &#125;        &#125;        auto ans &#x3D; set1.begin();  &#x2F;&#x2F;这里只能用auto 而不能用int        return *ans;  &#x2F;&#x2F;返回的必须是指针类型    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>方法3：哈希表</strong> </p><blockquote><p>哈希表增加键值对的函数：map1.insert(make_pair(n,1));<br>哈希表使用迭代器遍历时： i-&gt;first：表示键 i-&gt;second：表示值  </p></blockquote><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        map&lt;int,int&gt; map1;        for(int n : nums)        &#123;            if(map1.find(n) &#x3D;&#x3D; map1.end())            &#123;                map1.insert(make_pair(n,1));  &#x2F;&#x2F;如果字典中不存在该key，则新增一个键值对(n,1)            &#125;            else            &#123;                map1[n]++;  &#x2F;&#x2F;如果字典中存在该key，则将值加1            &#125;        &#125;        for(auto i&#x3D;map1.begin(); i!&#x3D;map1.end(); i++)        &#123;            if(i-&gt;second &#x3D;&#x3D; 1)            &#123;                return i-&gt;first;            &#125;        &#125;        return 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>Note：相同类型的哈希表题目：</strong><a href="https://leetcode-cn.com/problems/majority-element/">LeetCode 169：多数元素</a>   </p><p><strong>方法4：位运算</strong> </p><p>这个方法太精妙了！   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        int ret &#x3D; 0;        for (auto e: nums) ret ^&#x3D; e;        return ret;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>集合</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和 - 输入 BST</title>
    <link href="/2022/03/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-iv-%E8%BE%93%E5%85%A5-bst/"/>
    <url>/2022/03/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-iv-%E8%BE%93%E5%85%A5-bst/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-653-两数之和IV-输入BST"><a href="#LeetCode-653-两数之和IV-输入BST" class="headerlink" title="LeetCode 653:两数之和IV-输入BST"></a>LeetCode 653:两数之和IV-输入BST</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个二叉搜索树 root 和一个目标结果 k ，如果 BST 中存在两个元素且它们的和等于 给定的目标结果，则返回 true 。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：深度优先搜索+哈希表</strong> </p><p>使用深度优先搜索的方式遍历整棵树，用哈希表记录遍历过的节点的值。 对于一个值为x的节点，我们检查哈希表中是否存在k-x即可。如果存在对应的元素，那么我们就可以在这棵树上找到两个节点的和为k，否则我们将x放入哈希表中。 如果遍历完整棵树都不存在对应的元素，那么该树上不存在两个和为k的节点   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    unordered_set&lt;int&gt; hashTable;  &#x2F;&#x2F;哈希表要定义在函数外面    bool findTarget(TreeNode* root, int k) &#123;        if(root &#x3D;&#x3D; nullptr)        &#123;            return false;        &#125;        if(hashTable.count(k - root-&gt;val))        &#123;            return true;        &#125;        hashTable.insert(root-&gt;val);        return findTarget(root-&gt;left,k)  findTarget(root-&gt;right,k);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>方法2：广度优先搜索+哈希表</strong> </p><p>使用广度优先搜索的方式遍历整棵树，用哈希表记录遍历过的节点的值。 </p><p>首先创建一个哈希表和一个队列，将根节点加入队列中，然后执行以下步骤： </p><p>1.从队列中取出队头，假设其值为 x </p><p>2.检查哈希表中是否存在 k - x，如果存在，返回 true </p><p>3.否则，将该节点的左右的非空子节点加入队尾 </p><p>4.重复以上步骤，直到队列为空 </p><p>5.如果队列为空，说明树上不存在两个和为 k的节点，返回 false   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool findTarget(TreeNode* root, int k) &#123;        unordered_set&lt;int&gt; hashTable;        queue&lt;TreeNode*&gt; que;        que.push(root);        while(!que.empty())        &#123;            TreeNode* node &#x3D; que.front();            que.pop();            if(hashTable.count(k - node-&gt;val))            &#123;                return true;            &#125;            hashTable.insert(node-&gt;val);            if(node-&gt;left !&#x3D; nullptr)            &#123;                que.push(node-&gt;left);            &#125;            if(node-&gt;right !&#x3D; nullptr)            &#123;                que.push(node-&gt;right);            &#125;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> </p><p><strong>方法3：深度优先搜索+中序遍历+双指针</strong>   <strong>方法4：迭代+中序遍历+双指针</strong>   </p><p><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/liang-shu-zhi-he-iv-shu-ru-bst-by-leetco-b4nl/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="/2022/03/20/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/03/20/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-98-验证二叉搜索树"><a href="#LeetCode-98-验证二叉搜索树" class="headerlink" title="LeetCode 98 :验证二叉搜索树"></a>LeetCode 98 :验证二叉搜索树</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><blockquote><p>有效二叉搜索树定义：<br>1.节点左子树只包含小于当前节点的数<br>2.节点右子树只包含大于当前节点的数<br>3.所有左子树和右子树自身必须也是二叉搜索树  </p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：递归法</strong> </p><p>定义一个函数bool helper(TreeNode*,long long int lower,long long int upper) 如果上界和下界存在，判断当前节点的值是否在界内，如果不在界内，返回false。将当前节点的值作为上界，继续对node-&gt;left进行递归；将当前节点作为下界，继续对node-&gt;right进行递归。   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool helper(TreeNode* root,long long int lower,long long int upper)&#123;        if(root &#x3D;&#x3D; nullptr)        &#123;            return true;  &#x2F;&#x2F;空节点是合理的二叉搜索树        &#125;        if(root-&gt;val &lt;&#x3D; lower  root-&gt;val &gt;&#x3D; upper)  &#x2F;&#x2F;节点不为空，判断节点上的值是否在上下界内        &#123;            return false;        &#125;        &#x2F;&#x2F;更改上下界 递归遍历二叉树的左右子树        return helper(root-&gt;left,lower,root-&gt;val) &amp;&amp; helper(root-&gt;right,root-&gt;val,upper);    &#125;    bool isValidBST(TreeNode* root) &#123;        return helper(root,LONG_MIN,LONG_MAX);  &#x2F;&#x2F;从根节点开始，上下界都为空    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>方法2：中序遍历</strong> </p><p>根据二叉搜索树的性质，得知二叉搜索树中序遍历得到的值构成的序列一定是升序的，在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是。</p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; stack;  &#x2F;&#x2F;定义栈stack来存储未拜访过的树节点        long long inorder &#x3D; (long long)INT_MIN-1;  &#x2F;&#x2F;inorder用来存储上一个遍历到的树节点的值        while(!stack.empty() || root !&#x3D; nullptr)        &#123;            &#x2F;&#x2F;不断将root的左子节点加入栈 直到没有剩余的左节点            while(root !&#x3D; nullptr)            &#123;                stack.push(root);                root &#x3D; root-&gt;left;            &#125;            root &#x3D; stack.top();            stack.pop();  &#x2F;&#x2F;将当前子树最左边的节点从stack中取出            &#x2F;&#x2F;如果中序遍历得到的节点的值小于等于前一个inorder，说明不是二叉搜索树            if (root-&gt;val &lt;&#x3D; inorder)            &#123;                return false;            &#125;            inorder &#x3D; root-&gt;val;  &#x2F;&#x2F;将inorder设为当前节点的值            root &#x3D; root-&gt;right;  &#x2F;&#x2F;将root设为当前节点的右子节点，继续循环        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树路径总和</title>
    <link href="/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-112-路径总和"><a href="#LeetCode-112-路径总和" class="headerlink" title="LeetCode 112:路径总和"></a>LeetCode 112:路径总和</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>本题核心思想是对树进行一次遍历，在遍历是记录从根节点到当前节点的路径总和，以防止重复计算。 </p><p> </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：广度优先搜索</strong> </p><p>使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。 这样我们可以使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和。   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool hasPathSum(TreeNode* root, int targetSum) &#123;        if(root &#x3D;&#x3D; nullptr)  &#x2F;&#x2F;首先判断根节点是否存在        &#123;            return false;        &#125;        queue&lt;TreeNode*&gt; que_node;  &#x2F;&#x2F;定义一个队列 用于存储将要遍历的结点        queue&lt;int&gt; que_val;  &#x2F;&#x2F;定义一个队列 用于记录从根节点到当前节点路径和        que_node.push(root);  &#x2F;&#x2F;将根节点加入第一个队列        que_val.push(root-&gt;val);  &#x2F;&#x2F;将根节点的值加入第二个队列        &#x2F;&#x2F;迭代循环队列 直到队列为空        while(!que_node.empty())        &#123;            TreeNode* now &#x3D; que_node.front();            int temp &#x3D; que_val.front();            que_node.pop();            que_val.pop();            if(now-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; now-&gt;right &#x3D;&#x3D; nullptr)  &#x2F;&#x2F;不存在左右节点 则为叶节点            &#123;                if(temp &#x3D;&#x3D; targetSum)  &#x2F;&#x2F;判断路径和与目标值是否相等                &#123;                    return true;                &#125;                continue;  &#x2F;&#x2F;不相等则迭代继续            &#125;            if(now-&gt;left !&#x3D; nullptr)  &#x2F;&#x2F;存在左子节点            &#123;                que_node.push(now-&gt;left);  &#x2F;&#x2F;将左子节点加入第一个队列                que_val.push(now-&gt;left-&gt;val + temp);&#x2F;&#x2F;将左子节点值与当前路径和相加加入第二个队列            &#125;            if(now-&gt;right !&#x3D; nullptr)  &#x2F;&#x2F;存在右子节点            &#123;                que_node.push(now-&gt;right);  &#x2F;&#x2F;将右子节点加入第一个队列                que_val.push(now-&gt;right-val + temp);&#x2F;&#x2F;将右子节点值与当前路径和相加加入第二个队列            &#125;        &#125;        return false;  &#x2F;&#x2F;没有满足条件的 返回false    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>方法2：递归</strong> </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool hasPathSum(TreeNode *root, int sum) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            return false;        &#125;        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;            return sum &#x3D;&#x3D; root-&gt;val;        &#125;        return hasPathSum(root-&gt;left, sum - root-&gt;val)                hasPathSum(root-&gt;right, sum - root-&gt;val);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻转二叉树+对称二叉树</title>
    <link href="/2022/03/17/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/03/17/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-226-翻转二叉树"><a href="#LeetCode-226-翻转二叉树" class="headerlink" title="LeetCode 226:翻转二叉树"></a>LeetCode 226:翻转二叉树</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点root 的左右两颗子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以root 为根节点的整棵子树的翻转。</p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if(root &#x3D;&#x3D; nullptr)        &#123;            return root;        &#125;        TreeNode* left &#x3D; invertTree(root-&gt;left);        TreeNode* right &#x3D; invertTree(root-&gt;right);        root-&gt;left &#x3D; right;        root-&gt;right &#x3D; left;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> </p><h2 id="LeetCode-101-对称二叉树"><a href="#LeetCode-101-对称二叉树" class="headerlink" title="LeetCode 101:对称二叉树"></a>LeetCode 101:对称二叉树</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。 </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：递归</strong> </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isMirror(TreeNode* t1,TreeNode* t2)    &#123;        if(t1 &#x3D;&#x3D; nullptr &amp;&amp; t2 &#x3D;&#x3D; nullptr)        &#123;            return true;        &#125;        if(t1 &#x3D;&#x3D; nullptr  t2 &#x3D;&#x3D; nullptr)        &#123;            return false;        &#125;        return t1-&gt;val &#x3D;&#x3D; t2-&gt;val &amp;&amp; isMirror(t1-&gt;left,t2-&gt;right) &amp;&amp; isMirror(t1-&gt;right,t2-&gt;left);    &#125;    bool isSymmetric(TreeNode* root) &#123;        return isMirror(root-&gt;left,root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>方法2：迭代（利用队列）</strong> </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isMirror(TreeNode* t1,TreeNode* t2)    &#123;        queue&lt;TreeNode*&gt; q;        q.push(t1);        q.push(t2);        while(!q.empty())        &#123;            t1 &#x3D; q.front();            q.pop();            t2 &#x3D; q.front();            q.pop();            if(t1 &#x3D;&#x3D; nullptr &amp;&amp; t2 &#x3D;&#x3D; nullptr) continue;            if((t1 &#x3D;&#x3D; nullptr  t2 &#x3D;&#x3D; nullptr)  t1-&gt;val !&#x3D; t2-&gt;val) return false;            q.push(t1-&gt;left);            q.push(t2-&gt;right);            q.push(t1-&gt;right);            q.push(t2-&gt;left);        &#125;        return true;    &#125;    bool isSymmetric(TreeNode\* root) &#123;        return isMirror(root-&gt;left,root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> </p><p><a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用栈实现队列+用队列实现栈</title>
    <link href="/2022/03/11/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2022/03/11/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-232-用栈实现队列"><a href="#LeetCode-232-用栈实现队列" class="headerlink" title="LeetCode 232:用栈实现队列"></a>LeetCode 232:用栈实现队列</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>栈 队列 模拟  </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>请你仅使用两个栈实现先入先出队列,队列支持一般队列支持的所有操作（push、pop、peek、empty） 实现 MyQueue 类： </p><p>void push(int x) 将元素 x 推到队列的末尾 </p><p>int pop() 从队列的开头移除并返回元素 </p><p>int peek() 返回队列开头的元素 </p><p>boolean empty() 如果队列为空，返回 true ；否则，返回 false  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyQueue &#123;public:    stack&lt;int&gt; stIn;  &#x2F;&#x2F;创建一个栈stIn 用于进栈    stack&lt;int&gt; stOut; &#x2F;&#x2F;创建一个栈stOut 用于出栈    MyQueue() &#123;    &#125;        void push(int x) &#123;        stIn.push(x);  &#x2F;&#x2F;将元素压入栈中    &#125;    int pop() &#123;        if(stOut.empty())  &#x2F;&#x2F;如果栈stOut为空 则将栈stIn中所有元素压入栈stOut中        &#123;            while(!stIn.empty())            &#123;                stOut.push(stIn.top());  &#x2F;&#x2F;将栈stIn栈顶元素压入栈stOut中                stIn.pop();  &#x2F;&#x2F;栈顶元素压入栈stOut后将元素删除            &#125;        &#125;        &#x2F;&#x2F;当栈stOut不为空时 则直接弹出栈stOut栈顶元素        int res &#x3D; stOut.top();        stOut.pop();        return res;    &#125;    int peek() &#123;        int res &#x3D; this-&gt;pop();  &#x2F;&#x2F;直接使用已有的pop函数获取栈顶元素        stOut.push(res);  &#x2F;&#x2F;因为pop函数弹出了元素res 所以再添加回去        return res;    &#125;    bool empty() &#123;        return stIn.empty() &amp;&amp; stOut.empty();  &#x2F;&#x2F;当栈stIn和栈stOut都不为空时 队列才不为空    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>  <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/232-yong-zhan-shi-xian-dui-lie-liang-ge-zhan-lai-m/">LeetCode题解+动画演示</a>  </p><h2 id="LeetCode-225：用队列实现栈"><a href="#LeetCode-225：用队列实现栈" class="headerlink" title="LeetCode 225：用队列实现栈"></a>LeetCode 225：用队列实现栈</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>队列 栈 模拟  </p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、 pop 和 empty）。 实现 MyStack 类： </p><p>void push(int x) 将元素 x 压入栈顶。 </p><p>int pop() 移除并返回栈顶元素。 </p><p>int top() 返回栈顶元素。 </p><p>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：两个队列实现栈</strong> </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyStack &#123;public:    queue&lt;int&gt; queue1;  &#x2F;&#x2F;创建一个队列queue1 用于存储所有入栈元素    queue&lt;int&gt; queue2;  &#x2F;&#x2F;创建一个队列queue2 用于临时存储即将入栈的元素    MyStack() &#123;    &#125;        &#x2F;&#x2F;使用两个队列模拟元素入栈    void push(int x) &#123;        queue2.push(x);  &#x2F;&#x2F;将入栈元素插入临时队列queue2        while(!queue1.empty())  &#x2F;&#x2F;将队列queue1中所有元素插入临时队列queue2        &#123;            queue2.push(queue1.front());  &#x2F;&#x2F;将队列queue1中头元素插入队列queue2中            queue1.pop();  &#x2F;&#x2F;删除队列queue1头元素        &#125;        swap(queue1,queue2);  &#x2F;&#x2F;为了避免打乱元素顺序 交换队列queue1和queue2    &#125;    int pop() &#123;        int res &#x3D; queue1.front();        queue1.pop();        return res;    &#125;    int top() &#123;        int res &#x3D; queue1.front();        return res;    &#125;    bool empty() &#123;        return queue1.empty();  &#x2F;&#x2F;因为queue1包含了栈中所有元素 所以只需要检查queue1是否为空即可        &#x2F;&#x2F;queue2作为临时队列 不永久存储栈中的元素    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> </p><p><strong>方法二：一个队列实现栈</strong></p><p>入栈操作时，首先获得入栈前的元素个数 n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyStack &#123;public:    queue&lt;int&gt; q;    MyStack() &#123;    &#125;    void push(int x) &#123;        int n &#x3D; q.size();        q.push(x);        for (int i &#x3D; 0; i &lt; n; i++) &#123;            q.push(q.front());            q.pop();        &#125;    &#125;    int pop() &#123;        int r &#x3D; q.front();        q.pop();        return r;    &#125;    int top() &#123;        int r &#x3D; q.front();        return r;    &#125;    bool empty() &#123;        return q.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> </p><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>N叉树的前序遍历</title>
    <link href="/2022/03/10/N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/03/10/N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-589题：N叉树的前序遍历"><a href="#LeetCode-589题：N叉树的前序遍历" class="headerlink" title="LeetCode 589题：N叉树的前序遍历"></a>LeetCode 589题：N叉树的前序遍历</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h4><blockquote><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p></blockquote><p> <a href="http://c.biancheng.net/view/6826.html">C++STL中emplace_back()和push_back()的区别</a>  </p><h4 id="C-const-关键字"><a href="#C-const-关键字" class="headerlink" title="C++ const 关键字"></a>C++ const 关键字</h4><blockquote><p>const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。 </p></blockquote><p><a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">菜鸟教程：C++ const 关键字小结</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个 n 叉树的根节点  root ，返回其节点值的前序遍历。 n 叉树在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void helper(const Node* root, vector&lt;int&gt; &amp; res) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            return;        &#125;        res.emplace_back(root-&gt;val);        for (auto &amp; ch : root-&gt;children) &#123;    &#x2F;&#x2F;auto 类型也是 C++11 新标准中的，用来自动获取变量的类型            helper(ch, res);        &#125;    &#125;    vector&lt;int&gt; preorder(Node* root) &#123;        vector&lt;int&gt; res;        helper(root, res);        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> </p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="/2022/03/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2022/03/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-144题：二叉树的前序遍历"><a href="#LeetCode-144题：二叉树的前序遍历" class="headerlink" title="LeetCode 144题：二叉树的前序遍历"></a>LeetCode 144题：二叉树的前序遍历</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="参数传递时什么时候需要传入参数的引用-amp"><a href="#参数传递时什么时候需要传入参数的引用-amp" class="headerlink" title="参数传递时什么时候需要传入参数的引用&amp;"></a>参数传递时什么时候需要传入参数的引用&amp;</h4><p>当对参数的修改结果需要带回主函数时在传递参数时则需要在参数前加取地址符&amp; </p><p>CSDN博客：（易错点）什么时候要传入参数的引用“&amp;“：<a href="https://blog.csdn.net/dyw_666666/article/details/107823466">https://blog.csdn.net/dyw_666666/article/details/107823466</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根-&gt;左-&gt;右   </p><p><strong>方法一：递归法</strong> </p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">AC代码：class Solution &#123;public:    void preorder(TreeNode* root,vector&lt;int&gt; &amp;res)&#123;        if(root &#x3D;&#x3D; nullptr)        &#123;            return;        &#125;        res.push_back(root-&gt;val);        preorder(root-&gt;left,res);        preorder(root-&gt;right,res);    &#125;    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        preorder(root,res);        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>方法二：迭代法</strong> </p><p>方法1中的递归函数可以用迭代的方法实现，迭代法利用栈来遍历二叉树</p><p>LeetCode题解+动画演示 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/">二叉树前序遍历 迭代法</a> </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        if (root &#x3D;&#x3D; nullptr) &#123;            return res;        &#125;        stack&lt;TreeNode*&gt; stk;        TreeNode* node &#x3D; root;        while (!stk.empty() || node !&#x3D; nullptr) &#123;            while (node !&#x3D; nullptr) &#123;                res.emplace_back(node-&gt;val);                stk.emplace(node);                node &#x3D; node-&gt;left;            &#125;            node &#x3D; stk.top();            stk.pop();            node &#x3D; node-&gt;right;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> </p><h2 id="LeetCode-94题：二叉树的中序遍历"><a href="#LeetCode-94题：二叉树的中序遍历" class="headerlink" title="LeetCode 94题：二叉树的中序遍历"></a>LeetCode 94题：二叉树的中序遍历</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1：递归法</strong></p><p>左-&gt;根-&gt;右   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void inorder(TreeNode* root,vector&lt;int&gt; &amp;ans)    &#123;        if(root &#x3D;&#x3D; nullptr)        &#123;            return;        &#125;        inorder(root-&gt;left,ans);        ans.push_back(root-&gt;val);        inorder(root-&gt;right,ans);    &#125;    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ans;        inorder(root,ans);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> <strong>方法2：迭代法</strong></p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ans;        if(root &#x3D;&#x3D; nullptr)  return ans;        stack&lt;TreeNode*&gt; stk;        while(!stk.empty() || root !&#x3D; nullptr)        &#123;            while(root !&#x3D; nullptr)            &#123;                stk.push(root);                root &#x3D; root-&gt;left;            &#125;            root &#x3D; stk.top();            stk.pop();            ans.push_back(root-&gt;val);            root &#x3D; root-&gt;right;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="LeetCode-145题：二叉树的后序遍历"><a href="#LeetCode-145题：二叉树的后序遍历" class="headerlink" title="LeetCode 145题：二叉树的后序遍历"></a>LeetCode 145题：二叉树的后序遍历</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>左-&gt;右-&gt;根   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void postorder(TreeNode* root,vector&lt;int&gt; &amp;ans)    &#123;        if(root &#x3D;&#x3D; nullptr)        &#123;            return;        &#125;        postorder(root-&gt;left,ans);        postorder(root-&gt;right,ans);        ans.push_back(root-&gt;val);    &#125;    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ans;        postorder(root,ans);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="LeetCode-102-二叉树的层序遍历"><a href="#LeetCode-102-二叉树的层序遍历" class="headerlink" title="LeetCode 102:二叉树的层序遍历"></a>LeetCode 102:二叉树的层序遍历</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>二叉树 队列 广度优先搜索  </p><h4 id="二维vector容器的使用"><a href="#二维vector容器的使用" class="headerlink" title="二维vector容器的使用"></a>二维vector容器的使用</h4><p>res.push_back(vector&lt;int&gt;());  //向二维vector容器res中添加一行</p><p>res.back().push_back(node-&gt;val);  //向二维容器的最后一行插入一个元素node-&gt;val</p><p>其中res.back()是指二维容器res的最后一行</p><p>关于C++中vector&lt;vector&lt;int&gt; &gt;的使用：<a href="https://www.cnblogs.com/tyty-Somnuspoppy/p/9361821.html">https://www.cnblogs.com/tyty-Somnuspoppy/p/9361821.html</a></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><blockquote><p>用广度优先搜索+队列解决二叉树的层序遍历 我们可以用一种巧妙的方法修改广度优先搜索： 首先根元素入队 当队列不为空的时候 求当前队列的长度 currentLevelSize 依次从队列中取currentLevelSize个元素进行拓展，然后进入下一次迭代 它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取currentLevelSize个元素。在上述过程中的第 i 次迭代就得到了二叉树的第 i层的 currentLevelSize个元素。</p></blockquote><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; res;  &#x2F;&#x2F;定义二维vector容器res用来存储树中元素        if(root &#x3D;&#x3D; nullptr)        &#123;            return res;        &#125;        queue&lt;TreeNode*&gt; q;  &#x2F;&#x2F;定义队列q临时存储树中元素        q.push(root);  &#x2F;&#x2F;将树的根节点插入队列        while(!q.empty())        &#123;            int currentLevelSize &#x3D; q.size();  &#x2F;&#x2F;定义队列的当前长度currentLevelSize            res.push_back(vector&lt;int&gt;());  &#x2F;&#x2F;向二维vector容器res中添加一行            for(int i&#x3D;1; i&lt;&#x3D;currentLevelSize; i++)            &#123;                auto node &#x3D; q.front();  &#x2F;&#x2F;定义临时结点node为队列头结点                q.pop();  &#x2F;&#x2F;弹出队列头结点                res.back().push_back(node-&gt;val);  &#x2F;&#x2F;将队列头结点元素的值存入res中                &#x2F;&#x2F;将结点的左右儿子节点插入队列中                if(node-&gt;left)                &#123;                    q.push(node-&gt;left);                &#125;                if(node-&gt;right)                &#123;                    q.push(node-&gt;right);                &#125;            &#125;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++标准模板库（C++STL）</title>
    <link href="/2022/03/04/c%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88cstl%EF%BC%89/"/>
    <url>/2022/03/04/c%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88cstl%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-iterator迭代器"><a href="#1-iterator迭代器" class="headerlink" title="1.iterator迭代器"></a>1.iterator迭代器</h2><h3 id="1-定义和初始化"><a href="#1-定义和初始化" class="headerlink" title="1.定义和初始化"></a>1.定义和初始化</h3><p>每种容器都定义了自己的迭代器类型，如vector </p><p>vector<int>::iterator it;  //定义一个名为it的变量 </p><p>每种容器都定义了一对名为begin和end的函数，用于返回迭代器 </p><p>vector<int> ivec; </p><p>vector<int>::iterator it1 = ivec.begin();  //将迭代器it1指向ivec的第一个元素 </p><p>vector<int>::iterator it2 = ivec.end();  //将迭代器it2指向ivec容器的最后一个元素的下一个位置 end并不指向容器的任何元素  </p><h3 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2.常用操作"></a>2.常用操作</h3><p>vector<int>:: iterator it; </p><p>1.it +/- n; </p><p>2.it1 +/-= it2; </p><p>3.it1-it2; </p><p>4.&gt;,&gt;=,&lt;,&lt;=  </p><h2 id="2-vector容器"><a href="#2-vector容器" class="headerlink" title="2.vector容器"></a>2.vector容器</h2><h3 id="1-创建vector对象"><a href="#1-创建vector对象" class="headerlink" title="1.创建vector对象"></a>1.创建vector对象</h3><p>创建vector容器有三种形式 </p><p>1.不指定容器的个数：vector<int> v;</p><p>2.创建时指定容器的大小：vector<double> v(10);</p><p>3.创建一个具有n个元素的向量容器，每个元素具有指定的初始值 vector<double> v(10,8.6)  //v向量容器，共有10个元素，每个元素的初始值为8.6  </p><h3 id="2-尾部元素扩张"><a href="#2-尾部元素扩张" class="headerlink" title="2.尾部元素扩张"></a>2.尾部元素扩张</h3><p>v.push_back(num);  </p><h3 id="3-下标方式访问vector元素"><a href="#3-下标方式访问vector元素" class="headerlink" title="3.下标方式访问vector元素"></a>3.下标方式访问vector元素</h3><p>类似于数组的访问方式。对于vector对象，可以采用下标方式随意访问它的某个元素，也可以通过下标方式对某个元素重新赋值 </p><p>vector<int> v(3); </p><p>v[0]=2,v[1]=7,v[2]=9; </p><p>cout&lt;&lt;v[0]&lt;&lt;” “&lt;&lt;v[1]&lt;&lt;” “&lt;&lt;v[2]&lt;&lt;endl;  </p><h3 id="4-用迭代器访问vector容器"><a href="#4-用迭代器访问vector容器" class="headerlink" title="4.用迭代器访问vector容器"></a>4.用迭代器访问vector容器</h3><p>vector<int> v(3); </p><p>v[0]=2,v[1]=7,v[2]=9; </p><p>vector<int>::iterator it;  //定义迭代器 变量 </p><p>for(it=v.begin(); it!=v.end(); it++) </p><p>{ cout&lt;&lt;*it&lt;&lt;” “;  //输出迭代器上的元素值 }  </p><h3 id="5-插入元素"><a href="#5-插入元素" class="headerlink" title="5.插入元素"></a>5.插入元素</h3><p>insert()方法可以在vector对象的任意位置前插入一个新元素 </p><p>insert()方法要求插入的位置是元素的迭代器的位置，而不是元素的下标 </p><p>v.insert(v.begin(),8);  //在最前面插入新元素，元素值为8 </p><p>v.insert(v.begin()+2,1);  //在第2个元素前插入新元素1 </p><p>v.insert(v.end(),3);  //在向量末尾追加新元素3  </p><h3 id="6-元素的删除"><a href="#6-元素的删除" class="headerlink" title="6.元素的删除"></a>6.元素的删除</h3><p>erase()方法可以删除vector中迭代器所指向的一个元素或者一段区间中的所有元素 </p><p>v.erase(v.begin()+2);  //删除第二个元素，从0开始计数 </p><p>v.erase(v.begin()+1,v.begin()+5);  //删除迭代器第1到5区间的所有元素 </p><p>clear()方法则一次性删除vector中的所有元素 </p><p>v.clear();  //清空向量  </p><h3 id="7-使用reverse反向排列算法"><a href="#7-使用reverse反向排列算法" class="headerlink" title="7.使用reverse反向排列算法"></a>7.使用reverse反向排列算法</h3><p>reverse(v.begin(),v.end());  //反向排列向量从首到尾间的元素  </p><h3 id="8-使用sort算法对向量元素排序"><a href="#8-使用sort算法对向量元素排序" class="headerlink" title="8.使用sort算法对向量元素排序"></a>8.使用sort算法对向量元素排序</h3><p>sort(v.begin(),v.end());   自定义降序排列比较函数cmp bool cmp(const int &amp;a,const int &amp;b) { return a&gt;b; } sort(v.begin(),v.end(),cmp)  //按cmp函数比较规则排序  </p><h3 id="9-向量的大小"><a href="#9-向量的大小" class="headerlink" title="9.向量的大小"></a>9.向量的大小</h3><p>v.size()  //方法返回向量大小，即元素的个数 v.empty()  //方法返回向量是否为空  </p><h2 id="3-string容器"><a href="#3-string容器" class="headerlink" title="3.string容器"></a>3.string容器</h2><p> </p><h2 id="4-set容器"><a href="#4-set容器" class="headerlink" title="4.set容器"></a>4.set容器</h2><p> </p><h2 id="5-multiset容器"><a href="#5-multiset容器" class="headerlink" title="5.multiset容器"></a>5.multiset容器</h2><p> </p><h2 id="6-map容器"><a href="#6-map容器" class="headerlink" title="6.map容器"></a>6.map容器</h2><p> </p><h2 id="7-multimap容器"><a href="#7-multimap容器" class="headerlink" title="7.multimap容器"></a>7.multimap容器</h2><p> </p><h2 id="8-queue容器"><a href="#8-queue容器" class="headerlink" title="8.queue容器"></a>8.queue容器</h2><p> </p><h2 id="9-priority-queue容器"><a href="#9-priority-queue容器" class="headerlink" title="9.priority_queue容器"></a>9.priority_queue容器</h2><p> </p><h2 id="10-stack容器"><a href="#10-stack容器" class="headerlink" title="10.stack容器"></a>10.stack容器</h2><p> </p><h2 id="11-algorithm容器"><a href="#11-algorithm容器" class="headerlink" title="11.algorithm容器"></a>11.algorithm容器</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组</title>
    <link href="/2022/02/28/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2022/02/28/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-566题：重塑矩阵"><a href="#LeetCode-566题：重塑矩阵" class="headerlink" title="LeetCode 566题：重塑矩阵"></a>LeetCode 566题：重塑矩阵</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>vector容器定义二维数组  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将二维数组映射成一个一维数组，将这个一维数组映射回 r 行 c 列的二维数组。 对于x∈[0,mn)，第 x个元素在 nums 中对应的下标为(x / n,x % n)，而在新的重塑矩阵中对应的下标为(x / c,x % c)。我们直接进行赋值即可。   AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int r, int c) &#123;        int m &#x3D; mat.size(),n &#x3D; mat\[0\].size();        if(m*n !&#x3D; r*c)        &#123;            return mat;        &#125;        vector&lt;vector&lt;int&gt;&gt; ans(r,vector&lt;int&gt;(c));  &#x2F;&#x2F;vector容器定义一个二维数组ans        for(int i&#x3D;0; i&lt;m*n; i++)        &#123;            ans[i&#x2F;c][i%c] &#x3D; mat[i&#x2F;n][i%n];        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> </p><h2 id="LeetCode-118题：杨辉三角"><a href="#LeetCode-118题：杨辉三角" class="headerlink" title="LeetCode 118题：杨辉三角"></a>LeetCode 118题：杨辉三角</h2><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>动态规划  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;        vector&lt;vector&lt;int&gt;&gt; ans(numRows);        for(int i&#x3D;0; i&lt;numRows; i++)        &#123;            ans[i].resize(i + 1);  &#x2F;&#x2F;resize 改变当前使用数据的大小，如果它比当前使用的大，则填充默认值            ans[i][0]&#x3D;ans[i][i]&#x3D;1;            for(int j&#x3D;1; j&lt;i; j++)            &#123;                ans[i][j] &#x3D; ans[i-1][j-1]+ans[i-1][j];            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ vector 容器浅析</title>
    <link href="/2022/02/27/c-vector-%E5%AE%B9%E5%99%A8%E6%B5%85%E6%9E%90/"/>
    <url>/2022/02/27/c-vector-%E5%AE%B9%E5%99%A8%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>刷LeetCode有所收获的第一天！  </p><h2 id="LeetCode-350题：两个数组的交集"><a href="#LeetCode-350题：两个数组的交集" class="headerlink" title="LeetCode 350题：两个数组的交集"></a>LeetCode 350题：两个数组的交集</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>方法1</strong></p><p>哈希表（不太会） 学习C++算法哈希（Hash） B站收藏   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        if(nums1.size()&gt;nums2.size())        &#123;            return intersect(nums2,nums1);        &#125;        unordered_map &lt;int,int&gt; m;        for(int num : nums1)        &#123;            m[num]++;        &#125;        vector&lt;int&gt; intersection;        for(int num : nums2)        &#123;            if(m.count(num))            &#123;                intersection.push_back(num);                m[num]--;                if(m[num] &#x3D;&#x3D; 0)                &#123;                    m.erase(num);                &#125;            &#125;        &#125;        return intersection;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>方法2</strong> </p><p>排序+双指针（用到了C++ vector容器） </p><p>学习C++  STL标准库函数+vector 容器 </p><p><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector 容器浅析</a>   </p><p>AC代码：</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        sort(nums1.begin(),nums1.end());        sort(nums2.begin(),nums2.end());        int length1 &#x3D; nums1.size(),length2 &#x3D; nums2.size();        int index1 &#x3D; 0,index2 &#x3D; 0;        vector&lt;int&gt; result;        while(index1&lt;length1 &amp;&amp; index2&lt;length2)        &#123;            if(nums1[index1]&gt;nums2[index2])            &#123;                index2++;            &#125;            else if(nums1[index1]&lt;nums2[index2])            &#123;                index1++;            &#125;            else            &#123;                result.push_back(nums1[index1]);                index1++;                index2++;            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/">LeetCode题解</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UPC疫情防控通自动提交脚本—云函数实现</title>
    <link href="/2022/02/23/upc%E7%96%AB%E6%83%85%E9%98%B2%E6%8E%A7%E9%80%9A%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC-%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/02/23/upc%E7%96%AB%E6%83%85%E9%98%B2%E6%8E%A7%E9%80%9A%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC-%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p> </p><h3 id="1、获取Server酱的API-Key实现微信推送"><a href="#1、获取Server酱的API-Key实现微信推送" class="headerlink" title="1、获取Server酱的API Key实现微信推送"></a>1、获取Server酱的API Key实现微信推送</h3><p>打开<a href="http://sc.ftqq.com/3.version">Server酱主页</a>，按照页面指示获取Key并绑定微信，复制Key备用。</p><p> </p><h3 id="2、代码文件准备"><a href="#2、代码文件准备" class="headerlink" title="2、代码文件准备"></a>2、代码文件准备</h3><p>下载本仓库的代码，修改Index.js中的代码，使用上述准备的内容替换对应内容即可，修改完后打包即可。</p><p> </p><h3 id="3、新建云函数"><a href="#3、新建云函数" class="headerlink" title="3、新建云函数"></a>3、新建云函数</h3><p>这里以腾讯云为例，进入<a href="https://console.cloud.tencent.com/scf">腾讯云函数页面</a>，点击侧栏的函数服务，新建一个函数。</p><p>如果需要Server酱通知，请不要选择广州地区，其他地区请自行测试</p><p>函数名称随意，运行环境选择Nodejs12.16，创建方式选择空白函数即可，点击完成。 选择函数代码标签，提交方法选择本地上传zip包，上传方式选择在线安装依赖，选择保存并测试。成功的话转下一步，失败的话请检查相关字符串是否正确。  </p><h3 id="4、设置触发器"><a href="#4、设置触发器" class="headerlink" title="4、设置触发器"></a>4、设置触发器</h3><p>选择左侧触发管理，创建一个新的触发器。选择定时触发，出发周期自定义，自己根据想要自动提交的时间输入Cron数据即可。推荐使用0 1 1,8 * * * *即可，该触发时间为每天的01:01和08:01，防止因为系统或某方面原因而失败。</p><p> </p><h3 id="5、数据配置"><a href="#5、数据配置" class="headerlink" title="5、数据配置"></a>5、数据配置</h3><p>如果需要修改表单数据，在自动提交之前手动通过提交一次数据即可，第二天将会自动修正数据。</p><p> </p><p>博客转载于：<a href="https://github.com/tienskowl/AutoReport">https://github.com/tienskowl/AutoReport</a></p>]]></content>
    
    
    <categories>
      
      <category>解忧杂货</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题！</title>
    <link href="/2022/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2022/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>立个flag 每日一道LeetCode算法题+百词斩背单词！</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
